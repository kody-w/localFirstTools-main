<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Reality Corruption Simulator</title>
    <meta name="description" content="Explore a pristine procedural planet with diverse biomes that slowly reveals it's a broken simulation - exploit the bugs or repair reality before total corruption">
    <!-- 3d, threejs, simulation, glitch, horror, experimental -->
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            overflow: hidden;
            background: #000;
            font-family: 'Courier New', monospace;
        }
        #container { width: 100vw; height: 100vh; position: relative; }
        canvas { display: block; }

        /* Glitch overlay effects */
        #glitch-overlay {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            pointer-events: none;
            z-index: 100;
            mix-blend-mode: screen;
        }

        .scanlines {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: repeating-linear-gradient(
                0deg,
                rgba(0,0,0,0.1) 0px,
                rgba(0,0,0,0.1) 1px,
                transparent 1px,
                transparent 2px
            );
            pointer-events: none;
            z-index: 101;
            opacity: 0;
            transition: opacity 0.5s;
        }

        .screen-tear {
            position: fixed;
            left: 0;
            width: 100%;
            height: 10px;
            background: linear-gradient(90deg, #f0f, #0ff, #ff0);
            pointer-events: none;
            z-index: 102;
            opacity: 0;
            transform: scaleX(0);
        }

        #hud {
            position: fixed;
            top: 20px;
            left: 20px;
            color: #0f0;
            z-index: 200;
            text-shadow: 0 0 10px #0f0;
            user-select: none;
        }

        #hud.pristine {
            color: #333;
            text-shadow: none;
        }

        #hud.pristine #corruption-meter {
            display: none;
        }

        #hud.pristine #corruption-text {
            display: none;
        }

        #welcome-panel {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255,255,255,0.95);
            padding: 40px 60px;
            border-radius: 10px;
            text-align: center;
            z-index: 300;
            color: #333;
            font-family: 'Segoe UI', Arial, sans-serif;
            box-shadow: 0 10px 40px rgba(0,0,0,0.2);
        }

        #welcome-panel h1 {
            margin: 0 0 10px 0;
            font-size: 32px;
            color: #2a5aa7;
        }

        #welcome-panel p {
            margin: 5px 0;
            color: #666;
            font-size: 14px;
        }

        #welcome-panel .start-btn {
            margin-top: 20px;
            padding: 12px 30px;
            background: #2a5aa7;
            color: white;
            border: none;
            border-radius: 5px;
            font-size: 16px;
            cursor: pointer;
            transition: background 0.2s;
        }

        #welcome-panel .start-btn:hover {
            background: #1e4a8a;
        }

        #welcome-panel .start-btn:focus-visible {
            outline: 3px solid #1e4a8a;
            outline-offset: 2px;
            box-shadow: 0 0 0 5px rgba(30, 74, 138, 0.3);
        }

        .controls-pristine {
            color: #333 !important;
        }

        #controls.hidden {
            display: none;
        }

        #crosshair.pristine {
            border-color: rgba(100,100,100,0.3);
        }

        #crosshair.pristine::before,
        #crosshair.pristine::after {
            background: rgba(100,100,100,0.3);
        }

        #corruption-meter {
            width: 200px;
            height: 20px;
            background: #111;
            border: 2px solid #0f0;
            margin-top: 10px;
            position: relative;
            overflow: hidden;
        }

        #corruption-fill {
            height: 100%;
            background: linear-gradient(90deg, #0f0, #ff0, #f00);
            width: 0%;
            transition: width 0.3s;
        }

        #corruption-glitch {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: repeating-linear-gradient(
                90deg,
                transparent 0px,
                transparent 5px,
                rgba(255,0,255,0.3) 5px,
                rgba(255,0,255,0.3) 10px
            );
            animation: glitchSlide 0.1s infinite;
            opacity: 0;
        }

        @keyframes glitchSlide {
            0% { transform: translateX(-10px); }
            100% { transform: translateX(10px); }
        }

        #messages {
            position: fixed;
            bottom: 20px;
            left: 20px;
            color: #0f0;
            z-index: 200;
            max-width: 400px;
            font-size: 12px;
        }

        .message {
            padding: 5px 10px;
            background: rgba(0,0,0,0.7);
            margin-bottom: 5px;
            border-left: 3px solid #0f0;
            animation: fadeIn 0.3s;
        }

        .message.warning { border-color: #ff0; color: #ff0; }
        .message.error { border-color: #f00; color: #f00; }
        .message.glitched {
            animation: textGlitch 0.1s infinite;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateX(-20px); }
            to { opacity: 1; transform: translateX(0); }
        }

        @keyframes textGlitch {
            0% { transform: translateX(0); }
            25% { transform: translateX(-2px) skewX(5deg); }
            50% { transform: translateX(2px) skewX(-5deg); }
            75% { transform: translateX(-1px); }
            100% { transform: translateX(0); }
        }

        #controls {
            position: fixed;
            top: 20px;
            right: 20px;
            color: #0f0;
            z-index: 200;
            text-align: right;
            font-size: 12px;
        }

        #mode-indicator {
            font-size: 16px;
            margin-bottom: 10px;
            padding: 5px 15px;
            background: rgba(0,50,0,0.8);
            border: 1px solid #0f0;
        }

        #mode-indicator.exploit {
            background: rgba(50,0,50,0.8);
            border-color: #f0f;
            color: #f0f;
        }

        #stats {
            margin-top: 10px;
            font-size: 11px;
            opacity: 0.8;
        }

        .void-flash {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: #000;
            z-index: 500;
            opacity: 0;
            pointer-events: none;
        }

        #reality-status {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #fff;
            font-size: 48px;
            z-index: 1000;
            text-align: center;
            opacity: 0;
            pointer-events: none;
            text-shadow: 0 0 30px #f00;
        }

        #crosshair {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            border: 2px solid rgba(0,255,0,0.5);
            border-radius: 50%;
            z-index: 150;
            pointer-events: none;
        }

        #crosshair::before, #crosshair::after {
            content: '';
            position: absolute;
            background: rgba(0,255,0,0.5);
        }
        #crosshair::before {
            width: 2px; height: 6px;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
        }
        #crosshair::after {
            width: 6px; height: 2px;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
        }

        #instructions {
            position: fixed;
            bottom: 20px;
            right: 20px;
            color: #0f0;
            font-size: 11px;
            z-index: 200;
            text-align: right;
            opacity: 0.7;
        }
    </style>
</head>
<body>
    <div id="container" role="application" aria-label="Reality Corruption Simulator - 3D interactive world. Use WASD to move, mouse to look, Space to jump."></div>
    <div id="glitch-overlay"></div>
    <div class="scanlines"></div>
    <div class="screen-tear" id="tear1"></div>
    <div class="screen-tear" id="tear2"></div>
    <div class="void-flash" id="void-flash"></div>

    <div id="welcome-panel">
        <h1>Welcome to Planet Reality</h1>
        <p>A pristine simulated world awaits your exploration</p>
        <p style="font-size: 12px; margin-top: 15px;">Start in the city, then venture into forests, deserts, mountains, and oceans.<br>Walk far enough and you'll circumnavigate the entire planet.</p>
        <button class="start-btn" onclick="this.parentElement.style.display='none'">Enter Simulation</button>
    </div>

    <div id="hud" class="pristine">
        <div id="title">REALITY v1.0.0 - All Systems Normal</div>
        <div id="corruption-meter" role="progressbar" aria-valuenow="0" aria-valuemin="0" aria-valuemax="100" aria-label="Reality corruption level">
            <div id="corruption-fill"></div>
            <div id="corruption-glitch"></div>
        </div>
        <div id="corruption-text">Corruption: 0%</div>
    </div>

    <div id="controls" class="hidden">
        <div id="mode-indicator">MODE: OBSERVE</div>
        <div id="stats">
            <div>Anomalies: <span id="anomaly-count">0</span></div>
            <div>Repaired: <span id="repair-count">0</span></div>
            <div>Exploited: <span id="exploit-count">0</span></div>
        </div>
    </div>

    <div id="messages" role="log" aria-live="polite" aria-label="Game messages and notifications"></div>
    <div id="crosshair" class="pristine"></div>

    <div id="instructions">
        WASD - Move | Mouse - Look | Space - Jump<br>
        <span id="pristine-hint">Explore the planet freely. Everything is fine.</span>
        <span id="corrupt-hint" style="display:none;">E - Repair Mode | Q - Exploit Mode<br>Click - Interact with Anomaly</span>
    </div>

    <div id="reality-status"></div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // ============== GLITCH SHADER ==============
        const GlitchShader = {
            uniforms: {
                tDiffuse: { value: null },
                time: { value: 0 },
                corruption: { value: 0 },
                glitchIntensity: { value: 0 }
            },
            vertexShader: `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform sampler2D tDiffuse;
                uniform float time;
                uniform float corruption;
                uniform float glitchIntensity;
                varying vec2 vUv;

                float random(vec2 st) {
                    return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123);
                }

                void main() {
                    vec2 uv = vUv;

                    // Horizontal shift glitch
                    float glitchLine = step(0.99 - corruption * 0.1, random(vec2(floor(uv.y * 50.0), time)));
                    uv.x += glitchLine * (random(vec2(time, uv.y)) - 0.5) * 0.1 * glitchIntensity;

                    // Color channel separation (chromatic aberration)
                    float aberration = corruption * 0.01 * glitchIntensity;
                    vec4 color;
                    color.r = texture2D(tDiffuse, uv + vec2(aberration, 0.0)).r;
                    color.g = texture2D(tDiffuse, uv).g;
                    color.b = texture2D(tDiffuse, uv - vec2(aberration, 0.0)).b;
                    color.a = 1.0;

                    // Random color inversion
                    float invertBlock = step(0.995 - corruption * 0.01, random(vec2(floor(uv.x * 20.0), floor(uv.y * 20.0) + time)));
                    color.rgb = mix(color.rgb, 1.0 - color.rgb, invertBlock * glitchIntensity);

                    // Scanline flicker
                    float scanline = sin(uv.y * 800.0 + time * 10.0) * 0.02 * corruption;
                    color.rgb += scanline;

                    // Static noise
                    float noise = random(uv + time) * corruption * 0.1 * glitchIntensity;
                    color.rgb += noise;

                    // Void bleed at edges
                    float voidEdge = smoothstep(0.0, 0.1 * corruption, min(min(uv.x, 1.0 - uv.x), min(uv.y, 1.0 - uv.y)));
                    color.rgb *= voidEdge;

                    gl_FragColor = color;
                }
            `
        };

        // ============== GAME STATE ==============
        const state = {
            corruption: 0,
            corruptionStarted: false,  // Pristine mode until triggered
            mode: 'observe', // observe, repair, exploit
            anomalies: [],
            repairCount: 0,
            exploitCount: 0,
            messages: [],
            gameOver: false,
            realityCollapsed: false,
            physicsInverted: false,
            timeDistortion: 1,
            voidZones: [],
            glitchIntensity: 0,
            explorationTime: 0  // Track time spent exploring
        };

        // ============== SCENE SETUP ==============
        const container = document.getElementById('container');
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB);
        scene.fog = new THREE.Fog(0x89CFF0, 100, 500);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
        camera.position.set(0, 10, 20);  // Will be adjusted after terrain generates

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        container.appendChild(renderer.domElement);

        // Post-processing
        const composer = new EffectComposer(renderer);
        composer.addPass(new RenderPass(scene, camera));

        const bloomPass = new UnrealBloomPass(
            new THREE.Vector2(window.innerWidth, window.innerHeight),
            0.3, 0.4, 0.85
        );
        composer.addPass(bloomPass);

        const glitchPass = new ShaderPass(GlitchShader);
        composer.addPass(glitchPass);

        // Controls
        const controls = new PointerLockControls(camera, document.body);

        container.addEventListener('click', () => {
            if (!controls.isLocked) {
                controls.lock();
            } else {
                // Check for terminal interaction first
                if (!state.corruptionStarted) {
                    checkTerminalInteraction();
                } else {
                    interactWithAnomaly();
                }
            }
        });

        function checkTerminalInteraction() {
            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);

            const intersects = raycaster.intersectObjects(scene.children, true);

            for (const hit of intersects) {
                let obj = hit.object;

                // Walk up to find terminal group
                while (obj.parent && obj.parent !== scene) {
                    obj = obj.parent;
                }

                if (obj.userData.type === 'terminal') {
                    triggerCorruption();
                    return;
                }
            }
        }

        // ============== LIGHTING ==============
        const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
        scene.add(ambientLight);

        const sunLight = new THREE.DirectionalLight(0xffffcc, 1);
        sunLight.position.set(50, 100, 50);
        sunLight.castShadow = true;
        sunLight.shadow.mapSize.width = 2048;
        sunLight.shadow.mapSize.height = 2048;
        sunLight.shadow.camera.near = 0.5;
        sunLight.shadow.camera.far = 500;
        sunLight.shadow.camera.left = -100;
        sunLight.shadow.camera.right = 100;
        sunLight.shadow.camera.top = 100;
        sunLight.shadow.camera.bottom = -100;
        scene.add(sunLight);

        // ============== INFINITE PLANETARY WORLD GENERATION ==============
        const CHUNK_SIZE = 100;           // Size of each chunk
        const PLANET_CIRCUMFERENCE = 6000; // Distance to wrap around (like walking around a planet)
        const RENDER_DISTANCE = 4;        // Chunks to render in each direction
        const WORLD_SEED = 42;            // Fixed seed for consistent world
        const buildings = [];
        const worldObjects = [];
        const loadedChunks = new Map();   // Track loaded chunks by key
        const chunkObjects = new Map();   // Objects in each chunk

        // Starting position marker
        const START_POSITION = { x: 0, z: 0 };
        let distanceTraveled = { x: 0, z: 0 };
        let hasReturnedHome = false;

        // Simplex-like noise function with seamless wrapping
        class SimplexNoise {
            constructor(seed = Math.random()) {
                this.seed = seed;
                this.p = new Uint8Array(256);
                for (let i = 0; i < 256; i++) this.p[i] = i;
                for (let i = 255; i > 0; i--) {
                    const j = Math.floor((seed * 1000000 + i * 7919) % (i + 1));
                    [this.p[i], this.p[j]] = [this.p[j], this.p[i]];
                }
                this.perm = new Uint8Array(512);
                for (let i = 0; i < 512; i++) this.perm[i] = this.p[i & 255];
            }

            noise2D(x, y) {
                const fade = t => t * t * t * (t * (t * 6 - 15) + 10);
                const lerp = (a, b, t) => a + t * (b - a);
                const grad = (hash, x, y) => {
                    const h = hash & 3;
                    const u = h < 2 ? x : y;
                    const v = h < 2 ? y : x;
                    return ((h & 1) ? -u : u) + ((h & 2) ? -v : v);
                };

                const xi = Math.floor(x) & 255;
                const yi = Math.floor(y) & 255;
                const xf = x - Math.floor(x);
                const yf = y - Math.floor(y);
                const u = fade(xf);
                const v = fade(yf);

                const aa = this.perm[this.perm[xi] + yi];
                const ab = this.perm[this.perm[xi] + yi + 1];
                const ba = this.perm[this.perm[xi + 1] + yi];
                const bb = this.perm[this.perm[xi + 1] + yi + 1];

                return lerp(
                    lerp(grad(aa, xf, yf), grad(ba, xf - 1, yf), u),
                    lerp(grad(ab, xf, yf - 1), grad(bb, xf - 1, yf - 1), u),
                    v
                );
            }

            octaveNoise(x, y, octaves = 4, persistence = 0.5) {
                let total = 0, frequency = 1, amplitude = 1, maxValue = 0;
                for (let i = 0; i < octaves; i++) {
                    total += this.noise2D(x * frequency, y * frequency) * amplitude;
                    maxValue += amplitude;
                    amplitude *= persistence;
                    frequency *= 2;
                }
                return total / maxValue;
            }
        }

        const noise = new SimplexNoise(WORLD_SEED);
        const biomeNoise = new SimplexNoise(WORLD_SEED + 1);
        const districtNoise = new SimplexNoise(WORLD_SEED + 2);
        const roadNoise = new SimplexNoise(WORLD_SEED + 3);
        const temperatureNoise = new SimplexNoise(WORLD_SEED + 4);
        const moistureNoise = new SimplexNoise(WORLD_SEED + 5);

        // Wrap coordinates for seamless planetary wrap
        function wrapCoord(val) {
            const half = PLANET_CIRCUMFERENCE / 2;
            let wrapped = ((val + half) % PLANET_CIRCUMFERENCE + PLANET_CIRCUMFERENCE) % PLANET_CIRCUMFERENCE - half;
            return wrapped;
        }

        // Get world coordinates (wrapped for noise sampling)
        function getWorldCoords(x, z) {
            return {
                x: wrapCoord(x),
                z: wrapCoord(z)
            };
        }

        // Seeded random for consistent generation
        function seededRandom(x, z, salt = 0) {
            const wx = wrapCoord(x);
            const wz = wrapCoord(z);
            const n = Math.sin(wx * 12.9898 + wz * 78.233 + salt * 43758.5453) * 43758.5453;
            return n - Math.floor(n);
        }

        // ============== BIOME SYSTEM ==============
        // Large-scale biome determination based on temperature and moisture
        function getBiome(x, z) {
            const w = getWorldCoords(x, z);

            // Check if near origin - always city/plaza
            const distFromOrigin = Math.sqrt(w.x * w.x + w.z * w.z);
            if (distFromOrigin < 300) return 'city';

            // Temperature varies with "latitude" (z-axis) and noise
            const baseTemp = 1 - Math.abs(w.z) / (PLANET_CIRCUMFERENCE / 2);  // Warm at equator
            const tempVariation = temperatureNoise.octaveNoise(w.x * 0.0005, w.z * 0.0005, 3, 0.5) * 0.4;
            const temperature = Math.max(0, Math.min(1, baseTemp + tempVariation));

            // Moisture varies with noise
            const moisture = (moistureNoise.octaveNoise(w.x * 0.0008, w.z * 0.0008, 3, 0.5) + 1) / 2;

            // Elevation affects biome
            const elevation = biomeNoise.octaveNoise(w.x * 0.0003, w.z * 0.0003, 4, 0.6);

            // Determine biome based on conditions
            if (elevation > 0.55) return 'mountains';
            if (elevation < -0.4 && moisture > 0.5) return 'ocean';
            if (elevation < -0.3 && moisture > 0.6) return 'lake';

            if (temperature < 0.15) return 'tundra';
            if (temperature < 0.3 && moisture > 0.4) return 'taiga';

            if (temperature > 0.7 && moisture < 0.25) return 'desert';
            if (temperature > 0.6 && moisture < 0.35) return 'savanna';

            if (moisture > 0.7 && temperature > 0.5) return 'jungle';
            if (moisture > 0.55) return 'forest';
            if (moisture > 0.4) return 'plains';

            // Scattered settlements
            const settlementNoise = biomeNoise.octaveNoise(w.x * 0.003, w.z * 0.003, 2, 0.5);
            if (settlementNoise > 0.6 && moisture > 0.3 && moisture < 0.6) return 'village';

            return 'plains';
        }

        // Get terrain height based on biome
        function getTerrainHeight(x, z) {
            const w = getWorldCoords(x, z);
            const biome = getBiome(x, z);

            let baseHeight = noise.octaveNoise(w.x * 0.002, w.z * 0.002, 4, 0.5);
            let detail = noise.octaveNoise(w.x * 0.01, w.z * 0.01, 2, 0.5) * 3;

            switch (biome) {
                case 'mountains':
                    const mountainHeight = Math.abs(noise.octaveNoise(w.x * 0.003, w.z * 0.003, 5, 0.6));
                    return baseHeight * 20 + mountainHeight * 150 + detail * 5;

                case 'ocean':
                case 'lake':
                    return -5;  // Below water level

                case 'desert':
                    // Rolling dunes
                    const duneHeight = Math.abs(noise.octaveNoise(w.x * 0.008, w.z * 0.008, 2, 0.7));
                    return baseHeight * 10 + duneHeight * 15 + 5;

                case 'tundra':
                    return baseHeight * 15 + detail + 20;

                case 'taiga':
                    return baseHeight * 25 + detail * 2 + 15;

                case 'jungle':
                    return baseHeight * 20 + detail * 3 + 5;

                case 'forest':
                    return baseHeight * 25 + detail * 2 + 10;

                case 'savanna':
                    return baseHeight * 8 + detail + 8;

                case 'plains':
                    return baseHeight * 12 + detail + 5;

                case 'village':
                    return baseHeight * 10 + 8;

                case 'city':
                default:
                    const hills = Math.max(0, noise.octaveNoise(w.x * 0.005, w.z * 0.005, 3, 0.6)) * 20;
                    return baseHeight * 15 + detail + hills + 5;
            }
        }

        // District types within city biome
        function getDistrict(x, z) {
            const w = getWorldCoords(x, z);
            const biome = getBiome(x, z);

            if (biome !== 'city') return biome;

            const val = districtNoise.octaveNoise(w.x * 0.003, w.z * 0.003, 2, 0.5);
            const distFromOrigin = Math.sqrt(w.x * w.x + w.z * w.z);

            if (distFromOrigin < 40) return 'plaza';

            const regionNoise = districtNoise.octaveNoise(w.x * 0.001, w.z * 0.001, 1, 0.5);

            if (val < -0.3) return 'park';
            if (val < -0.1) return 'residential';
            if (val < 0.15) return 'commercial';
            if (val < 0.3) return 'industrial';
            if (regionNoise > 0.3) return 'downtown';
            return 'residential';
        }

        // Check if position is on a road (only in city/village)
        function isRoad(x, z) {
            const biome = getBiome(x, z);
            if (biome !== 'city' && biome !== 'village') return false;

            const w = getWorldCoords(x, z);
            const gridSize = biome === 'city' ? 40 : 60;
            const roadWidth = biome === 'city' ? 8 : 4;
            const onMainRoad = (Math.abs(((w.x % gridSize) + gridSize) % gridSize - gridSize/2) < roadWidth / 2) ||
                              (Math.abs(((w.z % gridSize) + gridSize) % gridSize - gridSize/2) < roadWidth / 2);

            const pathNoise = roadNoise.octaveNoise(w.x * 0.02, w.z * 0.02, 2, 0.5);
            const onPath = Math.abs(pathNoise) < 0.06;

            return onMainRoad || onPath;
        }

        // Check if position is underwater
        function isUnderwater(x, z) {
            const biome = getBiome(x, z);
            return biome === 'ocean' || biome === 'lake';
        }

        // ============== CHUNK SYSTEM ==============
        function getChunkKey(cx, cz) {
            return `${cx},${cz}`;
        }

        function worldToChunk(x, z) {
            return {
                cx: Math.floor(x / CHUNK_SIZE),
                cz: Math.floor(z / CHUNK_SIZE)
            };
        }

        function createChunkTerrain(cx, cz) {
            const chunkX = cx * CHUNK_SIZE;
            const chunkZ = cz * CHUNK_SIZE;

            const resolution = 25;
            const geometry = new THREE.PlaneGeometry(CHUNK_SIZE, CHUNK_SIZE, resolution, resolution);
            const positions = geometry.attributes.position.array;
            const colors = new Float32Array(positions.length);

            let hasWater = false;

            for (let i = 0; i < positions.length; i += 3) {
                const localX = positions[i];
                const localZ = positions[i + 1];
                const worldX = chunkX + localX + CHUNK_SIZE/2;
                const worldZ = chunkZ + localZ + CHUNK_SIZE/2;

                const height = getTerrainHeight(worldX, worldZ);
                positions[i + 2] = height;

                const biome = getBiome(worldX, worldZ);
                const district = getDistrict(worldX, worldZ);
                const road = isRoad(worldX, worldZ);

                let r, g, b;
                if (road) {
                    r = 0.25; g = 0.25; b = 0.27;
                } else {
                    switch (biome) {
                        case 'ocean':
                            r = 0.1; g = 0.3; b = 0.6;
                            hasWater = true;
                            break;
                        case 'lake':
                            r = 0.15; g = 0.4; b = 0.65;
                            hasWater = true;
                            break;
                        case 'mountains':
                            const snowLine = height > 100;
                            if (snowLine) {
                                r = 0.9; g = 0.92; b = 0.95;
                            } else if (height > 60) {
                                r = 0.5; g = 0.5; b = 0.5;
                            } else {
                                r = 0.4; g = 0.45; b = 0.35;
                            }
                            break;
                        case 'desert':
                            r = 0.85 + seededRandom(worldX, worldZ) * 0.1;
                            g = 0.7 + seededRandom(worldX, worldZ, 1) * 0.1;
                            b = 0.45;
                            break;
                        case 'tundra':
                            r = 0.75; g = 0.78; b = 0.8;
                            break;
                        case 'taiga':
                            r = 0.2; g = 0.35; b = 0.25;
                            break;
                        case 'jungle':
                            r = 0.1 + seededRandom(worldX, worldZ) * 0.1;
                            g = 0.4 + seededRandom(worldX, worldZ, 1) * 0.15;
                            b = 0.1;
                            break;
                        case 'forest':
                            r = 0.15 + seededRandom(worldX, worldZ) * 0.08;
                            g = 0.38 + seededRandom(worldX, worldZ, 1) * 0.12;
                            b = 0.12;
                            break;
                        case 'savanna':
                            r = 0.7; g = 0.65; b = 0.35;
                            break;
                        case 'plains':
                            r = 0.35 + seededRandom(worldX, worldZ) * 0.1;
                            g = 0.55 + seededRandom(worldX, worldZ, 1) * 0.1;
                            b = 0.25;
                            break;
                        case 'village':
                            r = 0.4; g = 0.5; b = 0.3;
                            break;
                        case 'city':
                            // Use district colors for city
                            switch (district) {
                                case 'plaza':
                                    r = 0.6; g = 0.55; b = 0.5; break;
                                case 'park':
                                    r = 0.2 + seededRandom(worldX, worldZ) * 0.1;
                                    g = 0.45 + seededRandom(worldX, worldZ, 1) * 0.15;
                                    b = 0.15; break;
                                case 'residential':
                                    r = 0.35; g = 0.42; b = 0.3; break;
                                case 'commercial':
                                    r = 0.4; g = 0.38; b = 0.35; break;
                                case 'downtown':
                                    r = 0.35; g = 0.35; b = 0.38; break;
                                case 'industrial':
                                    r = 0.35; g = 0.33; b = 0.32; break;
                                default:
                                    r = 0.3; g = 0.4; b = 0.28;
                            }
                            break;
                        default:
                            r = 0.3; g = 0.5; b = 0.25;
                    }
                }
                colors[i] = r;
                colors[i + 1] = g;
                colors[i + 2] = b;
            }

            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            geometry.computeVertexNormals();

            const material = new THREE.MeshStandardMaterial({
                vertexColors: true,
                roughness: 0.85,
                metalness: 0.1
            });

            const terrain = new THREE.Mesh(geometry, material);
            terrain.rotation.x = -Math.PI / 2;
            terrain.position.set(chunkX + CHUNK_SIZE/2, 0, chunkZ + CHUNK_SIZE/2);
            terrain.receiveShadow = true;
            terrain.userData.type = 'ground';
            terrain.userData.chunk = { cx, cz };

            // Add water plane if chunk has water
            if (hasWater) {
                const waterGeo = new THREE.PlaneGeometry(CHUNK_SIZE, CHUNK_SIZE);
                const waterMat = new THREE.MeshStandardMaterial({
                    color: 0x2288aa,
                    transparent: true,
                    opacity: 0.7,
                    roughness: 0.1,
                    metalness: 0.3
                });
                const water = new THREE.Mesh(waterGeo, waterMat);
                water.rotation.x = -Math.PI / 2;
                water.position.set(chunkX + CHUNK_SIZE/2, 0, chunkZ + CHUNK_SIZE/2);
                terrain.userData.water = water;
            }

            return terrain;
        }

        // ============== SKY DOME (follows player) ==============
        const skyGeometry = new THREE.SphereGeometry(800, 32, 32);
        const skyMaterial = new THREE.ShaderMaterial({
            uniforms: {
                topColor: { value: new THREE.Color(0x0077ff) },
                bottomColor: { value: new THREE.Color(0x89CFF0) },
                offset: { value: 20 },
                exponent: { value: 0.6 }
            },
            vertexShader: `
                varying vec3 vWorldPosition;
                void main() {
                    vec4 worldPosition = modelMatrix * vec4(position, 1.0);
                    vWorldPosition = worldPosition.xyz;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform vec3 topColor;
                uniform vec3 bottomColor;
                uniform float offset;
                uniform float exponent;
                varying vec3 vWorldPosition;
                void main() {
                    float h = normalize(vWorldPosition + offset).y;
                    gl_FragColor = vec4(mix(bottomColor, topColor, max(pow(max(h, 0.0), exponent), 0.0)), 1.0);
                }
            `,
            side: THREE.BackSide
        });
        const sky = new THREE.Mesh(skyGeometry, skyMaterial);
        sky.userData.type = 'sky';
        sky.userData.originalTopColor = skyMaterial.uniforms.topColor.value.clone();
        sky.userData.originalBottomColor = skyMaterial.uniforms.bottomColor.value.clone();
        scene.add(sky);

        // Clouds (follow player)
        const cloudGroup = new THREE.Group();
        for (let i = 0; i < 40; i++) {
            const cloudGeo = new THREE.SphereGeometry(15 + Math.random() * 25, 6, 6);
            const cloudMat = new THREE.MeshStandardMaterial({
                color: 0xffffff,
                transparent: true,
                opacity: 0.8,
                roughness: 1
            });
            const cloud = new THREE.Mesh(cloudGeo, cloudMat);

            const angle = Math.random() * Math.PI * 2;
            const radius = 150 + Math.random() * 400;
            cloud.position.set(
                Math.cos(angle) * radius,
                100 + Math.random() * 50,
                Math.sin(angle) * radius
            );
            cloud.scale.set(1.5, 0.4, 1);
            cloudGroup.add(cloud);
        }
        scene.add(cloudGroup);

        // ============== BUILDING STYLES BY DISTRICT ==============
        const buildingStyles = {
            residential: {
                colors: [0xd4c4b0, 0xc9b99a, 0xe8dcc8, 0xbfae94, 0xf5efe6],
                minHeight: 8, maxHeight: 25,
                minWidth: 6, maxWidth: 12,
                roofStyle: 'peaked'
            },
            commercial: {
                colors: [0x4a5568, 0x2d3748, 0x718096, 0x1a202c, 0x2c5282],
                minHeight: 20, maxHeight: 60,
                minWidth: 10, maxWidth: 20,
                roofStyle: 'flat'
            },
            downtown: {
                colors: [0x2c3e50, 0x34495e, 0x1abc9c, 0x3498db, 0x9b59b6],
                minHeight: 60, maxHeight: 150,
                minWidth: 15, maxWidth: 30,
                roofStyle: 'spire'
            },
            industrial: {
                colors: [0x5c5c5c, 0x4a4a4a, 0x6b6b6b, 0x3d3d3d, 0x7a7a7a],
                minHeight: 10, maxHeight: 30,
                minWidth: 15, maxWidth: 40,
                roofStyle: 'industrial'
            },
            plaza: {
                colors: [0xffffff, 0xe8e8e8, 0xf0f0f0],
                minHeight: 5, maxHeight: 15,
                minWidth: 8, maxWidth: 15,
                roofStyle: 'dome'
            }
        };

        function createBuilding(x, z, district) {
            const style = buildingStyles[district] || buildingStyles.residential;
            const buildingGroup = new THREE.Group();

            const width = style.minWidth + Math.random() * (style.maxWidth - style.minWidth);
            const height = style.minHeight + Math.random() * (style.maxHeight - style.minHeight);
            const depth = width * (0.6 + Math.random() * 0.4);

            const baseY = getTerrainHeight(x, z);

            // Main building body
            const geometry = new THREE.BoxGeometry(width, height, depth);
            const color = style.colors[Math.floor(Math.random() * style.colors.length)];
            const material = new THREE.MeshStandardMaterial({
                color: color,
                roughness: 0.7,
                metalness: 0.2
            });

            const building = new THREE.Mesh(geometry, material);
            building.position.y = height / 2;
            building.castShadow = true;
            building.receiveShadow = true;
            buildingGroup.add(building);

            // Add roof based on style
            if (style.roofStyle === 'peaked') {
                const roofGeo = new THREE.ConeGeometry(width * 0.7, height * 0.3, 4);
                const roofMat = new THREE.MeshStandardMaterial({ color: 0x8b4513, roughness: 0.9 });
                const roof = new THREE.Mesh(roofGeo, roofMat);
                roof.position.y = height + height * 0.15;
                roof.rotation.y = Math.PI / 4;
                roof.castShadow = true;
                buildingGroup.add(roof);
            } else if (style.roofStyle === 'dome') {
                const domeGeo = new THREE.SphereGeometry(width * 0.4, 16, 16, 0, Math.PI * 2, 0, Math.PI / 2);
                const domeMat = new THREE.MeshStandardMaterial({ color: 0xcccccc, metalness: 0.3, roughness: 0.5 });
                const dome = new THREE.Mesh(domeGeo, domeMat);
                dome.position.y = height;
                dome.castShadow = true;
                buildingGroup.add(dome);
            } else if (style.roofStyle === 'spire') {
                // Tall spire for downtown skyscrapers
                const spireGeo = new THREE.ConeGeometry(width * 0.15, height * 0.2, 8);
                const spireMat = new THREE.MeshStandardMaterial({ color: 0xcccccc, metalness: 0.8, roughness: 0.2 });
                const spire = new THREE.Mesh(spireGeo, spireMat);
                spire.position.y = height + height * 0.1;
                spire.castShadow = true;
                buildingGroup.add(spire);

                // Antenna
                const antennaGeo = new THREE.CylinderGeometry(0.1, 0.1, height * 0.1, 8);
                const antenna = new THREE.Mesh(antennaGeo, spireMat);
                antenna.position.y = height + height * 0.25;
                buildingGroup.add(antenna);
            } else if (style.roofStyle === 'industrial') {
                // Saw-tooth roof
                for (let i = 0; i < 3; i++) {
                    const sawGeo = new THREE.BoxGeometry(width / 3, 3, depth);
                    const sawMat = new THREE.MeshStandardMaterial({ color: 0x666666 });
                    const saw = new THREE.Mesh(sawGeo, sawMat);
                    saw.position.set(-width / 3 + i * width / 3, height + 1.5, 0);
                    saw.castShadow = true;
                    buildingGroup.add(saw);
                }
            }

            // Windows
            const windowMaterial = new THREE.MeshStandardMaterial({
                color: 0xffffee,
                emissive: 0xffffee,
                emissiveIntensity: 0.2
            });

            const windowRows = Math.floor(height / 4);
            const windowCols = Math.floor(width / 3);

            for (let side = 0; side < 4; side++) {
                for (let row = 1; row < windowRows; row++) {
                    for (let col = 0; col < windowCols; col++) {
                        if (Math.random() > 0.25) {
                            const windowGeom = new THREE.PlaneGeometry(1, 1.5);
                            const windowMesh = new THREE.Mesh(windowGeom, windowMaterial.clone());

                            switch (side) {
                                case 0: // Front
                                    windowMesh.position.set(-width / 2 + 1.5 + col * 3, row * 4, depth / 2 + 0.01);
                                    break;
                                case 1: // Back
                                    windowMesh.position.set(-width / 2 + 1.5 + col * 3, row * 4, -depth / 2 - 0.01);
                                    windowMesh.rotation.y = Math.PI;
                                    break;
                                case 2: // Left
                                    windowMesh.position.set(-width / 2 - 0.01, row * 4, -depth / 2 + 1.5 + col * 3);
                                    windowMesh.rotation.y = -Math.PI / 2;
                                    break;
                                case 3: // Right
                                    windowMesh.position.set(width / 2 + 0.01, row * 4, -depth / 2 + 1.5 + col * 3);
                                    windowMesh.rotation.y = Math.PI / 2;
                                    break;
                            }

                            windowMesh.userData.type = 'window';
                            building.add(windowMesh);
                        }
                    }
                }
            }

            buildingGroup.position.set(x, baseY, z);
            buildingGroup.rotation.y = Math.floor(Math.random() * 4) * Math.PI / 2 + (Math.random() - 0.5) * 0.1;

            buildingGroup.userData.type = 'building';
            buildingGroup.userData.originalPosition = buildingGroup.position.clone();
            buildingGroup.userData.district = district;

            scene.add(buildingGroup);
            buildings.push(buildingGroup);
            return buildingGroup;
        }

        // ============== TREES AND VEGETATION ==============
        function createTree(x, z, treeType = 'deciduous') {
            const treeGroup = new THREE.Group();
            const baseY = getTerrainHeight(x, z);

            if (treeType === 'deciduous') {
                const trunkHeight = 3 + Math.random() * 2;
                const trunkGeom = new THREE.CylinderGeometry(0.2, 0.35, trunkHeight, 8);
                const trunkMat = new THREE.MeshStandardMaterial({ color: 0x4a3728 });
                const trunk = new THREE.Mesh(trunkGeom, trunkMat);
                trunk.position.y = trunkHeight / 2;
                trunk.castShadow = true;
                treeGroup.add(trunk);

                const foliageSize = 2 + Math.random() * 1.5;
                const foliageGeom = new THREE.SphereGeometry(foliageSize, 8, 8);
                const foliageMat = new THREE.MeshStandardMaterial({
                    color: new THREE.Color().setHSL(0.3 + Math.random() * 0.1, 0.6, 0.25 + Math.random() * 0.1)
                });
                const foliage = new THREE.Mesh(foliageGeom, foliageMat);
                foliage.position.y = trunkHeight + foliageSize * 0.6;
                foliage.castShadow = true;
                treeGroup.add(foliage);
            } else if (treeType === 'pine') {
                const trunkHeight = 4 + Math.random() * 3;
                const trunkGeom = new THREE.CylinderGeometry(0.15, 0.3, trunkHeight, 6);
                const trunkMat = new THREE.MeshStandardMaterial({ color: 0x5c4033 });
                const trunk = new THREE.Mesh(trunkGeom, trunkMat);
                trunk.position.y = trunkHeight / 2;
                trunk.castShadow = true;
                treeGroup.add(trunk);

                for (let i = 0; i < 4; i++) {
                    const coneSize = 2.5 - i * 0.4;
                    const coneGeo = new THREE.ConeGeometry(coneSize, 3, 8);
                    const coneMat = new THREE.MeshStandardMaterial({ color: 0x1a472a });
                    const cone = new THREE.Mesh(coneGeo, coneMat);
                    cone.position.y = trunkHeight - 1 + i * 2;
                    cone.castShadow = true;
                    treeGroup.add(cone);
                }
            } else if (treeType === 'palm') {
                const trunkHeight = 8 + Math.random() * 4;
                const trunkGeom = new THREE.CylinderGeometry(0.3, 0.4, trunkHeight, 8);
                const trunkMat = new THREE.MeshStandardMaterial({ color: 0x8b7355 });
                const trunk = new THREE.Mesh(trunkGeom, trunkMat);
                trunk.position.y = trunkHeight / 2;
                trunk.castShadow = true;
                treeGroup.add(trunk);

                for (let i = 0; i < 7; i++) {
                    const frondGeo = new THREE.PlaneGeometry(6, 1);
                    const frondMat = new THREE.MeshStandardMaterial({
                        color: 0x228b22,
                        side: THREE.DoubleSide
                    });
                    const frond = new THREE.Mesh(frondGeo, frondMat);
                    frond.position.y = trunkHeight;
                    frond.rotation.y = (i / 7) * Math.PI * 2;
                    frond.rotation.x = -0.5;
                    treeGroup.add(frond);
                }
            }

            treeGroup.position.set(x, baseY, z);
            scene.add(treeGroup);
            worldObjects.push(treeGroup);
            return treeGroup;
        }

        // ============== STREET FURNITURE ==============
        function createStreetLight(x, z) {
            const lightGroup = new THREE.Group();
            const baseY = getTerrainHeight(x, z);

            const poleGeo = new THREE.CylinderGeometry(0.1, 0.15, 6, 8);
            const poleMat = new THREE.MeshStandardMaterial({ color: 0x333333, metalness: 0.5 });
            const pole = new THREE.Mesh(poleGeo, poleMat);
            pole.position.y = 3;
            pole.castShadow = true;
            lightGroup.add(pole);

            const lampGeo = new THREE.SphereGeometry(0.4, 8, 8);
            const lampMat = new THREE.MeshStandardMaterial({
                color: 0xffffee,
                emissive: 0xffffaa,
                emissiveIntensity: 0.3
            });
            const lamp = new THREE.Mesh(lampGeo, lampMat);
            lamp.position.y = 6.2;
            lightGroup.add(lamp);

            lightGroup.position.set(x, baseY, z);
            scene.add(lightGroup);
            worldObjects.push(lightGroup);
        }

        function createBench(x, z, rotation = 0) {
            const benchGroup = new THREE.Group();
            const baseY = getTerrainHeight(x, z);

            const woodMat = new THREE.MeshStandardMaterial({ color: 0x8b4513, roughness: 0.8 });
            const metalMat = new THREE.MeshStandardMaterial({ color: 0x333333, metalness: 0.7 });

            // Seat slats
            for (let i = 0; i < 4; i++) {
                const slat = new THREE.Mesh(new THREE.BoxGeometry(2, 0.08, 0.15), woodMat);
                slat.position.set(0, 0.5, -0.2 + i * 0.18);
                slat.castShadow = true;
                benchGroup.add(slat);
            }

            // Back slats
            for (let i = 0; i < 3; i++) {
                const slat = new THREE.Mesh(new THREE.BoxGeometry(2, 0.08, 0.12), woodMat);
                slat.position.set(0, 0.7 + i * 0.15, -0.35);
                slat.rotation.x = 0.2;
                slat.castShadow = true;
                benchGroup.add(slat);
            }

            // Metal legs
            for (let i = -1; i <= 1; i += 2) {
                const leg = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.5, 0.5), metalMat);
                leg.position.set(i * 0.85, 0.25, -0.1);
                leg.castShadow = true;
                benchGroup.add(leg);
            }

            benchGroup.position.set(x, baseY, z);
            benchGroup.rotation.y = rotation;
            scene.add(benchGroup);
            worldObjects.push(benchGroup);
        }

        function createFountain(x, z) {
            const fountainGroup = new THREE.Group();
            const baseY = getTerrainHeight(x, z);

            // Base pool
            const poolGeo = new THREE.CylinderGeometry(5, 5.5, 0.8, 32);
            const stoneMat = new THREE.MeshStandardMaterial({ color: 0x888888, roughness: 0.9 });
            const pool = new THREE.Mesh(poolGeo, stoneMat);
            pool.position.y = 0.4;
            pool.castShadow = true;
            pool.receiveShadow = true;
            fountainGroup.add(pool);

            // Water
            const waterGeo = new THREE.CylinderGeometry(4.8, 4.8, 0.6, 32);
            const waterMat = new THREE.MeshStandardMaterial({
                color: 0x4488aa,
                transparent: true,
                opacity: 0.7,
                roughness: 0.1
            });
            const water = new THREE.Mesh(waterGeo, waterMat);
            water.position.y = 0.5;
            fountainGroup.add(water);

            // Central pillar
            const pillarGeo = new THREE.CylinderGeometry(0.5, 0.7, 3, 16);
            const pillar = new THREE.Mesh(pillarGeo, stoneMat);
            pillar.position.y = 2;
            pillar.castShadow = true;
            fountainGroup.add(pillar);

            // Top bowl
            const bowlGeo = new THREE.SphereGeometry(1.2, 16, 16, 0, Math.PI * 2, 0, Math.PI / 2);
            const bowl = new THREE.Mesh(bowlGeo, stoneMat);
            bowl.position.y = 3.5;
            bowl.rotation.x = Math.PI;
            bowl.castShadow = true;
            fountainGroup.add(bowl);

            fountainGroup.position.set(x, baseY, z);
            scene.add(fountainGroup);
            worldObjects.push(fountainGroup);
        }

        // ============== BIOME-SPECIFIC OBJECTS ==============
        function createRock(x, z, scale = 1) {
            const rockGroup = new THREE.Group();
            const baseY = getTerrainHeight(x, z);

            const rockGeo = new THREE.DodecahedronGeometry(1.5 * scale, 0);
            const rockMat = new THREE.MeshStandardMaterial({
                color: 0x666666,
                roughness: 0.9,
                metalness: 0.1
            });
            const rock = new THREE.Mesh(rockGeo, rockMat);
            rock.position.y = 0.8 * scale;
            rock.rotation.set(Math.random(), Math.random(), Math.random());
            rock.scale.set(1, 0.6, 0.8);
            rock.castShadow = true;
            rockGroup.add(rock);

            rockGroup.position.set(x, baseY, z);
            scene.add(rockGroup);
            return rockGroup;
        }

        function createCactus(x, z) {
            const cactusGroup = new THREE.Group();
            const baseY = getTerrainHeight(x, z);

            const cactusMat = new THREE.MeshStandardMaterial({ color: 0x2d5a27 });

            // Main trunk
            const trunkGeo = new THREE.CylinderGeometry(0.3, 0.4, 4, 8);
            const trunk = new THREE.Mesh(trunkGeo, cactusMat);
            trunk.position.y = 2;
            trunk.castShadow = true;
            cactusGroup.add(trunk);

            // Arms
            if (seededRandom(x, z, 30) > 0.4) {
                const armGeo = new THREE.CylinderGeometry(0.2, 0.25, 2, 8);
                const arm1 = new THREE.Mesh(armGeo, cactusMat);
                arm1.position.set(0.5, 2.5, 0);
                arm1.rotation.z = -Math.PI / 4;
                arm1.castShadow = true;
                cactusGroup.add(arm1);
            }
            if (seededRandom(x, z, 31) > 0.5) {
                const armGeo = new THREE.CylinderGeometry(0.2, 0.25, 1.5, 8);
                const arm2 = new THREE.Mesh(armGeo, cactusMat);
                arm2.position.set(-0.4, 2, 0);
                arm2.rotation.z = Math.PI / 4;
                arm2.castShadow = true;
                cactusGroup.add(arm2);
            }

            cactusGroup.position.set(x, baseY, z);
            scene.add(cactusGroup);
            return cactusGroup;
        }

        function createVillageHut(x, z) {
            const hutGroup = new THREE.Group();
            const baseY = getTerrainHeight(x, z);

            // Walls
            const wallGeo = new THREE.CylinderGeometry(3, 3.5, 3, 8);
            const wallMat = new THREE.MeshStandardMaterial({ color: 0xb8956b });
            const walls = new THREE.Mesh(wallGeo, wallMat);
            walls.position.y = 1.5;
            walls.castShadow = true;
            hutGroup.add(walls);

            // Roof
            const roofGeo = new THREE.ConeGeometry(4, 2.5, 8);
            const roofMat = new THREE.MeshStandardMaterial({ color: 0x8b7355 });
            const roof = new THREE.Mesh(roofGeo, roofMat);
            roof.position.y = 4.25;
            roof.castShadow = true;
            hutGroup.add(roof);

            // Door
            const doorGeo = new THREE.BoxGeometry(0.8, 1.8, 0.1);
            const doorMat = new THREE.MeshStandardMaterial({ color: 0x4a3728 });
            const door = new THREE.Mesh(doorGeo, doorMat);
            door.position.set(0, 1, 3.4);
            hutGroup.add(door);

            hutGroup.position.set(x, baseY, z);
            hutGroup.rotation.y = seededRandom(x, z, 50) * Math.PI * 2;
            scene.add(hutGroup);
            return hutGroup;
        }

        function createSnowPine(x, z) {
            const treeGroup = new THREE.Group();
            const baseY = getTerrainHeight(x, z);

            const trunkHeight = 3 + seededRandom(x, z, 40) * 2;
            const trunkGeom = new THREE.CylinderGeometry(0.15, 0.3, trunkHeight, 6);
            const trunkMat = new THREE.MeshStandardMaterial({ color: 0x3d2817 });
            const trunk = new THREE.Mesh(trunkGeom, trunkMat);
            trunk.position.y = trunkHeight / 2;
            trunk.castShadow = true;
            treeGroup.add(trunk);

            // Snow-covered cones
            for (let i = 0; i < 4; i++) {
                const coneSize = 2 - i * 0.35;
                const coneGeo = new THREE.ConeGeometry(coneSize, 2.5, 8);
                const coneMat = new THREE.MeshStandardMaterial({
                    color: i === 0 ? 0xffffff : 0x1a3a20  // Top is snowy
                });
                const cone = new THREE.Mesh(coneGeo, coneMat);
                cone.position.y = trunkHeight - 0.5 + i * 1.8;
                cone.castShadow = true;
                treeGroup.add(cone);
            }

            treeGroup.position.set(x, baseY, z);
            scene.add(treeGroup);
            return treeGroup;
        }

        function createJungleTree(x, z) {
            const treeGroup = new THREE.Group();
            const baseY = getTerrainHeight(x, z);

            const trunkHeight = 8 + seededRandom(x, z, 45) * 6;
            const trunkGeom = new THREE.CylinderGeometry(0.4, 0.6, trunkHeight, 8);
            const trunkMat = new THREE.MeshStandardMaterial({ color: 0x4a3020 });
            const trunk = new THREE.Mesh(trunkGeom, trunkMat);
            trunk.position.y = trunkHeight / 2;
            trunk.castShadow = true;
            treeGroup.add(trunk);

            // Large canopy
            for (let i = 0; i < 5; i++) {
                const canopyGeo = new THREE.SphereGeometry(3 + seededRandom(x + i, z, 46) * 2, 8, 8);
                const canopyMat = new THREE.MeshStandardMaterial({
                    color: new THREE.Color().setHSL(0.3, 0.7, 0.2 + seededRandom(x, z + i, 47) * 0.1)
                });
                const canopy = new THREE.Mesh(canopyGeo, canopyMat);
                canopy.position.set(
                    (seededRandom(x + i, z, 48) - 0.5) * 4,
                    trunkHeight + seededRandom(x, z + i, 49) * 2,
                    (seededRandom(x, z + i, 50) - 0.5) * 4
                );
                canopy.scale.y = 0.6;
                canopy.castShadow = true;
                treeGroup.add(canopy);
            }

            treeGroup.position.set(x, baseY, z);
            scene.add(treeGroup);
            return treeGroup;
        }

        function createSavannaTree(x, z) {
            const treeGroup = new THREE.Group();
            const baseY = getTerrainHeight(x, z);

            // Acacia-style tree
            const trunkHeight = 5 + seededRandom(x, z, 55) * 3;
            const trunkGeom = new THREE.CylinderGeometry(0.2, 0.4, trunkHeight, 6);
            const trunkMat = new THREE.MeshStandardMaterial({ color: 0x5c4033 });
            const trunk = new THREE.Mesh(trunkGeom, trunkMat);
            trunk.position.y = trunkHeight / 2;
            trunk.castShadow = true;
            treeGroup.add(trunk);

            // Flat canopy
            const canopyGeo = new THREE.CylinderGeometry(4, 4, 1, 12);
            const canopyMat = new THREE.MeshStandardMaterial({ color: 0x3d5c28 });
            const canopy = new THREE.Mesh(canopyGeo, canopyMat);
            canopy.position.y = trunkHeight + 0.5;
            canopy.castShadow = true;
            treeGroup.add(canopy);

            treeGroup.position.set(x, baseY, z);
            scene.add(treeGroup);
            return treeGroup;
        }

        // ============== CHUNK POPULATION ==============
        function populateChunk(cx, cz) {
            const chunkKey = getChunkKey(cx, cz);
            if (chunkObjects.has(chunkKey)) return chunkObjects.get(chunkKey);

            const objects = [];
            const chunkX = cx * CHUNK_SIZE;
            const chunkZ = cz * CHUNK_SIZE;

            // Sample biome at chunk center
            const centerBiome = getBiome(chunkX + CHUNK_SIZE/2, chunkZ + CHUNK_SIZE/2);

            // Skip underwater chunks
            if (centerBiome === 'ocean' || centerBiome === 'lake') {
                chunkObjects.set(chunkKey, objects);
                return objects;
            }

            // Biome-specific population
            const objectSpacing = 15;

            for (let lx = 0; lx < CHUNK_SIZE; lx += objectSpacing) {
                for (let lz = 0; lz < CHUNK_SIZE; lz += objectSpacing) {
                    const worldX = chunkX + lx;
                    const worldZ = chunkZ + lz;
                    const biome = getBiome(worldX, worldZ);
                    const offsetX = (seededRandom(worldX, worldZ, 1) - 0.5) * objectSpacing * 0.8;
                    const offsetZ = (seededRandom(worldX, worldZ, 2) - 0.5) * objectSpacing * 0.8;
                    const px = worldX + offsetX;
                    const pz = worldZ + offsetZ;

                    switch (biome) {
                        case 'mountains':
                            if (seededRandom(worldX, worldZ, 10) < 0.3) {
                                const rock = createRock(px, pz, 1 + seededRandom(worldX, worldZ, 11) * 2);
                                rock.userData.chunk = { cx, cz };
                                objects.push(rock);
                            }
                            break;

                        case 'desert':
                            if (seededRandom(worldX, worldZ, 12) < 0.08) {
                                const cactus = createCactus(px, pz);
                                cactus.userData.chunk = { cx, cz };
                                objects.push(cactus);
                            }
                            if (seededRandom(worldX, worldZ, 13) < 0.05) {
                                const rock = createRock(px, pz, 0.5 + seededRandom(worldX, worldZ, 14));
                                rock.userData.chunk = { cx, cz };
                                objects.push(rock);
                            }
                            break;

                        case 'tundra':
                            if (seededRandom(worldX, worldZ, 15) < 0.15) {
                                const rock = createRock(px, pz, 0.8);
                                rock.userData.chunk = { cx, cz };
                                objects.push(rock);
                            }
                            if (seededRandom(worldX, worldZ, 16) < 0.1) {
                                const tree = createSnowPine(px, pz);
                                tree.userData.chunk = { cx, cz };
                                objects.push(tree);
                            }
                            break;

                        case 'taiga':
                            if (seededRandom(worldX, worldZ, 17) < 0.5) {
                                const tree = createTree(px, pz, 'pine');
                                tree.userData.chunk = { cx, cz };
                                objects.push(tree);
                            }
                            break;

                        case 'jungle':
                            if (seededRandom(worldX, worldZ, 18) < 0.6) {
                                const tree = createJungleTree(px, pz);
                                tree.userData.chunk = { cx, cz };
                                objects.push(tree);
                            }
                            break;

                        case 'forest':
                            if (seededRandom(worldX, worldZ, 19) < 0.55) {
                                const treeType = seededRandom(worldX, worldZ, 20) > 0.3 ? 'deciduous' : 'pine';
                                const tree = createTree(px, pz, treeType);
                                tree.userData.chunk = { cx, cz };
                                objects.push(tree);
                            }
                            break;

                        case 'savanna':
                            if (seededRandom(worldX, worldZ, 21) < 0.12) {
                                const tree = createSavannaTree(px, pz);
                                tree.userData.chunk = { cx, cz };
                                objects.push(tree);
                            }
                            break;

                        case 'plains':
                            if (seededRandom(worldX, worldZ, 22) < 0.08) {
                                const tree = createTree(px, pz, 'deciduous');
                                tree.userData.chunk = { cx, cz };
                                objects.push(tree);
                            }
                            break;

                        case 'village':
                            if (!isRoad(worldX, worldZ)) {
                                if (seededRandom(worldX, worldZ, 23) < 0.15) {
                                    const hut = createVillageHut(px, pz);
                                    hut.userData.chunk = { cx, cz };
                                    objects.push(hut);
                                } else if (seededRandom(worldX, worldZ, 24) < 0.2) {
                                    const tree = createTree(px, pz, 'deciduous');
                                    tree.userData.chunk = { cx, cz };
                                    objects.push(tree);
                                }
                            }
                            break;
                    }
                }
            }

            // City-specific objects (buildings, etc.)
            if (centerBiome === 'city') {
                const buildingSpacing = 20;
                for (let lx = 0; lx < CHUNK_SIZE; lx += buildingSpacing) {
                    for (let lz = 0; lz < CHUNK_SIZE; lz += buildingSpacing) {
                        const worldX = chunkX + lx;
                        const worldZ = chunkZ + lz;

                        if (isRoad(worldX, worldZ)) continue;

                        const district = getDistrict(worldX, worldZ);
                        if (district === 'park' && seededRandom(worldX, worldZ, 10) > 0.1) continue;

                        const offsetX = (seededRandom(worldX, worldZ, 1) - 0.5) * buildingSpacing * 0.5;
                        const offsetZ = (seededRandom(worldX, worldZ, 2) - 0.5) * buildingSpacing * 0.5;

                        let buildChance = 0.55;
                        if (district === 'commercial') buildChance = 0.7;
                        if (district === 'downtown') buildChance = 0.8;
                        if (district === 'industrial') buildChance = 0.65;
                        if (district === 'residential') buildChance = 0.5;

                        if (seededRandom(worldX, worldZ, 3) < buildChance) {
                            const building = createBuilding(worldX + offsetX, worldZ + offsetZ, district);
                            building.userData.chunk = { cx, cz };
                            objects.push(building);
                        }
                    }
                }

                // Park trees
                const treeSpacing = 18;
                for (let lx = 0; lx < CHUNK_SIZE; lx += treeSpacing) {
                    for (let lz = 0; lz < CHUNK_SIZE; lz += treeSpacing) {
                        const worldX = chunkX + lx;
                        const worldZ = chunkZ + lz;
                        if (isRoad(worldX, worldZ)) continue;

                        const district = getDistrict(worldX, worldZ);
                        let treeChance = 0;
                        let treeType = 'deciduous';

                        if (district === 'park') treeChance = 0.5;
                        else if (district === 'residential') treeChance = 0.1;
                        else if (district === 'plaza') { treeChance = 0.08; treeType = 'palm'; }

                        if (seededRandom(worldX, worldZ, 4) < treeChance) {
                            const tree = createTree(worldX, worldZ, treeType);
                            tree.userData.chunk = { cx, cz };
                            objects.push(tree);
                        }
                    }
                }

                // Street lights and benches
                for (let lx = 0; lx < CHUNK_SIZE; lx += 35) {
                    for (let lz = 0; lz < CHUNK_SIZE; lz += 35) {
                        const worldX = chunkX + lx;
                        const worldZ = chunkZ + lz;
                        if (isRoad(worldX, worldZ) && seededRandom(worldX, worldZ, 7) < 0.35) {
                            createStreetLight(worldX + 4, worldZ);
                        }
                    }
                }

                for (let lx = 0; lx < CHUNK_SIZE; lx += 45) {
                    for (let lz = 0; lz < CHUNK_SIZE; lz += 45) {
                        const worldX = chunkX + lx;
                        const worldZ = chunkZ + lz;
                        const district = getDistrict(worldX, worldZ);
                        if ((district === 'park' || district === 'plaza') && seededRandom(worldX, worldZ, 8) < 0.3) {
                            createBench(worldX, worldZ, seededRandom(worldX, worldZ, 9) * Math.PI * 2);
                        }
                    }
                }
            }

            chunkObjects.set(chunkKey, objects);
            return objects;
        }

        function loadChunk(cx, cz) {
            const key = getChunkKey(cx, cz);
            if (loadedChunks.has(key)) return;

            // Create terrain
            const terrain = createChunkTerrain(cx, cz);
            scene.add(terrain);

            // Add water if present
            if (terrain.userData.water) {
                scene.add(terrain.userData.water);
            }

            // Populate with objects
            populateChunk(cx, cz);

            loadedChunks.set(key, { terrain, cx, cz });
        }

        function unloadChunk(cx, cz) {
            const key = getChunkKey(cx, cz);
            if (!loadedChunks.has(key)) return;

            const chunk = loadedChunks.get(key);

            // Remove water plane if present
            if (chunk.terrain.userData.water) {
                scene.remove(chunk.terrain.userData.water);
                chunk.terrain.userData.water.geometry.dispose();
                chunk.terrain.userData.water.material.dispose();
            }

            // Remove terrain
            scene.remove(chunk.terrain);
            chunk.terrain.geometry.dispose();
            chunk.terrain.material.dispose();

            // Remove objects
            const objects = chunkObjects.get(key) || [];
            objects.forEach(obj => {
                scene.remove(obj);
                // Remove from buildings array
                const buildIdx = buildings.indexOf(obj);
                if (buildIdx > -1) buildings.splice(buildIdx, 1);
            });
            chunkObjects.delete(key);

            loadedChunks.delete(key);
        }

        function updateChunks(playerX, playerZ) {
            const { cx: playerCx, cz: playerCz } = worldToChunk(playerX, playerZ);

            // Load nearby chunks
            for (let dx = -RENDER_DISTANCE; dx <= RENDER_DISTANCE; dx++) {
                for (let dz = -RENDER_DISTANCE; dz <= RENDER_DISTANCE; dz++) {
                    loadChunk(playerCx + dx, playerCz + dz);
                }
            }

            // Unload distant chunks
            const chunksToUnload = [];
            loadedChunks.forEach((chunk, key) => {
                const dist = Math.max(
                    Math.abs(chunk.cx - playerCx),
                    Math.abs(chunk.cz - playerCz)
                );
                if (dist > RENDER_DISTANCE + 1) {
                    chunksToUnload.push([chunk.cx, chunk.cz]);
                }
            });

            chunksToUnload.forEach(([cx, cz]) => unloadChunk(cx, cz));
        }

        // Central fountain at origin
        createFountain(0, 0);

        // Home marker (visible beacon at spawn)
        const homeMarkerGeo = new THREE.CylinderGeometry(0.5, 0.5, 100, 8);
        const homeMarkerMat = new THREE.MeshBasicMaterial({
            color: 0x00ff00,
            transparent: true,
            opacity: 0.3
        });
        const homeMarker = new THREE.Mesh(homeMarkerGeo, homeMarkerMat);
        homeMarker.position.set(0, 50, 0);
        scene.add(homeMarker);

        console.log('Infinite planetary world initialized. Walk in any direction to generate new terrain!');

        // ============== MYSTERIOUS TERMINAL ==============
        let corruptionTerminal;

        function createTerminal() {
            const terminalGroup = new THREE.Group();
            const baseY = getTerrainHeight(15, -15);

            // Base pedestal
            const pedestalGeom = new THREE.CylinderGeometry(1.5, 2, 1, 8);
            const pedestalMat = new THREE.MeshStandardMaterial({
                color: 0x333333,
                roughness: 0.3,
                metalness: 0.7
            });
            const pedestal = new THREE.Mesh(pedestalGeom, pedestalMat);
            pedestal.position.y = 0.5;
            pedestal.castShadow = true;
            terminalGroup.add(pedestal);

            // Main terminal body
            const bodyGeom = new THREE.BoxGeometry(1.2, 2, 0.8);
            const bodyMat = new THREE.MeshStandardMaterial({
                color: 0x1a1a2e,
                roughness: 0.2,
                metalness: 0.8
            });
            const body = new THREE.Mesh(bodyGeom, bodyMat);
            body.position.y = 2;
            body.castShadow = true;
            terminalGroup.add(body);

            // Screen
            const screenGeom = new THREE.PlaneGeometry(0.9, 0.7);
            const screenMat = new THREE.MeshBasicMaterial({
                color: 0x00ff88
            });
            const screen = new THREE.Mesh(screenGeom, screenMat);
            screen.position.set(0, 2.3, 0.41);
            terminalGroup.add(screen);

            // Blinking indicator light
            const lightGeom = new THREE.SphereGeometry(0.1, 8, 8);
            const lightMat = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
            const indicator = new THREE.Mesh(lightGeom, lightMat);
            indicator.position.set(0.4, 1.6, 0.41);
            indicator.userData.blinkPhase = 0;
            terminalGroup.add(indicator);

            // Label
            const labelGeom = new THREE.PlaneGeometry(1, 0.2);
            const labelCanvas = document.createElement('canvas');
            labelCanvas.width = 256;
            labelCanvas.height = 64;
            const ctx = labelCanvas.getContext('2d');
            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, 0, 256, 64);
            ctx.fillStyle = '#00ff88';
            ctx.font = 'bold 24px monospace';
            ctx.textAlign = 'center';
            ctx.fillText('SYSTEM ACCESS', 128, 40);
            const labelTexture = new THREE.CanvasTexture(labelCanvas);
            const labelMat = new THREE.MeshBasicMaterial({ map: labelTexture });
            const label = new THREE.Mesh(labelGeom, labelMat);
            label.position.set(0, 1.3, 0.41);
            terminalGroup.add(label);

            terminalGroup.position.set(15, baseY, -15);
            terminalGroup.userData.type = 'terminal';
            terminalGroup.userData.isInteractable = true;
            terminalGroup.userData.indicator = indicator;
            terminalGroup.userData.screen = screen;
            terminalGroup.userData.screenMat = screenMat;

            scene.add(terminalGroup);
            return terminalGroup;
        }

        corruptionTerminal = createTerminal();

        // ============== CORRUPTION TRIGGER ==============
        function triggerCorruption() {
            if (state.corruptionStarted) return;

            state.corruptionStarted = true;

            // UI transitions
            document.getElementById('hud').classList.remove('pristine');
            document.getElementById('title').textContent = 'REALITY v1.0.0';
            document.getElementById('pristine-hint').style.display = 'none';
            document.getElementById('corrupt-hint').style.display = 'block';
            document.getElementById('controls').classList.remove('hidden');
            document.getElementById('crosshair').classList.remove('pristine');

            // Terminal goes haywire
            if (corruptionTerminal) {
                corruptionTerminal.userData.screenMat.color.setHex(0xff0000);
                corruptionTerminal.userData.corrupted = true;
            }

            // Dramatic messages
            addMessage('WARNING: Unauthorized access detected', 'warning');
            setTimeout(() => addMessage('SYSTEM INTEGRITY COMPROMISED', 'error'), 1000);
            setTimeout(() => addMessage('Reality substrate destabilizing...', 'error', true), 2500);
            setTimeout(() => addMessage('Anomalies emerging. You can REPAIR or EXPLOIT them.', 'warning'), 4000);

            // Initial glitch burst
            state.glitchIntensity = 0.5;

            // Spawn first anomaly after a delay
            setTimeout(() => {
                if (state.corruptionStarted) spawnRandomAnomaly();
            }, 6000);
        }

        // ============== NPCS ==============
        const npcs = [];

        class NPC {
            constructor(x, z) {
                const bodyGeom = new THREE.CapsuleGeometry(0.3, 1, 4, 8);
                const bodyMat = new THREE.MeshStandardMaterial({
                    color: new THREE.Color().setHSL(Math.random(), 0.6, 0.5)
                });

                this.mesh = new THREE.Mesh(bodyGeom, bodyMat);
                this.mesh.position.set(x, 1, z);
                this.mesh.castShadow = true;
                this.mesh.userData.type = 'npc';
                this.mesh.userData.npc = this;

                // Head
                const headGeom = new THREE.SphereGeometry(0.25, 8, 8);
                const head = new THREE.Mesh(headGeom, bodyMat);
                head.position.y = 0.9;
                this.mesh.add(head);

                this.velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 2,
                    0,
                    (Math.random() - 0.5) * 2
                );

                this.originalPosition = this.mesh.position.clone();
                this.walkCycle = Math.random() * Math.PI * 2;
                this.glitchState = 'normal';
                this.loopTimer = 0;
                this.stutterTimer = 0;
                this.frozenTime = 0;

                scene.add(this.mesh);
                npcs.push(this);
            }

            update(deltaTime, corruption) {
                if (state.gameOver) return;

                const distortedDelta = deltaTime * state.timeDistortion;

                // In pristine mode, NPCs behave normally
                if (!state.corruptionStarted) {
                    this.normalBehavior(distortedDelta);
                    return;
                }

                // Random glitch chance based on corruption
                if (this.glitchState === 'normal' && Math.random() < corruption * 0.001) {
                    const glitchTypes = ['loop', 'stutter', 'freeze', 'teleport', 'phase'];
                    this.glitchState = glitchTypes[Math.floor(Math.random() * glitchTypes.length)];
                    this.glitchTimer = 0;

                    if (!this.mesh.userData.isAnomaly) {
                        this.mesh.userData.isAnomaly = true;
                        state.anomalies.push(this.mesh);
                        addMessage(`NPC BEHAVIORAL ANOMALY DETECTED`, 'warning');
                    }
                }

                switch (this.glitchState) {
                    case 'normal':
                        this.normalBehavior(distortedDelta);
                        break;
                    case 'loop':
                        this.loopBehavior(distortedDelta);
                        break;
                    case 'stutter':
                        this.stutterBehavior(distortedDelta);
                        break;
                    case 'freeze':
                        this.freezeBehavior(distortedDelta);
                        break;
                    case 'teleport':
                        this.teleportBehavior(distortedDelta);
                        break;
                    case 'phase':
                        this.phaseBehavior(distortedDelta);
                        break;
                }
            }

            normalBehavior(delta) {
                this.walkCycle += delta * 5;
                this.mesh.position.x += this.velocity.x * delta;
                this.mesh.position.z += this.velocity.z * delta;
                this.mesh.position.y = 1 + Math.sin(this.walkCycle) * 0.1;

                // Bounce off boundaries
                if (Math.abs(this.mesh.position.x) > 80) this.velocity.x *= -1;
                if (Math.abs(this.mesh.position.z) > 80) this.velocity.z *= -1;

                // Face direction
                this.mesh.rotation.y = Math.atan2(this.velocity.x, this.velocity.z);
            }

            loopBehavior(delta) {
                this.loopTimer += delta;
                const loopDuration = 2;
                const t = (this.loopTimer % loopDuration) / loopDuration;

                // Walk in small circle
                const radius = 2;
                this.mesh.position.x = this.originalPosition.x + Math.cos(t * Math.PI * 2) * radius;
                this.mesh.position.z = this.originalPosition.z + Math.sin(t * Math.PI * 2) * radius;
                this.mesh.position.y = 1 + Math.sin(t * Math.PI * 8) * 0.1;
                this.mesh.rotation.y = t * Math.PI * 2;

                // Visual indication
                this.mesh.material.emissive.setHex(0xff00ff);
                this.mesh.material.emissiveIntensity = 0.3 + Math.sin(this.loopTimer * 10) * 0.2;
            }

            stutterBehavior(delta) {
                this.stutterTimer += delta;

                // Stutter movement
                if (Math.floor(this.stutterTimer * 20) % 3 === 0) {
                    this.mesh.position.x += this.velocity.x * delta * 3;
                    this.mesh.position.z += this.velocity.z * delta * 3;
                }

                // Stutter rotation
                this.mesh.rotation.y += (Math.random() - 0.5) * 0.5;

                // Visual glitch
                this.mesh.material.emissive.setHex(0xffff00);
                this.mesh.material.emissiveIntensity = Math.random() * 0.5;
            }

            freezeBehavior(delta) {
                this.frozenTime += delta;

                // Frozen in place with occasional jitter
                if (Math.random() < 0.02) {
                    this.mesh.position.x += (Math.random() - 0.5) * 0.1;
                    this.mesh.position.z += (Math.random() - 0.5) * 0.1;
                }

                // T-pose glitch
                this.mesh.material.emissive.setHex(0x00ffff);
                this.mesh.material.emissiveIntensity = 0.5;
            }

            teleportBehavior(delta) {
                this.glitchTimer = (this.glitchTimer || 0) + delta;

                if (this.glitchTimer > 0.5) {
                    this.glitchTimer = 0;
                    // Random teleport nearby
                    this.mesh.position.x += (Math.random() - 0.5) * 10;
                    this.mesh.position.z += (Math.random() - 0.5) * 10;

                    // Flash effect
                    state.glitchIntensity = Math.min(1, state.glitchIntensity + 0.2);
                }

                this.mesh.material.emissive.setHex(0xff0000);
                this.mesh.material.emissiveIntensity = 0.5 + Math.sin(this.glitchTimer * 30) * 0.3;
            }

            phaseBehavior(delta) {
                this.glitchTimer = (this.glitchTimer || 0) + delta;

                // Phase in and out
                this.mesh.material.opacity = 0.3 + Math.sin(this.glitchTimer * 5) * 0.5;
                this.mesh.material.transparent = true;

                // Slow normal movement
                this.normalBehavior(delta * 0.3);

                this.mesh.material.emissive.setHex(0x00ff00);
                this.mesh.material.emissiveIntensity = 1 - this.mesh.material.opacity;
            }

            repair() {
                this.glitchState = 'normal';
                this.mesh.material.emissive.setHex(0x000000);
                this.mesh.material.emissiveIntensity = 0;
                this.mesh.material.opacity = 1;
                this.mesh.material.transparent = false;
                this.mesh.userData.isAnomaly = false;

                const idx = state.anomalies.indexOf(this.mesh);
                if (idx > -1) state.anomalies.splice(idx, 1);
            }

            exploit() {
                // Amplify glitch effect
                this.glitchState = 'teleport';

                // Spread corruption
                state.corruption += 2;

                // Create afterimages
                for (let i = 0; i < 5; i++) {
                    setTimeout(() => {
                        const ghost = this.mesh.clone();
                        ghost.material = this.mesh.material.clone();
                        ghost.material.transparent = true;
                        ghost.material.opacity = 0.3;
                        ghost.position.x += (Math.random() - 0.5) * 5;
                        ghost.position.z += (Math.random() - 0.5) * 5;
                        scene.add(ghost);

                        setTimeout(() => scene.remove(ghost), 2000);
                    }, i * 100);
                }
            }
        }

        // Spawn NPCs
        for (let i = 0; i < 30; i++) {
            new NPC(
                (Math.random() - 0.5) * 150,
                (Math.random() - 0.5) * 150
            );
        }

        // ============== ANOMALY TYPES ==============
        function createVoidZone(x, z) {
            const geometry = new THREE.CircleGeometry(3 + Math.random() * 5, 32);
            const material = new THREE.MeshBasicMaterial({
                color: 0x000000,
                transparent: true,
                opacity: 0.9,
                side: THREE.DoubleSide
            });

            const void_ = new THREE.Mesh(geometry, material);
            void_.position.set(x, 0.1, z);
            void_.rotation.x = -Math.PI / 2;
            void_.userData.type = 'void';
            void_.userData.isAnomaly = true;
            void_.userData.pulsePhase = Math.random() * Math.PI * 2;

            // Add void tendrils
            for (let i = 0; i < 8; i++) {
                const tendril = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.1, 0.3, 2, 8),
                    new THREE.MeshBasicMaterial({ color: 0x110011 })
                );
                tendril.position.set(
                    Math.cos(i / 8 * Math.PI * 2) * 2,
                    1,
                    Math.sin(i / 8 * Math.PI * 2) * 2
                );
                tendril.rotation.x = (Math.random() - 0.5) * 0.5;
                tendril.rotation.z = (Math.random() - 0.5) * 0.5;
                void_.add(tendril);
            }

            scene.add(void_);
            state.voidZones.push(void_);
            state.anomalies.push(void_);

            addMessage('VOID BREACH DETECTED', 'error');
            return void_;
        }

        function createZFightingGlitch(building) {
            // Create duplicate geometry that z-fights
            const clone = building.clone();
            clone.material = building.material.clone();
            clone.material.color.setHex(0xff00ff);
            clone.position.copy(building.position);
            clone.scale.multiplyScalar(1.001); // Slightly larger to cause z-fighting
            clone.userData.type = 'zfight';
            clone.userData.isAnomaly = true;
            clone.userData.parentBuilding = building;
            clone.userData.flickerPhase = 0;

            scene.add(clone);
            state.anomalies.push(clone);

            addMessage('RENDER CONFLICT DETECTED', 'warning');
            return clone;
        }

        function createTextureCorruption(building) {
            building.userData.textureCorrupted = true;
            building.userData.isAnomaly = true;
            building.userData.corruptionPhase = 0;

            // Replace texture with noise
            const canvas = document.createElement('canvas');
            canvas.width = 64;
            canvas.height = 64;
            const ctx = canvas.getContext('2d');

            const texture = new THREE.CanvasTexture(canvas);
            building.userData.corruptionCanvas = ctx;
            building.userData.corruptionTexture = texture;
            building.material.map = texture;
            building.material.needsUpdate = true;

            state.anomalies.push(building);
            addMessage('TEXTURE LOAD FAILURE', 'error');
        }

        function updateCorruptedTexture(building, time) {
            const ctx = building.userData.corruptionCanvas;
            if (!ctx) return;

            const imgData = ctx.createImageData(64, 64);
            for (let i = 0; i < imgData.data.length; i += 4) {
                const noise = Math.random();
                const glitch = Math.sin(time * 10 + i * 0.01) > 0.8;

                if (glitch) {
                    imgData.data[i] = 255;
                    imgData.data[i + 1] = 0;
                    imgData.data[i + 2] = 255;
                } else {
                    const gray = noise * 100;
                    imgData.data[i] = gray;
                    imgData.data[i + 1] = gray;
                    imgData.data[i + 2] = gray;
                }
                imgData.data[i + 3] = 255;
            }
            ctx.putImageData(imgData, 0, 0);
            building.userData.corruptionTexture.needsUpdate = true;
        }

        // ============== CORRUPTION SYSTEM ==============
        function updateCorruption(deltaTime) {
            if (state.gameOver) return;

            // In pristine mode, no corruption happens
            if (!state.corruptionStarted) {
                state.explorationTime += deltaTime;
                return;
            }

            // Natural corruption increase
            state.corruption += deltaTime * 0.5;

            // Cap corruption
            state.corruption = Math.min(100, Math.max(0, state.corruption));

            // Update UI
            document.getElementById('corruption-fill').style.width = state.corruption + '%';
            document.getElementById('corruption-text').textContent =
                `Corruption: ${Math.floor(state.corruption)}%`;

            // Update glitch overlay
            document.getElementById('corruption-glitch').style.opacity = state.corruption / 100 * 0.5;
            document.querySelector('.scanlines').style.opacity = state.corruption / 100 * 0.3;

            // Spawn anomalies based on corruption
            if (state.corruption > 10 && Math.random() < 0.001 * state.corruption) {
                spawnRandomAnomaly();
            }

            // Physics inversion at high corruption
            if (state.corruption > 60 && !state.physicsInverted && Math.random() < 0.001) {
                state.physicsInverted = true;
                addMessage('GRAVITY VECTOR INVERTED', 'error', true);
            }

            // Time distortion
            if (state.corruption > 40) {
                state.timeDistortion = 1 + Math.sin(Date.now() * 0.001) * (state.corruption / 100) * 0.5;
            }

            // Screen tears
            if (state.corruption > 30 && Math.random() < 0.01 * (state.corruption / 100)) {
                triggerScreenTear();
            }

            // Reality collapse
            if (state.corruption >= 100) {
                collapseReality();
            }
        }

        function spawnRandomAnomaly() {
            const anomalyTypes = ['void', 'zfight', 'texture'];
            const type = anomalyTypes[Math.floor(Math.random() * anomalyTypes.length)];

            switch (type) {
                case 'void':
                    createVoidZone(
                        (Math.random() - 0.5) * 150,
                        (Math.random() - 0.5) * 150
                    );
                    break;
                case 'zfight':
                    if (buildings.length > 0) {
                        const building = buildings[Math.floor(Math.random() * buildings.length)];
                        if (!building.userData.hasZFight) {
                            building.userData.hasZFight = true;
                            createZFightingGlitch(building);
                        }
                    }
                    break;
                case 'texture':
                    if (buildings.length > 0) {
                        const building = buildings[Math.floor(Math.random() * buildings.length)];
                        if (!building.userData.textureCorrupted) {
                            createTextureCorruption(building);
                        }
                    }
                    break;
            }

            updateAnomalyCount();
        }

        function triggerScreenTear() {
            const tear = document.getElementById('tear1');
            tear.style.top = (Math.random() * 100) + '%';
            tear.style.opacity = '1';
            tear.style.transform = 'scaleX(1)';

            setTimeout(() => {
                tear.style.opacity = '0';
                tear.style.transform = 'scaleX(0)';
            }, 50 + Math.random() * 100);
        }

        function collapseReality() {
            state.gameOver = true;
            state.realityCollapsed = true;

            const status = document.getElementById('reality-status');
            status.innerHTML = 'REALITY.EXE HAS STOPPED WORKING<br><span style="font-size: 24px">Total Corruption Achieved</span>';
            status.style.opacity = '1';

            // Final glitch burst
            state.glitchIntensity = 1;

            // Void everything
            document.getElementById('void-flash').style.opacity = '0.9';

            addMessage('SIMULATION TERMINATED', 'error', true);
        }

        // ============== INTERACTION ==============
        function interactWithAnomaly() {
            if (state.mode === 'observe' || state.gameOver) return;

            // Raycast from camera
            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);

            const intersects = raycaster.intersectObjects(scene.children, true);

            for (const hit of intersects) {
                let obj = hit.object;

                // Walk up to parent if needed
                while (obj.parent && !obj.userData.isAnomaly) {
                    obj = obj.parent;
                }

                if (obj.userData.isAnomaly) {
                    if (state.mode === 'repair') {
                        repairAnomaly(obj);
                    } else if (state.mode === 'exploit') {
                        exploitAnomaly(obj);
                    }
                    break;
                }
            }
        }

        function repairAnomaly(obj) {
            const type = obj.userData.type;

            switch (type) {
                case 'void':
                    scene.remove(obj);
                    const voidIdx = state.voidZones.indexOf(obj);
                    if (voidIdx > -1) state.voidZones.splice(voidIdx, 1);
                    state.corruption -= 5;
                    addMessage('Void breach sealed', 'message');
                    break;

                case 'zfight':
                    scene.remove(obj);
                    if (obj.userData.parentBuilding) {
                        obj.userData.parentBuilding.userData.hasZFight = false;
                    }
                    state.corruption -= 3;
                    addMessage('Render conflict resolved', 'message');
                    break;

                case 'building':
                    if (obj.userData.textureCorrupted) {
                        obj.material.map = null;
                        obj.material.needsUpdate = true;
                        obj.userData.textureCorrupted = false;
                        state.corruption -= 4;
                        addMessage('Texture restored', 'message');
                    }
                    break;

                case 'npc':
                    if (obj.userData.npc) {
                        obj.userData.npc.repair();
                        state.corruption -= 2;
                        addMessage('NPC behavior normalized', 'message');
                    }
                    break;
            }

            // Remove from anomalies list
            const idx = state.anomalies.indexOf(obj);
            if (idx > -1) state.anomalies.splice(idx, 1);

            obj.userData.isAnomaly = false;
            state.repairCount++;
            updateStats();
            updateAnomalyCount();
        }

        function exploitAnomaly(obj) {
            const type = obj.userData.type;

            // Exploiting anomalies gives power but increases corruption
            switch (type) {
                case 'void':
                    // Void jump - teleport player
                    const angle = Math.random() * Math.PI * 2;
                    const dist = 20 + Math.random() * 30;
                    camera.position.x += Math.cos(angle) * dist;
                    camera.position.z += Math.sin(angle) * dist;
                    state.corruption += 3;
                    state.glitchIntensity = Math.min(1, state.glitchIntensity + 0.5);
                    addMessage('VOID JUMP EXECUTED', 'warning');
                    break;

                case 'zfight':
                    // Duplicate exploit - spawn items
                    for (let i = 0; i < 3; i++) {
                        const clone = obj.clone();
                        clone.position.x += (Math.random() - 0.5) * 20;
                        clone.position.z += (Math.random() - 0.5) * 20;
                        clone.userData.isAnomaly = false;
                        scene.add(clone);
                    }
                    state.corruption += 5;
                    addMessage('DUPLICATION EXPLOIT', 'warning');
                    break;

                case 'npc':
                    if (obj.userData.npc) {
                        obj.userData.npc.exploit();
                        addMessage('NPC BEHAVIOR AMPLIFIED', 'warning');
                    }
                    break;

                default:
                    state.corruption += 2;
                    state.glitchIntensity = Math.min(1, state.glitchIntensity + 0.3);
            }

            state.exploitCount++;
            updateStats();
        }

        // ============== PLAYER MOVEMENT ==============
        const velocity = new THREE.Vector3();
        const direction = new THREE.Vector3();
        let canJump = true;

        const keys = {
            forward: false,
            backward: false,
            left: false,
            right: false,
            jump: false
        };

        document.addEventListener('keydown', (e) => {
            switch (e.code) {
                case 'KeyW': keys.forward = true; break;
                case 'KeyS': keys.backward = true; break;
                case 'KeyA': keys.left = true; break;
                case 'KeyD': keys.right = true; break;
                case 'Space':
                    keys.jump = true;
                    if (canJump) {
                        velocity.y = state.physicsInverted ? -8 : 8;
                        canJump = false;
                    }
                    break;
                case 'KeyE':
                    state.mode = 'repair';
                    updateModeIndicator();
                    break;
                case 'KeyQ':
                    state.mode = 'exploit';
                    updateModeIndicator();
                    break;
            }
        });

        document.addEventListener('keyup', (e) => {
            switch (e.code) {
                case 'KeyW': keys.forward = false; break;
                case 'KeyS': keys.backward = false; break;
                case 'KeyA': keys.left = false; break;
                case 'KeyD': keys.right = false; break;
                case 'Space': keys.jump = false; break;
            }
        });

        function updatePlayerMovement(deltaTime) {
            const speed = 25;
            const gravity = state.physicsInverted ? 25 : -25;

            direction.z = Number(keys.forward) - Number(keys.backward);
            direction.x = Number(keys.right) - Number(keys.left);
            direction.normalize();

            if (controls.isLocked) {
                velocity.x -= velocity.x * 5 * deltaTime;
                velocity.z -= velocity.z * 5 * deltaTime;
                velocity.y += gravity * deltaTime;

                if (keys.forward || keys.backward) {
                    velocity.z -= direction.z * speed * deltaTime * 10;
                }
                if (keys.left || keys.right) {
                    velocity.x -= direction.x * speed * deltaTime * 10;
                }

                controls.moveRight(-velocity.x * deltaTime);
                controls.moveForward(-velocity.z * deltaTime);

                camera.position.y += velocity.y * deltaTime;

                // Get terrain height at current position
                const terrainHeight = getTerrainHeight(camera.position.x, camera.position.z);
                const playerHeight = 2;  // Eye level above ground

                // Ground collision - follow terrain
                const groundLevel = state.physicsInverted ? terrainHeight + 100 : terrainHeight + playerHeight;
                if (state.physicsInverted) {
                    if (camera.position.y > groundLevel) {
                        camera.position.y = groundLevel;
                        velocity.y = 0;
                        canJump = true;
                    }
                } else {
                    if (camera.position.y < groundLevel) {
                        camera.position.y = groundLevel;
                        velocity.y = 0;
                        canJump = true;
                    }
                }

                // Track distance traveled for planetary circumnavigation
                distanceTraveled.x = camera.position.x;
                distanceTraveled.z = camera.position.z;

                // Check if player has walked around the planet
                const wrappedX = wrapCoord(camera.position.x);
                const wrappedZ = wrapCoord(camera.position.z);
                const distFromHome = Math.sqrt(wrappedX * wrappedX + wrappedZ * wrappedZ);
                const totalDist = Math.sqrt(distanceTraveled.x * distanceTraveled.x + distanceTraveled.z * distanceTraveled.z);

                // Detect circumnavigation
                if (totalDist > PLANET_CIRCUMFERENCE * 0.7 && distFromHome < 60 && !hasReturnedHome) {
                    hasReturnedHome = true;
                    addMessage('YOU HAVE CIRCUMNAVIGATED THE PLANET!', 'warning');
                    addMessage('You returned to where you started.', 'message');
                    // Flash effect
                    state.glitchIntensity = 0.5;
                }

                // Void zone damage
                for (const void_ of state.voidZones) {
                    const dist = camera.position.distanceTo(void_.position);
                    if (dist < 5) {
                        state.corruption += deltaTime * 5;
                        state.glitchIntensity = Math.min(1, state.glitchIntensity + deltaTime);
                    }
                }
            }
        }

        // ============== UI HELPERS ==============
        function addMessage(text, type = 'message', glitched = false) {
            const messages = document.getElementById('messages');
            const msg = document.createElement('div');
            msg.className = `message ${type} ${glitched ? 'glitched' : ''}`;

            if (glitched) {
                // Corrupt the text
                text = text.split('').map(c =>
                    Math.random() < 0.2 ? String.fromCharCode(c.charCodeAt(0) + Math.floor(Math.random() * 10)) : c
                ).join('');
            }

            msg.textContent = `[${new Date().toLocaleTimeString()}] ${text}`;
            messages.appendChild(msg);

            // Keep only last 5 messages
            while (messages.children.length > 5) {
                messages.removeChild(messages.firstChild);
            }

            // Auto-remove after 5 seconds
            setTimeout(() => {
                if (msg.parentNode) {
                    msg.style.opacity = '0';
                    setTimeout(() => msg.remove(), 300);
                }
            }, 5000);
        }

        function updateModeIndicator() {
            const indicator = document.getElementById('mode-indicator');
            indicator.textContent = `MODE: ${state.mode.toUpperCase()}`;
            indicator.className = state.mode === 'exploit' ? 'exploit' : '';
        }

        function updateStats() {
            document.getElementById('repair-count').textContent = state.repairCount;
            document.getElementById('exploit-count').textContent = state.exploitCount;
        }

        function updateAnomalyCount() {
            document.getElementById('anomaly-count').textContent = state.anomalies.length;
        }

        // ============== ANIMATION LOOP ==============
        const clock = new THREE.Clock();
        let lastTime = 0;

        function animate() {
            requestAnimationFrame(animate);

            const time = clock.getElapsedTime();
            const deltaTime = Math.min(0.1, time - lastTime);
            lastTime = time;

            // Update corruption
            updateCorruption(deltaTime);

            // Update player
            updatePlayerMovement(deltaTime);

            // Update chunks based on player position
            updateChunks(camera.position.x, camera.position.z);

            // Move sky dome and clouds to follow player
            sky.position.x = camera.position.x;
            sky.position.z = camera.position.z;
            cloudGroup.position.x = camera.position.x;
            cloudGroup.position.z = camera.position.z;

            // Move sun to follow player
            sunLight.position.x = camera.position.x + 50;
            sunLight.position.z = camera.position.z + 50;
            sunLight.target.position.x = camera.position.x;
            sunLight.target.position.z = camera.position.z;

            // Update home marker visibility (show direction to origin)
            const wrappedPos = getWorldCoords(camera.position.x, camera.position.z);
            const homeDir = Math.atan2(-wrappedPos.z, -wrappedPos.x);
            homeMarker.position.x = camera.position.x + Math.cos(homeDir) * 200;
            homeMarker.position.z = camera.position.z + Math.sin(homeDir) * 200;
            homeMarker.material.opacity = Math.min(0.5, Math.sqrt(wrappedPos.x * wrappedPos.x + wrappedPos.z * wrappedPos.z) / 500);

            // Update NPCs
            for (const npc of npcs) {
                npc.update(deltaTime, state.corruption);
            }

            // Update terminal (blink indicator in pristine mode)
            if (corruptionTerminal && !state.corruptionStarted) {
                const indicator = corruptionTerminal.userData.indicator;
                if (indicator) {
                    indicator.userData.blinkPhase += deltaTime * 3;
                    indicator.material.color.setHex(
                        Math.sin(indicator.userData.blinkPhase) > 0 ? 0x00ff00 : 0x003300
                    );
                }
                // Subtle screen glow
                const screenMat = corruptionTerminal.userData.screenMat;
                if (screenMat) {
                    const pulse = 0.8 + Math.sin(time * 2) * 0.2;
                    screenMat.color.setRGB(0, pulse, pulse * 0.5);
                }
            } else if (corruptionTerminal && corruptionTerminal.userData.corrupted) {
                // Corrupted terminal flickers red
                const screenMat = corruptionTerminal.userData.screenMat;
                if (screenMat) {
                    screenMat.color.setRGB(
                        0.8 + Math.random() * 0.2,
                        Math.random() * 0.2,
                        Math.random() * 0.2
                    );
                }
            }

            // Update void zones
            for (const void_ of state.voidZones) {
                void_.userData.pulsePhase += deltaTime * 2;
                const scale = 1 + Math.sin(void_.userData.pulsePhase) * 0.2;
                void_.scale.set(scale, scale, 1);

                // Rotate tendrils
                void_.children.forEach((tendril, i) => {
                    tendril.rotation.y = time + i;
                    tendril.position.y = 1 + Math.sin(time * 2 + i) * 0.5;
                });
            }

            // Update corrupted textures
            for (const building of buildings) {
                if (building.userData.textureCorrupted) {
                    updateCorruptedTexture(building, time);
                }
            }

            // Update z-fighting glitches
            for (const anomaly of state.anomalies) {
                if (anomaly.userData.type === 'zfight') {
                    anomaly.userData.flickerPhase += deltaTime * 30;
                    anomaly.visible = Math.sin(anomaly.userData.flickerPhase) > 0;
                    anomaly.scale.setScalar(1.001 + Math.sin(anomaly.userData.flickerPhase * 0.5) * 0.002);
                }
            }

            // Sky corruption
            if (state.corruption > 50 && sky.userData.originalTopColor) {
                const corrupt = (state.corruption - 50) / 50;
                const topOrig = sky.userData.originalTopColor;
                const botOrig = sky.userData.originalBottomColor;

                sky.material.uniforms.topColor.value.setRGB(
                    topOrig.r * (1 - corrupt) + corrupt * (0.3 + Math.random() * 0.2),
                    topOrig.g * (1 - corrupt * 0.8),
                    topOrig.b * (1 - corrupt) + corrupt * 0.5
                );
                sky.material.uniforms.bottomColor.value.setRGB(
                    botOrig.r * (1 - corrupt) + corrupt * Math.random() * 0.3,
                    botOrig.g * (1 - corrupt * 0.5),
                    botOrig.b * (1 - corrupt * 0.3)
                );
            }

            // Cloud corruption
            if (state.corruption > 40) {
                const cloudCorrupt = (state.corruption - 40) / 60;
                cloudGroup.children.forEach((cloud, i) => {
                    cloud.material.opacity = 0.8 - cloudCorrupt * 0.6;
                    if (Math.random() < cloudCorrupt * 0.02) {
                        cloud.material.color.setHex(Math.random() > 0.5 ? 0xff00ff : 0x00ffff);
                    }
                });
            }

            // Ground warping
            if (state.corruption > 30) {
                const positions = ground.geometry.attributes.position.array;
                const original = ground.userData.originalVertices;

                for (let i = 0; i < positions.length; i += 3) {
                    const warpAmount = (state.corruption - 30) / 70;
                    positions[i + 2] = original[i + 2] +
                        Math.sin(time + original[i] * 0.1) *
                        Math.cos(time + original[i + 1] * 0.1) *
                        warpAmount * 3;
                }
                ground.geometry.attributes.position.needsUpdate = true;
            }

            // Decay glitch intensity
            state.glitchIntensity *= 0.95;

            // Update shader uniforms
            glitchPass.uniforms.time.value = time;
            glitchPass.uniforms.corruption.value = state.corruption / 100;
            glitchPass.uniforms.glitchIntensity.value = state.glitchIntensity + state.corruption / 200;

            // Bloom increases with corruption
            bloomPass.strength = 0.3 + state.corruption / 100 * 0.7;

            // Cloud movement
            cloudGroup.rotation.y += deltaTime * 0.005;
            cloudGroup.children.forEach((cloud, i) => {
                cloud.position.y += Math.sin(time * 0.5 + i) * 0.02;
            });

            // Fog gets weird
            if (state.corruption > 20) {
                const fogCorrupt = (state.corruption - 20) / 80;
                scene.fog.color.setRGB(
                    0.53 * (1 - fogCorrupt) + fogCorrupt * Math.sin(time) * 0.5,
                    0.81 * (1 - fogCorrupt),
                    0.92 * (1 - fogCorrupt) + fogCorrupt * 0.3
                );
                scene.fog.near = 100 - fogCorrupt * 80;
                scene.fog.far = 500 - fogCorrupt * 300;
            }

            // Render
            composer.render();
        }

        // ============== INIT ==============
        function init() {
            // Set camera to proper height above terrain
            const startHeight = getTerrainHeight(0, 20);
            camera.position.set(0, startHeight + 2, 20);

            // Load initial chunks around player
            updateChunks(camera.position.x, camera.position.z);

            addMessage('Welcome to Planet Reality v1.0.0');
            addMessage('Biomes: City, Forest, Desert, Mountains, Ocean, Tundra, Jungle, and more');
            addMessage(`Planetary circumference: ${PLANET_CIRCUMFERENCE} units - explore freely`);
            addMessage('Walk far enough and you will return to where you started.');

            // Hint about terminal after some exploration time
            setTimeout(() => {
                if (!state.corruptionStarted) {
                    addMessage('There appears to be an access terminal nearby...');
                }
            }, 25000);

            setTimeout(() => {
                if (!state.corruptionStarted) {
                    addMessage('The terminal\'s screen is glowing. Click to interact.');
                }
            }, 45000);

            // Display coordinates periodically
            setInterval(() => {
                const w = getWorldCoords(camera.position.x, camera.position.z);
                const distFromHome = Math.sqrt(w.x * w.x + w.z * w.z);
                document.getElementById('title').textContent =
                    state.corruptionStarted ?
                    `REALITY v1.0.0 - ${Math.floor(distFromHome)}m from origin` :
                    `REALITY v1.0.0 - ${Math.floor(distFromHome)}m from origin`;
            }, 500);

            animate();
        }

        // Handle resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });

        init();
    </script>
</body>
</html>
