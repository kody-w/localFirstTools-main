<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Determinism Debugger</title>
    <meta name="description" content="Every choice you make is revealed to have been predetermined. Experience the vertigo of watching your decisions unfold as predictable patterns.">
    <!-- tags: philosophy, experimental, psychology, interactive, educational -->
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            background: #0a0a0f;
            min-height: 100vh;
            font-family: 'SF Mono', 'Consolas', monospace;
            color: #a0a0a0;
            overflow: hidden;
        }

        .container {
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .header {
            padding: 20px;
            text-align: center;
            border-bottom: 1px solid #222;
        }

        h1 {
            font-size: 1.8em;
            font-weight: 300;
            color: #666;
            letter-spacing: 0.1em;
        }

        .phase-indicator {
            margin-top: 10px;
            font-size: 0.9em;
            color: #444;
        }

        .main-area {
            flex: 1;
            display: flex;
            position: relative;
        }

        .tracking-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            opacity: 0.3;
        }

        .choice-panel {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 40px;
        }

        .question {
            font-size: 1.5em;
            color: #888;
            margin-bottom: 40px;
            text-align: center;
            max-width: 600px;
        }

        .choices {
            display: flex;
            gap: 30px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .choice-btn {
            padding: 25px 50px;
            font-size: 1.2em;
            font-family: inherit;
            background: rgba(255, 255, 255, 0.03);
            border: 2px solid #333;
            color: #888;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .choice-btn:hover {
            background: rgba(255, 255, 255, 0.08);
            border-color: #555;
            color: #ccc;
        }

        .choice-btn::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, rgba(100, 100, 255, 0.1), transparent);
            opacity: 0;
            transition: opacity 0.3s;
        }

        .choice-btn:hover::after {
            opacity: 1;
        }

        .prediction-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.95);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100;
        }

        .prediction-overlay.visible {
            display: flex;
        }

        .prediction-title {
            font-size: 0.9em;
            color: #666;
            margin-bottom: 30px;
            letter-spacing: 0.2em;
        }

        .prediction-content {
            max-width: 700px;
            text-align: center;
            padding: 40px;
        }

        .your-choice {
            font-size: 2em;
            color: #4a9eff;
            margin-bottom: 20px;
        }

        .prediction-text {
            font-size: 1.1em;
            color: #888;
            line-height: 1.8;
            margin: 30px 0;
        }

        .evidence-panel {
            background: rgba(255, 255, 255, 0.02);
            border: 1px solid #333;
            padding: 30px;
            margin: 30px 0;
            text-align: left;
        }

        .evidence-title {
            color: #666;
            font-size: 0.8em;
            margin-bottom: 15px;
            letter-spacing: 0.1em;
        }

        .evidence-item {
            padding: 10px 0;
            border-bottom: 1px solid #222;
            display: flex;
            justify-content: space-between;
        }

        .evidence-label {
            color: #555;
        }

        .evidence-value {
            color: #4a9eff;
        }

        .replay-canvas {
            width: 400px;
            height: 200px;
            background: #111;
            border: 1px solid #333;
            margin: 20px 0;
        }

        .philosophical-quote {
            font-style: italic;
            color: #555;
            margin-top: 40px;
            font-size: 0.95em;
        }

        .continue-btn {
            margin-top: 30px;
            padding: 15px 40px;
            font-family: inherit;
            font-size: 1em;
            background: transparent;
            border: 1px solid #444;
            color: #666;
            cursor: pointer;
            transition: all 0.3s;
        }

        .continue-btn:hover {
            border-color: #666;
            color: #aaa;
        }

        .metrics-panel {
            position: fixed;
            right: 20px;
            top: 80px;
            width: 200px;
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid #222;
            padding: 15px;
            font-size: 0.75em;
            display: none;
        }

        .metrics-panel.visible {
            display: block;
        }

        .metric {
            display: flex;
            justify-content: space-between;
            padding: 5px 0;
            color: #555;
        }

        .metric-value {
            color: #4a9eff;
        }

        .final-revelation {
            text-align: center;
            padding: 50px;
        }

        .final-title {
            font-size: 2em;
            color: #888;
            margin-bottom: 30px;
        }

        .accuracy-display {
            font-size: 4em;
            color: #4a9eff;
            margin: 30px 0;
        }

        .final-message {
            font-size: 1.2em;
            color: #666;
            line-height: 1.8;
            max-width: 600px;
            margin: 0 auto;
        }

        .behavior-timeline {
            width: 100%;
            height: 100px;
            background: #111;
            margin: 30px 0;
            position: relative;
            overflow: hidden;
        }

        .timeline-event {
            position: absolute;
            width: 4px;
            background: #4a9eff;
            border-radius: 2px;
        }

        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .animate-in {
            animation: fadeInUp 0.6s ease forwards;
        }

        .choice-prediction {
            position: absolute;
            top: -30px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 0.75em;
            color: #ff6b6b;
            opacity: 0;
            transition: opacity 0.3s;
        }

        .choice-btn.predicted .choice-prediction {
            opacity: 1;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>THE DETERMINISM DEBUGGER</h1>
            <div class="phase-indicator" id="phaseIndicator">Recording your behavior patterns...</div>
        </div>

        <div class="main-area">
            <canvas class="tracking-canvas" id="trackingCanvas"></canvas>

            <div class="choice-panel" id="choicePanel">
                <div class="question" id="question">Loading...</div>
                <div class="choices" id="choices"></div>
            </div>
        </div>

        <div class="metrics-panel" id="metricsPanel">
            <div class="metric">
                <span>Mouse velocity</span>
                <span class="metric-value" id="velocityMetric">0</span>
            </div>
            <div class="metric">
                <span>Hesitation score</span>
                <span class="metric-value" id="hesitationMetric">0</span>
            </div>
            <div class="metric">
                <span>Pattern match</span>
                <span class="metric-value" id="patternMetric">0%</span>
            </div>
            <div class="metric">
                <span>Prediction conf.</span>
                <span class="metric-value" id="confidenceMetric">0%</span>
            </div>
        </div>
    </div>

    <div class="prediction-overlay" id="predictionOverlay">
        <div class="prediction-content" id="predictionContent"></div>
    </div>

    <script>
        // Behavior tracking
        const behavior = {
            mousePositions: [],
            velocities: [],
            hesitations: [],
            hoverTimes: {},
            clickPatterns: [],
            scrollEvents: [],
            choiceHistory: [],
            predictions: [],
            startTime: Date.now()
        };

        // Canvas for trajectory visualization
        const canvas = document.getElementById('trackingCanvas');
        const ctx = canvas.getContext('2d');

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // Mouse tracking
        let lastMousePos = { x: 0, y: 0, time: Date.now() };
        let isHovering = null;
        let hoverStartTime = 0;

        document.addEventListener('mousemove', (e) => {
            const now = Date.now();
            const dx = e.clientX - lastMousePos.x;
            const dy = e.clientY - lastMousePos.y;
            const dt = now - lastMousePos.time;

            const velocity = Math.sqrt(dx * dx + dy * dy) / Math.max(dt, 1);

            behavior.mousePositions.push({
                x: e.clientX,
                y: e.clientY,
                time: now,
                velocity: velocity
            });

            behavior.velocities.push(velocity);

            // Keep only last 500 positions
            if (behavior.mousePositions.length > 500) {
                behavior.mousePositions.shift();
            }
            if (behavior.velocities.length > 100) {
                behavior.velocities.shift();
            }

            lastMousePos = { x: e.clientX, y: e.clientY, time: now };

            // Draw trajectory
            drawTrajectory();

            // Update metrics
            updateMetrics();
        });

        // Track hesitations (mouse stopping)
        setInterval(() => {
            const recentPositions = behavior.mousePositions.slice(-10);
            if (recentPositions.length >= 10) {
                const firstPos = recentPositions[0];
                const lastPos = recentPositions[recentPositions.length - 1];
                const distance = Math.sqrt(
                    Math.pow(lastPos.x - firstPos.x, 2) +
                    Math.pow(lastPos.y - firstPos.y, 2)
                );

                if (distance < 20) {
                    behavior.hesitations.push({
                        x: lastPos.x,
                        y: lastPos.y,
                        time: Date.now(),
                        duration: lastPos.time - firstPos.time
                    });
                }
            }
        }, 100);

        function drawTrajectory() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            if (behavior.mousePositions.length < 2) return;

            // Draw trail
            ctx.beginPath();
            ctx.strokeStyle = 'rgba(74, 158, 255, 0.15)';
            ctx.lineWidth = 2;

            const positions = behavior.mousePositions.slice(-100);
            ctx.moveTo(positions[0].x, positions[0].y);

            for (let i = 1; i < positions.length; i++) {
                ctx.lineTo(positions[i].x, positions[i].y);
            }
            ctx.stroke();

            // Draw hesitation points
            ctx.fillStyle = 'rgba(255, 107, 107, 0.3)';
            behavior.hesitations.slice(-20).forEach(h => {
                ctx.beginPath();
                ctx.arc(h.x, h.y, 5 + h.duration / 100, 0, Math.PI * 2);
                ctx.fill();
            });
        }

        function updateMetrics() {
            const avgVelocity = behavior.velocities.length > 0
                ? behavior.velocities.reduce((a, b) => a + b, 0) / behavior.velocities.length
                : 0;

            document.getElementById('velocityMetric').textContent = avgVelocity.toFixed(1);
            document.getElementById('hesitationMetric').textContent = behavior.hesitations.length;

            // Calculate pattern match (how predictable the user is)
            const patternScore = calculatePatternScore();
            document.getElementById('patternMetric').textContent = patternScore + '%';

            // Prediction confidence
            const confidence = Math.min(95, 50 + behavior.choiceHistory.length * 10 + patternScore / 2);
            document.getElementById('confidenceMetric').textContent = confidence.toFixed(0) + '%';
        }

        function calculatePatternScore() {
            if (behavior.choiceHistory.length < 2) return 0;

            // Check for patterns in choices
            let patterns = 0;
            const choices = behavior.choiceHistory.map(c => c.chosen);

            // Check for alternation pattern
            let alternating = 0;
            for (let i = 1; i < choices.length; i++) {
                if (choices[i] !== choices[i - 1]) alternating++;
            }
            if (alternating > choices.length * 0.7) patterns += 30;

            // Check for consistency (same choice repeatedly)
            const firstChoice = choices.filter(c => c === 0).length;
            const ratio = firstChoice / choices.length;
            if (ratio > 0.7 || ratio < 0.3) patterns += 30;

            // Check for mouse movement patterns (left-leaning vs right-leaning)
            const avgX = behavior.mousePositions.reduce((a, p) => a + p.x, 0) / behavior.mousePositions.length;
            if (avgX < window.innerWidth * 0.4 || avgX > window.innerWidth * 0.6) {
                patterns += 20;
            }

            return Math.min(100, patterns + behavior.choiceHistory.length * 5);
        }

        // Choice questions
        const questions = [
            {
                text: "Choose freely.",
                options: ["LEFT", "RIGHT"]
            },
            {
                text: "Pick one. There is no wrong answer.",
                options: ["OPTION A", "OPTION B"]
            },
            {
                text: "Which calls to you?",
                options: ["CHAOS", "ORDER"]
            },
            {
                text: "Select intuitively.",
                options: ["YES", "NO"]
            },
            {
                text: "One will be yours.",
                options: ["PAST", "FUTURE"]
            },
            {
                text: "Make your choice.",
                options: ["CREATION", "DESTRUCTION"]
            },
            {
                text: "Which resonates?",
                options: ["SILENCE", "NOISE"]
            },
            {
                text: "Decide now.",
                options: ["STAY", "LEAVE"]
            }
        ];

        let currentQuestion = 0;
        let predictionShown = false;

        function showQuestion() {
            if (currentQuestion >= questions.length) {
                showFinalRevelation();
                return;
            }

            const q = questions[currentQuestion];
            document.getElementById('question').textContent = q.text;

            const choicesDiv = document.getElementById('choices');
            choicesDiv.innerHTML = '';

            // Predict which option they'll choose
            const prediction = predictChoice(q.options);
            behavior.predictions.push(prediction);

            q.options.forEach((option, index) => {
                const btn = document.createElement('button');
                btn.className = 'choice-btn';
                btn.textContent = option;

                // Hidden prediction indicator
                const predSpan = document.createElement('span');
                predSpan.className = 'choice-prediction';
                predSpan.textContent = 'PREDICTED';
                btn.appendChild(predSpan);

                if (index === prediction.predictedIndex) {
                    btn.classList.add('predicted');
                }

                // Track hover
                btn.addEventListener('mouseenter', () => {
                    isHovering = index;
                    hoverStartTime = Date.now();
                });

                btn.addEventListener('mouseleave', () => {
                    if (isHovering === index) {
                        const hoverDuration = Date.now() - hoverStartTime;
                        if (!behavior.hoverTimes[currentQuestion]) {
                            behavior.hoverTimes[currentQuestion] = [];
                        }
                        behavior.hoverTimes[currentQuestion].push({
                            option: index,
                            duration: hoverDuration
                        });
                    }
                    isHovering = null;
                });

                btn.addEventListener('click', () => makeChoice(index, q.options, prediction));

                choicesDiv.appendChild(btn);
            });

            // Show metrics panel after first question
            if (currentQuestion > 0) {
                document.getElementById('metricsPanel').classList.add('visible');
            }
        }

        function predictChoice(options) {
            // Prediction algorithm based on behavior
            let scores = [50, 50]; // Base scores for each option

            // Factor 1: Mouse position tendency
            if (behavior.mousePositions.length > 10) {
                const recentX = behavior.mousePositions.slice(-30).reduce((a, p) => a + p.x, 0) / 30;
                if (recentX < window.innerWidth / 2) {
                    scores[0] += 15; // Left tendency
                } else {
                    scores[1] += 15; // Right tendency
                }
            }

            // Factor 2: Previous choice patterns
            if (behavior.choiceHistory.length > 0) {
                const lastChoice = behavior.choiceHistory[behavior.choiceHistory.length - 1].chosen;

                // People often alternate
                const oppositeIndex = lastChoice === 0 ? 1 : 0;
                scores[oppositeIndex] += 10;

                // Check for consistency pattern
                const sameChoiceCount = behavior.choiceHistory.filter(c => c.chosen === lastChoice).length;
                if (sameChoiceCount > behavior.choiceHistory.length * 0.6) {
                    scores[lastChoice] += 20; // They're consistent
                }
            }

            // Factor 3: Semantic preference (if we can detect it)
            const positiveWords = ['YES', 'CREATION', 'ORDER', 'FUTURE', 'STAY'];
            const negativeWords = ['NO', 'DESTRUCTION', 'CHAOS', 'PAST', 'LEAVE'];

            options.forEach((opt, i) => {
                if (positiveWords.includes(opt)) scores[i] += 8;
                if (negativeWords.includes(opt)) scores[i] -= 5;
            });

            // Factor 4: Reading order (left-to-right bias in English speakers)
            scores[0] += 5;

            // Factor 5: Hesitation patterns
            if (behavior.hesitations.length > 3) {
                const recentHesitations = behavior.hesitations.slice(-5);
                const avgX = recentHesitations.reduce((a, h) => a + h.x, 0) / recentHesitations.length;
                if (avgX < window.innerWidth / 2) {
                    scores[0] += 10;
                } else {
                    scores[1] += 10;
                }
            }

            const predictedIndex = scores[0] >= scores[1] ? 0 : 1;
            const confidence = Math.abs(scores[0] - scores[1]) / (scores[0] + scores[1]) * 100;

            return {
                predictedIndex,
                confidence: Math.min(95, 50 + confidence),
                factors: {
                    mousePosition: behavior.mousePositions.length > 10,
                    previousChoices: behavior.choiceHistory.length,
                    hesitations: behavior.hesitations.length
                }
            };
        }

        function makeChoice(chosenIndex, options, prediction) {
            behavior.choiceHistory.push({
                question: currentQuestion,
                chosen: chosenIndex,
                predicted: prediction.predictedIndex,
                correct: chosenIndex === prediction.predictedIndex,
                time: Date.now(),
                mousePositions: [...behavior.mousePositions.slice(-50)],
                hesitations: [...behavior.hesitations.slice(-10)]
            });

            // Show prediction reveal
            showPredictionReveal(chosenIndex, options, prediction);
        }

        function showPredictionReveal(chosenIndex, options, prediction) {
            const overlay = document.getElementById('predictionOverlay');
            const content = document.getElementById('predictionContent');

            const wasCorrect = chosenIndex === prediction.predictedIndex;
            const correctCount = behavior.choiceHistory.filter(c => c.correct).length;
            const accuracy = (correctCount / behavior.choiceHistory.length * 100).toFixed(0);

            content.innerHTML = `
                <div class="prediction-title">PREDICTION ANALYSIS</div>
                <div class="your-choice">You chose: ${options[chosenIndex]}</div>
                <div class="prediction-text">
                    ${wasCorrect
                        ? `I predicted this with ${prediction.confidence.toFixed(0)}% confidence.`
                        : `My prediction was ${options[prediction.predictedIndex]}. You surprised me... this time.`
                    }
                </div>

                <div class="evidence-panel">
                    <div class="evidence-title">BEHAVIORAL EVIDENCE</div>
                    <div class="evidence-item">
                        <span class="evidence-label">Mouse trajectory bias</span>
                        <span class="evidence-value">${getMouseBias()}</span>
                    </div>
                    <div class="evidence-item">
                        <span class="evidence-label">Hesitation pattern</span>
                        <span class="evidence-value">${behavior.hesitations.length} pause points</span>
                    </div>
                    <div class="evidence-item">
                        <span class="evidence-label">Average velocity</span>
                        <span class="evidence-value">${getAvgVelocity()} px/ms</span>
                    </div>
                    <div class="evidence-item">
                        <span class="evidence-label">Decision time</span>
                        <span class="evidence-value">${getDecisionTime()}</span>
                    </div>
                </div>

                <canvas class="replay-canvas" id="replayCanvas"></canvas>

                <div style="color: #555; margin-top: 20px;">
                    Running accuracy: <span style="color: #4a9eff;">${accuracy}%</span> (${correctCount}/${behavior.choiceHistory.length} predicted correctly)
                </div>

                <button class="continue-btn" onclick="nextQuestion()">
                    ${currentQuestion < questions.length - 1 ? 'Continue' : 'See Final Analysis'}
                </button>
            `;

            overlay.classList.add('visible');

            // Draw replay animation
            setTimeout(() => {
                drawReplay();
            }, 100);
        }

        function getMouseBias() {
            if (behavior.mousePositions.length < 10) return 'Insufficient data';
            const avgX = behavior.mousePositions.slice(-50).reduce((a, p) => a + p.x, 0) / 50;
            const center = window.innerWidth / 2;
            const bias = ((avgX - center) / center * 100).toFixed(0);
            return bias > 0 ? `+${bias}% right` : `${bias}% left`;
        }

        function getAvgVelocity() {
            if (behavior.velocities.length === 0) return '0';
            return (behavior.velocities.reduce((a, b) => a + b, 0) / behavior.velocities.length).toFixed(2);
        }

        function getDecisionTime() {
            const lastChoice = behavior.choiceHistory[behavior.choiceHistory.length - 1];
            if (!lastChoice) return 'N/A';
            const positions = lastChoice.mousePositions;
            if (positions.length < 2) return 'N/A';
            const duration = positions[positions.length - 1].time - positions[0].time;
            return (duration / 1000).toFixed(1) + 's';
        }

        function drawReplay() {
            const canvas = document.getElementById('replayCanvas');
            if (!canvas) return;

            const ctx = canvas.getContext('2d');
            const lastChoice = behavior.choiceHistory[behavior.choiceHistory.length - 1];
            if (!lastChoice) return;

            const positions = lastChoice.mousePositions;
            if (positions.length < 2) return;

            canvas.width = 400;
            canvas.height = 200;

            // Scale positions to fit canvas
            const minX = Math.min(...positions.map(p => p.x));
            const maxX = Math.max(...positions.map(p => p.x));
            const minY = Math.min(...positions.map(p => p.y));
            const maxY = Math.max(...positions.map(p => p.y));

            const scaleX = 380 / Math.max(maxX - minX, 1);
            const scaleY = 180 / Math.max(maxY - minY, 1);
            const scale = Math.min(scaleX, scaleY, 1);

            // Animate the replay
            let frame = 0;
            const totalFrames = positions.length;

            function animateReplay() {
                ctx.fillStyle = 'rgba(17, 17, 17, 0.1)';
                ctx.fillRect(0, 0, 400, 200);

                const end = Math.min(frame, totalFrames);

                // Draw path
                ctx.beginPath();
                ctx.strokeStyle = '#4a9eff';
                ctx.lineWidth = 2;

                for (let i = 0; i < end; i++) {
                    const x = 10 + (positions[i].x - minX) * scale;
                    const y = 10 + (positions[i].y - minY) * scale;

                    if (i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                ctx.stroke();

                // Draw current position
                if (end > 0) {
                    const current = positions[end - 1];
                    const x = 10 + (current.x - minX) * scale;
                    const y = 10 + (current.y - minY) * scale;

                    ctx.fillStyle = '#ff6b6b';
                    ctx.beginPath();
                    ctx.arc(x, y, 5, 0, Math.PI * 2);
                    ctx.fill();
                }

                frame += 2;
                if (frame < totalFrames + 20) {
                    requestAnimationFrame(animateReplay);
                }
            }

            animateReplay();
        }

        function nextQuestion() {
            document.getElementById('predictionOverlay').classList.remove('visible');
            currentQuestion++;
            showQuestion();
        }

        function showFinalRevelation() {
            const correctCount = behavior.choiceHistory.filter(c => c.correct).length;
            const totalCount = behavior.choiceHistory.length;
            const accuracy = (correctCount / totalCount * 100).toFixed(0);

            document.getElementById('choicePanel').innerHTML = `
                <div class="final-revelation animate-in">
                    <div class="final-title">FINAL ANALYSIS</div>

                    <div class="accuracy-display">${accuracy}%</div>
                    <div style="color: #666; margin-bottom: 30px;">
                        of your "free" choices were predicted
                    </div>

                    <div class="behavior-timeline" id="behaviorTimeline"></div>

                    <div class="final-message">
                        ${accuracy >= 70
                            ? `Your choices followed predictable patterns. Your mouse drifted ${getMouseBias()} on average.
                               You hesitated ${behavior.hesitations.length} times before deciding.
                               Your average decision velocity was ${getAvgVelocity()} px/ms.
                               <br><br>
                               Every micro-movement betrayed your "decision" before you made it.`
                            : `You showed some unpredictability. But consider: even your attempts to be random
                               followed detectable patterns. Your "chaos" had structure.`
                        }
                        <br><br>
                        <span style="color: #4a9eff;">If I could predict this, what does that say about the you who chose it?</span>
                    </div>

                    <div class="philosophical-quote">
                        "The initial configuration of the universe may be described in deterministic laws,
                        and if so, the entire future is already determined by those laws."
                        <br>â€” Laplace's Demon
                    </div>

                    <button class="continue-btn" onclick="location.reload()">
                        Try Again (Or Will You?)
                    </button>
                </div>
            `;

            // Draw timeline
            setTimeout(() => {
                const timeline = document.getElementById('behaviorTimeline');
                const totalTime = Date.now() - behavior.startTime;

                behavior.choiceHistory.forEach((choice, i) => {
                    const x = (choice.time - behavior.startTime) / totalTime * 100;
                    const event = document.createElement('div');
                    event.className = 'timeline-event';
                    event.style.left = x + '%';
                    event.style.height = choice.correct ? '60%' : '30%';
                    event.style.top = choice.correct ? '20%' : '35%';
                    event.style.background = choice.correct ? '#4a9eff' : '#ff6b6b';
                    event.title = `Choice ${i + 1}: ${choice.correct ? 'Predicted' : 'Surprised'}`;
                    timeline.appendChild(event);
                });
            }, 100);
        }

        // Initialize
        document.getElementById('phaseIndicator').textContent = 'Your behavior is being recorded...';
        showQuestion();
    </script>
</body>
</html>
