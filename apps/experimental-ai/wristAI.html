<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>AI Companion Hub - Interactive Assistant</title>

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #000;
            color: #fff;
            overflow: hidden;
            position: fixed;
            width: 100%;
            height: 100%;
            -webkit-overflow-scrolling: touch;
        }

        #three-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            touch-action: none;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
            cursor: default;
        }

        /* Wrist Mode Styles */
        .wrist-mode-container {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 3000;
            background: linear-gradient(135deg, #0a0a0f 0%, #1a1a2e 100%);
        }

        /* Show wrist mode in landscape on mobile */
        @media screen and (max-width: 768px) and (orientation: landscape) {
            .wrist-mode-container {
                display: block;
            }
            
            #three-container,
            .world-ui,
            .ai-companion-button,
            .tasks-button,
            .settings-button,
            .show-mode-button {
                display: none !important;
            }
        }

        /* Orientation Notice */
        .orientation-notice {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            z-index: 9999;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            text-align: center;
            padding: 20px;
        }

        .orientation-notice svg {
            width: 80px;
            height: 80px;
            margin-bottom: 20px;
            animation: rotate 2s ease-in-out infinite;
        }

        @keyframes rotate {
            0%, 100% { transform: rotate(-90deg); }
            50% { transform: rotate(0deg); }
        }

        .orientation-notice h2 {
            font-size: 24px;
            margin-bottom: 10px;
        }

        .orientation-notice p {
            font-size: 16px;
            opacity: 0.8;
            margin-bottom: 20px;
        }

        .orientation-notice button {
            background: linear-gradient(45deg, #8338ec, #3a86ff);
            color: white;
            border: none;
            padding: 12px 30px;
            border-radius: 25px;
            font-weight: bold;
            cursor: pointer;
            font-size: 16px;
            margin-top: 10px;
        }

        /* Wrist Interface Layout */
        .wrist-interface {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: grid;
            grid-template-columns: 1fr 2fr 1fr;
            grid-template-rows: 1fr;
            gap: 10px;
            padding: 10px;
            padding-left: env(safe-area-inset-left);
            padding-right: env(safe-area-inset-right);
        }

        /* Mini 3D Container */
        #mini-three-container {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            width: 120px;
            height: 120px;
            border-radius: 60px;
            overflow: hidden;
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid rgba(138, 43, 226, 0.3);
            cursor: pointer;
            transition: all 0.3s ease;
            z-index: 10;
        }

        #mini-three-container:active {
            transform: translateX(-50%) scale(0.95);
            border-color: rgba(138, 43, 226, 0.6);
        }

        .mini-orb-label {
            position: absolute;
            bottom: -25px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 11px;
            opacity: 0.7;
            white-space: nowrap;
        }

        /* Left Panel - Quick Actions */
        .left-panel {
            display: flex;
            flex-direction: column;
            gap: 10px;
            justify-content: center;
        }

        .quick-action-btn {
            background: rgba(138, 43, 226, 0.3);
            backdrop-filter: blur(10px);
            border: 2px solid rgba(138, 43, 226, 0.5);
            border-radius: 15px;
            padding: 15px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            height: 60px;
        }

        .quick-action-btn:active {
            transform: scale(0.95);
            background: rgba(138, 43, 226, 0.5);
        }

        .quick-action-btn svg {
            width: 24px;
            height: 24px;
            color: white;
        }

        /* Center Panel - Main Display */
        .center-panel {
            background: rgba(20, 20, 40, 0.85);
            border: 2px solid rgba(255, 255, 255, 0.1);
            border-radius: 20px;
            padding: 15px;
            padding-top: 140px;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            position: relative;
        }

        .ai-display {
            flex: 1;
            overflow-y: auto;
            margin-bottom: 10px;
            -webkit-overflow-scrolling: touch;
            scroll-behavior: smooth;
        }

        .ai-message {
            margin: 8px 0;
            padding: 10px 15px;
            border-radius: 15px;
            font-size: 14px;
            line-height: 1.4;
            max-width: 100%;
            word-wrap: break-word;
            animation: messageSlide 0.3s ease;
        }

        @keyframes messageSlide {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .ai-message.user {
            background: rgba(131, 56, 236, 0.3);
            text-align: right;
        }

        .ai-message.ai {
            background: rgba(6, 255, 165, 0.2);
        }

        .wrist-input-container {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .wrist-input {
            flex: 1;
            padding: 10px 15px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 20px;
            color: white;
            font-size: 14px;
            outline: none;
        }

        .voice-btn {
            background: linear-gradient(45deg, #ff006e, #ff4458);
            border: none;
            width: 50px;
            height: 40px;
            border-radius: 20px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
        }

        .voice-btn:active {
            transform: scale(0.9);
        }

        .voice-btn.recording {
            background: linear-gradient(45deg, #ff0000, #ff4444);
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(255, 0, 0, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(255, 0, 0, 0); }
            100% { box-shadow: 0 0 0 0 rgba(255, 0, 0, 0); }
        }

        /* Right Panel - Status & Controls */
        .right-panel {
            display: flex;
            flex-direction: column;
            gap: 10px;
            justify-content: space-between;
        }

        .status-indicator {
            background: rgba(0, 0, 0, 0.5);
            border-radius: 15px;
            padding: 10px;
            text-align: center;
            font-size: 12px;
        }

        .status-dot {
            width: 10px;
            height: 10px;
            background: #00ff00;
            border-radius: 50%;
            display: inline-block;
            margin-right: 5px;
            animation: blink 2s infinite;
        }

        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }

        .pause-voice-btn {
            background: rgba(255, 0, 0, 0.3);
            border: 2px solid rgba(255, 0, 0, 0.5);
            border-radius: 15px;
            padding: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
            font-size: 12px;
            font-weight: bold;
        }

        .pause-voice-btn:active {
            transform: scale(0.95);
        }

        .pause-voice-btn.paused {
            background: rgba(255, 165, 0, 0.3);
            border-color: rgba(255, 165, 0, 0.5);
        }

        /* Typing Indicator */
        .ai-typing {
            display: flex;
            align-items: center;
            gap: 5px;
            padding: 10px 15px;
            background: rgba(6, 255, 165, 0.2);
            border-radius: 15px;
            width: fit-content;
            margin: 8px 0;
        }

        .typing-dot {
            width: 6px;
            height: 6px;
            background: rgba(255, 255, 255, 0.6);
            border-radius: 50%;
            animation: typingPulse 1.4s infinite ease-in-out;
        }

        .typing-dot:nth-child(1) { animation-delay: -0.32s; }
        .typing-dot:nth-child(2) { animation-delay: -0.16s; }

        @keyframes typingPulse {
            0%, 80%, 100% {
                transform: scale(0.8);
                opacity: 0.5;
            }
            40% {
                transform: scale(1);
                opacity: 1;
            }
        }

        /* Preset Messages */
        .preset-messages {
            display: flex;
            gap: 5px;
            margin-bottom: 10px;
            overflow-x: auto;
            -webkit-overflow-scrolling: touch;
            scrollbar-width: none;
        }

        .preset-messages::-webkit-scrollbar {
            display: none;
        }

        .preset-msg {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 15px;
            padding: 5px 12px;
            font-size: 12px;
            white-space: nowrap;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .preset-msg:active {
            background: rgba(255, 255, 255, 0.2);
            transform: scale(0.95);
        }

        /* Show Mode Button */
        .show-mode-button {
            position: fixed;
            bottom: calc(env(safe-area-inset-bottom, 30px) + 240px);
            right: calc(env(safe-area-inset-right, 30px));
            width: 60px;
            height: 60px;
            background: rgba(0, 255, 255, 0.3);
            backdrop-filter: blur(10px);
            border: 2px solid rgba(0, 255, 255, 0.5);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            z-index: 1002;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.3);
        }

        .show-mode-button:hover {
            background: rgba(0, 255, 255, 0.5);
            transform: scale(1.1);
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.5);
        }

        .show-mode-button.active {
            background: rgba(0, 255, 0, 0.3);
            border-color: rgba(0, 255, 0, 0.5);
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.3);
        }

        .show-mode-button svg {
            width: 28px;
            height: 28px;
            color: white;
        }

        /* Show Mode Status */
        .show-mode-status {
            position: fixed;
            top: env(safe-area-inset-top, 80px);
            right: env(safe-area-inset-right, 20px);
            background: rgba(0, 0, 0, 0.8);
            padding: 10px 20px;
            border-radius: 20px;
            display: flex;
            align-items: center;
            gap: 10px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .show-mode-status.visible {
            opacity: 1;
        }

        .status-indicator {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: #888;
            transition: all 0.3s ease;
        }

        .status-indicator.connected {
            background: #00ff00;
            box-shadow: 0 0 10px #00ff00;
        }

        .status-indicator.hosting {
            background: #06ffa5;
            box-shadow: 0 0 10px #06ffa5;
        }

        .status-text {
            color: rgba(255, 255, 255, 0.8);
            font-size: 0.9em;
        }

        .viewer-count {
            color: #06ffa5;
            font-weight: bold;
        }

        /* Viewer Mode Indicator */
        .viewer-mode-indicator {
            position: fixed;
            top: env(safe-area-inset-top, 20px);
            left: env(safe-area-inset-left, 20px);
            background: rgba(138, 43, 226, 0.9);
            color: white;
            padding: 10px 20px;
            border-radius: 20px;
            display: none;
            align-items: center;
            gap: 10px;
            z-index: 1005;
            font-weight: bold;
            animation: pulse 2s infinite;
        }

        .viewer-mode-indicator.active {
            display: flex;
        }

        .viewer-mode-indicator svg {
            width: 20px;
            height: 20px;
        }

        /* Show Mode Modal */
        .show-mode-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            z-index: 2001;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(5px);
        }

        .show-mode-modal.show {
            display: flex;
        }

        .show-mode-modal-content {
            background: rgba(20, 20, 40, 0.95);
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 20px;
            padding: 30px;
            max-width: 400px;
            width: 90%;
            text-align: center;
            position: relative;
            box-shadow: 0 0 50px rgba(0, 255, 255, 0.3);
        }

        .modal-close {
            position: absolute;
            top: 15px;
            right: 15px;
            background: none;
            border: none;
            font-size: 30px;
            cursor: pointer;
            color: #fff;
            transition: all 0.3s;
        }

        .modal-close:hover {
            color: #ff006e;
            transform: rotate(90deg);
        }

        .show-mode-modal h3 {
            margin: 0 0 20px 0;
            font-size: 24px;
            background: linear-gradient(45deg, #00ffff, #0088ff, #06ffa5);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .show-mode-info {
            background: rgba(0, 255, 255, 0.1);
            border: 1px solid rgba(0, 255, 255, 0.3);
            border-radius: 10px;
            padding: 10px;
            margin: 15px 0;
            font-size: 0.9em;
            color: #06ffa5;
        }

        #qr-code-container {
            margin: 20px auto;
            display: flex;
            justify-content: center;
            padding: 20px;
            background: white;
            border-radius: 15px;
        }

        #qr-code-container canvas,
        #qr-code-container img {
            border-radius: 10px;
        }

        .qr-url {
            font-size: 12px;
            color: rgba(255, 255, 255, 0.7);
            word-break: break-all;
            margin: 20px 0;
            padding: 10px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            font-family: monospace;
        }

        .copy-url-btn {
            background: linear-gradient(45deg, #00ffff, #0088ff);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 25px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .copy-url-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 20px rgba(0, 255, 255, 0.4);
        }

        .copy-url-btn.copied {
            background: linear-gradient(45deg, #06ffa5, #00ff88);
        }

        /* Show Mode Notifications */
        .show-mode-notification {
            position: fixed;
            top: 100px;
            right: 20px;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 15px 25px;
            border-radius: 10px;
            border: 2px solid rgba(0, 255, 255, 0.5);
            animation: slideIn 0.3s ease;
            z-index: 1005;
            backdrop-filter: blur(10px);
        }

        @keyframes slideIn {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        /* Following Indicator */
        .following-indicator {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 255, 255, 0.9);
            color: #000;
            padding: 10px 20px;
            border-radius: 20px;
            display: none;
            align-items: center;
            gap: 10px;
            z-index: 1004;
            font-weight: bold;
            animation: pulse 2s infinite;
        }

        .following-indicator.active {
            display: flex;
        }

        @keyframes pulse {
            0%, 100% { opacity: 0.9; }
            50% { opacity: 0.6; }
        }

        /* Settings Button */
        .settings-button {
            position: fixed;
            bottom: calc(env(safe-area-inset-bottom, 30px) + 160px);
            right: calc(env(safe-area-inset-right, 30px));
            width: 60px;
            height: 60px;
            background: rgba(138, 43, 226, 0.3);
            backdrop-filter: blur(10px);
            border: 2px solid rgba(138, 43, 226, 0.5);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            z-index: 1002;
            box-shadow: 0 0 20px rgba(138, 43, 226, 0.3);
        }

        .settings-button:hover {
            background: rgba(138, 43, 226, 0.5);
            transform: scale(1.1);
            box-shadow: 0 0 30px rgba(138, 43, 226, 0.5);
        }

        .settings-button svg {
            width: 28px;
            height: 28px;
            color: white;
        }

        /* Settings Panel */
        .settings-panel {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(20, 20, 40, 0.95);
            border: 2px solid rgba(138, 43, 226, 0.5);
            border-radius: 20px;
            padding: 30px;
            z-index: 2003;
            max-width: 600px;
            width: 90%;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 0 50px rgba(138, 43, 226, 0.3);
            display: none;
            backdrop-filter: blur(10px);
        }

        .settings-panel.active {
            display: block;
        }

        .settings-panel h2 {
            margin: 0 0 25px 0;
            font-size: 28px;
            background: linear-gradient(45deg, #8a2be2, #06ffa5);
            background-clip: text;
            -webkit-text-fill-color: transparent;
            text-align: center;
        }

        .settings-tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 25px;
            border-bottom: 2px solid rgba(255, 255, 255, 0.1);
            padding-bottom: 15px;
        }

        .settings-tab {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            padding: 8px 16px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 14px;
        }

        .settings-tab:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .settings-tab.active {
            background: linear-gradient(45deg, #8a2be2, #06ffa5);
            border-color: transparent;
        }

        .settings-section {
            display: none;
        }

        .settings-section.active {
            display: block;
        }

        .settings-group {
            margin-bottom: 20px;
            padding: 20px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .settings-group h3 {
            margin: 0 0 15px 0;
            font-size: 18px;
            color: #06ffa5;
        }

        .setting-item {
            margin-bottom: 15px;
        }

        .setting-item label {
            display: block;
            margin-bottom: 5px;
            font-size: 14px;
            color: rgba(255, 255, 255, 0.8);
        }

        .setting-item input[type="text"],
        .setting-item input[type="password"],
        .setting-item input[type="number"],
        .setting-item select {
            width: 100%;
            padding: 10px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            color: white;
            font-size: 14px;
        }

        .setting-item input[type="range"] {
            width: 100%;
            height: 6px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
            outline: none;
            -webkit-appearance: none;
        }

        .setting-item input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            background: #8a2be2;
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .setting-item input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.2);
            background: #06ffa5;
        }

        .range-value {
            display: inline-block;
            margin-left: 10px;
            font-family: monospace;
            color: #06ffa5;
            font-size: 13px;
            min-width: 60px;
        }

        .toggle-setting {
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .toggle-switch {
            position: relative;
            width: 48px;
            height: 24px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .toggle-switch.active {
            background: #06ffa5;
        }

        .toggle-switch::after {
            content: '';
            position: absolute;
            top: 2px;
            left: 2px;
            width: 20px;
            height: 20px;
            background: white;
            border-radius: 50%;
            transition: all 0.3s ease;
        }

        .toggle-switch.active::after {
            transform: translateX(24px);
        }

        .settings-actions {
            display: flex;
            gap: 10px;
            margin-top: 25px;
            padding-top: 20px;
            border-top: 2px solid rgba(255, 255, 255, 0.1);
        }

        .settings-btn {
            flex: 1;
            padding: 12px 20px;
            background: linear-gradient(45deg, #8a2be2, #06ffa5);
            border: none;
            border-radius: 10px;
            color: white;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
        }

        .settings-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 20px rgba(138, 43, 226, 0.4);
        }

        .settings-btn.secondary {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
        }

        .settings-btn.danger {
            background: linear-gradient(45deg, #ff0066, #ff4458);
        }

        .close-settings {
            position: absolute;
            top: 15px;
            right: 15px;
            background: none;
            border: none;
            font-size: 30px;
            cursor: pointer;
            color: #fff;
            transition: all 0.3s;
        }

        .close-settings:hover {
            color: #ff006e;
            transform: rotate(90deg);
        }

        .import-export-section {
            margin-top: 20px;
            padding: 20px;
            background: rgba(138, 43, 226, 0.1);
            border-radius: 15px;
            border: 1px solid rgba(138, 43, 226, 0.3);
        }

        .import-export-section h4 {
            margin: 0 0 15px 0;
            color: #8a2be2;
            font-size: 16px;
        }

        .json-preview {
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            padding: 15px;
            font-family: monospace;
            font-size: 12px;
            max-height: 200px;
            overflow-y: auto;
            margin: 10px 0;
            white-space: pre-wrap;
            word-break: break-all;
        }

        .file-input-wrapper {
            position: relative;
            display: inline-block;
            width: 100%;
        }

        .file-input-wrapper input[type="file"] {
            position: absolute;
            opacity: 0;
            width: 100%;
            height: 100%;
            cursor: pointer;
        }

        .file-input-label {
            display: block;
            padding: 12px 20px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px dashed rgba(255, 255, 255, 0.3);
            border-radius: 10px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .file-input-label:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: #8a2be2;
        }

        /* Perspective Controls */
        .perspective-controls {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
        }

        .perspective-preset {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin-top: 15px;
        }

        .preset-btn {
            padding: 8px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            color: white;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .preset-btn:hover {
            background: rgba(138, 43, 226, 0.3);
            border-color: #8a2be2;
        }

        /* Click to Chat Tooltip */
        .companion-tooltip {
            position: absolute;
            background: rgba(255, 255, 255, 0.9);
            color: #000;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 14px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s ease;
            white-space: nowrap;
            z-index: 1010;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
        }

        .companion-tooltip.visible {
            opacity: 1;
        }

        /* Voice Pause Button - PROMINENT POSITION */
        .voice-pause-button {
            position: fixed;
            top: calc(env(safe-area-inset-top, 20px) + 60px);
            right: calc(env(safe-area-inset-right, 20px));
            width: 120px;
            height: 50px;
            background: rgba(255, 0, 0, 0.3);
            backdrop-filter: blur(10px);
            border: 2px solid rgba(255, 0, 0, 0.5);
            border-radius: 25px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            z-index: 1006;
            box-shadow: 0 0 20px rgba(255, 0, 0, 0.3);
            font-weight: bold;
            font-size: 14px;
        }

        .voice-pause-button:hover {
            background: rgba(255, 0, 0, 0.5);
            transform: scale(1.05);
            box-shadow: 0 0 30px rgba(255, 0, 0, 0.5);
        }

        .voice-pause-button.paused {
            background: rgba(255, 165, 0, 0.3);
            border-color: rgba(255, 165, 0, 0.5);
            box-shadow: 0 0 20px rgba(255, 165, 0, 0.3);
        }

        .voice-pause-button.paused:hover {
            background: rgba(255, 165, 0, 0.5);
            box-shadow: 0 0 30px rgba(255, 165, 0, 0.5);
        }

        .voice-pause-button svg {
            width: 24px;
            height: 24px;
            color: white;
        }

        /* Voice Paused Indicator */
        .voice-paused-indicator {
            position: fixed;
            top: calc(env(safe-area-inset-top, 20px) + 10px);
            right: calc(env(safe-area-inset-right, 20px));
            background: rgba(255, 165, 0, 0.9);
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            display: none;
            align-items: center;
            gap: 8px;
            z-index: 1005;
            animation: fadeIn 0.3s ease-out;
            font-size: 13px;
            font-weight: bold;
        }

        .voice-paused-indicator.active {
            display: flex;
        }

        .voice-paused-indicator svg {
            width: 16px;
            height: 16px;
            animation: blink 2s infinite;
        }

        @keyframes blink {
            0%, 50%, 100% { opacity: 1; }
            25%, 75% { opacity: 0.3; }
        }

        /* AI Companion Modal */
        .ai-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            z-index: 2002;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(5px);
        }

        .ai-modal.show {
            display: flex;
        }

        .ai-modal-content {
            background: rgba(20, 20, 40, 0.95);
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 20px;
            padding: 30px;
            max-width: 500px;
            width: 90%;
            text-align: center;
            position: relative;
            box-shadow: 0 0 50px rgba(138, 56, 236, 0.3);
            max-height: 90vh;
            overflow-y: auto;
        }

        .ai-modal-close {
            position: absolute;
            top: 15px;
            right: 15px;
            background: none;
            border: none;
            font-size: 30px;
            cursor: pointer;
            color: #fff;
            transition: all 0.3s;
        }

        .ai-modal-close:hover {
            color: #ff006e;
            transform: rotate(90deg);
        }

        .ai-modal h3 {
            margin: 0 0 20px 0;
            font-size: 24px;
            background: linear-gradient(45deg, #ff006e, #8338ec, #3a86ff, #06ffa5);
            background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .ai-api-key-input {
            width: 100%;
            padding: 12px;
            margin: 10px 0;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 10px;
            color: white;
            font-size: 14px;
            font-family: monospace;
        }

        .ai-api-key-input::placeholder {
            color: rgba(255, 255, 255, 0.5);
        }

        .ai-activate-btn {
            background: linear-gradient(45deg, #8338ec, #3a86ff);
            color: white;
            border: none;
            padding: 12px 30px;
            border-radius: 25px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-top: 10px;
        }

        .ai-activate-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 20px rgba(131, 56, 236, 0.4);
        }

        /* Voice Settings */
        .voice-settings {
            margin-top: 20px;
            padding-top: 20px;
            border-top: 1px solid rgba(255, 255, 255, 0.2);
        }

        .voice-settings h4 {
            color: #06ffa5;
            margin-bottom: 15px;
            font-size: 16px;
        }

        .form-group {
            margin-bottom: 15px;
            text-align: left;
        }

        .form-group label {
            display: block;
            color: rgba(255, 255, 255, 0.7);
            margin-bottom: 5px;
            font-size: 14px;
        }

        .form-group input,
        .form-group select {
            width: 100%;
            padding: 8px 12px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            color: white;
            font-size: 14px;
        }

        .form-group select option {
            background: #1a1a2e;
            color: white;
        }

        .settings-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 10px;
        }

        /* Voice Input Settings */
        .voice-input-settings {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid rgba(255, 255, 255, 0.2);
        }

        .voice-input-settings h4 {
            color: #ff006e;
            margin-bottom: 15px;
            font-size: 16px;
        }

        /* AI Chat Interface */
        .ai-chat-interface {
            position: fixed;
            bottom: calc(env(safe-area-inset-bottom, 20px) + 100px);
            right: calc(env(safe-area-inset-right, 20px));
            width: 350px;
            height: 450px;
            background: rgba(20, 20, 40, 0.85);
            border: 2px solid rgba(138, 56, 236, 0.5);
            border-radius: 20px;
            display: none;
            flex-direction: column;
            z-index: 1003;
            box-shadow: 0 0 30px rgba(138, 56, 236, 0.3);
            backdrop-filter: blur(5px);
        }

        .ai-chat-interface.active {
            display: flex;
        }

        /* Special styling for viewer mode chat */
        .ai-chat-interface.viewer-mode {
            border-color: rgba(0, 255, 255, 0.5);
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.3);
        }

        /* Viewers can still interact with chat */
        .ai-chat-interface.viewer-mode .ai-chat-input-container {
            opacity: 1;
            pointer-events: all;
        }

        .ai-chat-header {
            padding: 15px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .ai-chat-title {
            font-weight: bold;
            color: #06ffa5;
        }

        .viewer-chat-label {
            background: rgba(0, 255, 255, 0.2);
            color: #00ffff;
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 12px;
            margin-left: 10px;
        }

        .ai-chat-messages {
            flex: 1;
            padding: 15px;
            overflow-y: auto;
            scroll-behavior: smooth;
        }

        .ai-message {
            margin: 10px 0;
            padding: 10px 15px;
            border-radius: 15px;
            max-width: 80%;
            word-wrap: break-word;
            overflow-wrap: break-word;
            word-break: break-word;
            font-size: 15px;
            line-height: 1.6;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
            transition: all 0.2s ease;
            max-width: 100%;
            overflow-x: auto;
            -webkit-user-select: text;
            user-select: text;
        }

        .ai-message.user {
            background: rgba(131, 56, 236, 0.3);
            margin-left: auto;
            text-align: right;
        }

        .ai-message.ai {
            background: rgba(6, 255, 165, 0.2);
            margin-right: auto;
        }

        /* Presenter label for viewer mode */
        .ai-message.presenter-message::before {
            content: "Presenter";
            display: block;
            font-size: 11px;
            color: #00ffff;
            margin-bottom: 4px;
            opacity: 0.8;
        }

        /* Viewer label for presenter mode */
        .ai-message.viewer-message::before {
            content: attr(data-viewer-name);
            display: block;
            font-size: 11px;
            color: #ff6a00;
            margin-bottom: 4px;
            opacity: 0.8;
        }

        /* Markdown Styles for AI Messages */
        .ai-message.ai h1,
        .ai-message.ai h2,
        .ai-message.ai h3,
        .ai-message.ai h4,
        .ai-message.ai h5,
        .ai-message.ai h6 {
            margin: 0.5em 0 0.3em 0;
            font-weight: 600;
            line-height: 1.3;
            color: #06ffa5;
        }

        .ai-message.ai h1 { font-size: 1.3em; }
        .ai-message.ai h2 { font-size: 1.2em; }
        .ai-message.ai h3 { font-size: 1.1em; }
        .ai-message.ai h4 { font-size: 1.05em; }
        .ai-message.ai h5 { font-size: 1em; }
        .ai-message.ai h6 { font-size: 0.95em; }

        .ai-message.ai p {
            margin: 0.5em 0;
        }

        .ai-message.ai a {
            color: #00ffff;
            text-decoration: underline;
            cursor: pointer;
            transition: color 0.2s ease;
        }

        .ai-message.ai a:hover {
            color: #06ffa5;
            text-decoration: underline;
        }

        .ai-message.ai strong {
            font-weight: 600;
            color: #ffffff;
        }

        .ai-message.ai em {
            font-style: italic;
            color: rgba(255, 255, 255, 0.9);
        }

        .ai-message.ai code {
            background: rgba(0, 0, 0, 0.3);
            padding: 2px 6px;
            border-radius: 4px;
            font-family: 'Monaco', 'Consolas', 'Courier New', monospace;
            font-size: 0.9em;
            color: #06ffa5;
        }

        .ai-message.ai pre {
            background: rgba(0, 0, 0, 0.4);
            padding: 12px;
            border-radius: 8px;
            overflow-x: auto;
            margin: 0.5em 0;
        }

        .ai-message.ai pre code {
            background: none;
            padding: 0;
            color: #ffffff;
        }

        .ai-message.ai blockquote {
            border-left: 4px solid #8338ec;
            padding-left: 12px;
            margin: 0.5em 0;
            color: rgba(255, 255, 255, 0.8);
            font-style: italic;
        }

        .ai-message.ai ul,
        .ai-message.ai ol {
            margin: 0.5em 0;
            padding-left: 1.5em;
        }

        .ai-message.ai li {
            margin: 0.25em 0;
        }

        .ai-message.ai hr {
            border: none;
            border-top: 1px solid rgba(255, 255, 255, 0.2);
            margin: 1em 0;
        }

        .ai-message.ai table {
            border-collapse: collapse;
            width: 100%;
            margin: 0.5em 0;
        }

        .ai-message.ai th,
        .ai-message.ai td {
            border: 1px solid rgba(255, 255, 255, 0.2);
            padding: 8px;
            text-align: left;
        }

        .ai-message.ai th {
            background: rgba(138, 43, 226, 0.2);
            font-weight: 600;
        }

        .ai-message.ai img {
            max-width: 100%;
            height: auto;
            border-radius: 8px;
            margin: 0.5em 0;
        }

        .ai-message.task-replay {
            border: 1px solid rgba(255, 106, 0, 0.5);
            opacity: 0.8;
            font-style: italic;
        }

        .ai-typing {
            margin: 10px 0;
            padding: 10px 15px;
            border-radius: 15px;
            max-width: 80%;
            background: rgba(6, 255, 165, 0.2);
            margin-right: auto;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .typing-dot {
            width: 8px;
            height: 8px;
            background: rgba(255, 255, 255, 0.6);
            border-radius: 50%;
            animation: typingPulse 1.4s infinite ease-in-out;
        }

        .typing-dot:nth-child(1) {
            animation-delay: -0.32s;
        }

        .typing-dot:nth-child(2) {
            animation-delay: -0.16s;
        }

        @keyframes typingPulse {
            0%, 80%, 100% {
                transform: scale(0.8);
                opacity: 0.5;
            }
            40% {
                transform: scale(1);
                opacity: 1;
            }
        }

        .ai-chat-input-container {
            padding: 15px;
            border-top: 1px solid rgba(255, 255, 255, 0.2);
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .ai-chat-input {
            flex: 1;
            padding: 10px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 20px;
            color: white;
            font-size: 14px;
        }

        .ai-chat-send {
            background: linear-gradient(45deg, #8338ec, #3a86ff);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 20px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .ai-chat-send:hover {
            transform: scale(1.05);
        }

        /* Voice Input Button */
        .voice-input-btn {
            background: linear-gradient(45deg, #ff006e, #ff4458);
            color: white;
            border: none;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }

        .voice-input-btn:hover {
            transform: scale(1.1);
        }

        .voice-input-btn.recording {
            background: linear-gradient(45deg, #ff0000, #ff4444);
            animation: recordPulse 1.5s infinite;
        }

        .voice-input-btn.disabled {
            background: linear-gradient(45deg, #666, #888);
            cursor: not-allowed;
            opacity: 0.5;
        }

        .voice-input-btn.disabled:hover {
            transform: scale(1);
        }

        @keyframes recordPulse {
            0% {
                box-shadow: 0 0 0 0 rgba(255, 0, 0, 0.7);
            }
            70% {
                box-shadow: 0 0 0 10px rgba(255, 0, 0, 0);
            }
            100% {
                box-shadow: 0 0 0 0 rgba(255, 0, 0, 0);
            }
        }

        /* Voice Indicator */
        .voice-indicator {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(138, 56, 236, 0.9);
            color: white;
            padding: 10px 20px;
            border-radius: 20px;
            display: none;
            align-items: center;
            gap: 10px;
            z-index: 1004;
            animation: fadeIn 0.3s ease-out;
        }

        .voice-indicator.active {
            display: flex;
        }

        .voice-indicator i {
            animation: pulse 1.5s infinite;
        }

        /* Listening Indicator */
        .listening-indicator {
            position: fixed;
            top: 80px;
            right: 20px;
            background: rgba(255, 0, 110, 0.9);
            color: white;
            padding: 10px 20px;
            border-radius: 20px;
            display: none;
            align-items: center;
            gap: 10px;
            z-index: 1004;
            animation: fadeIn 0.3s ease-out;
        }

        .listening-indicator.active {
            display: flex;
        }

        .listening-indicator svg {
            width: 20px;
            height: 20px;
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }

        /* AI Companion Button */
        .ai-companion-button {
            position: fixed;
            bottom: calc(env(safe-area-inset-bottom, 30px));
            right: calc(env(safe-area-inset-right, 30px));
            width: 60px;
            height: 60px;
            background: rgba(131, 56, 236, 0.3);
            backdrop-filter: blur(10px);
            border: 2px solid rgba(131, 56, 236, 0.5);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            z-index: 1002;
            box-shadow: 0 0 20px rgba(131, 56, 236, 0.3);
        }

        .ai-companion-button:hover {
            background: rgba(131, 56, 236, 0.5);
            transform: scale(1.1);
            box-shadow: 0 0 30px rgba(131, 56, 236, 0.5);
        }

        .ai-companion-button.active {
            background: rgba(6, 255, 165, 0.3);
            border-color: rgba(6, 255, 165, 0.5);
        }

        /* Tasks Button */
        .tasks-button {
            position: fixed;
            bottom: calc(env(safe-area-inset-bottom, 30px) + 80px);
            right: calc(env(safe-area-inset-right, 30px));
            width: 60px;
            height: 60px;
            background: rgba(255, 106, 0, 0.3);
            backdrop-filter: blur(10px);
            border: 2px solid rgba(255, 106, 0, 0.5);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            z-index: 1002;
            box-shadow: 0 0 20px rgba(255, 106, 0, 0.3);
        }

        .tasks-button:hover {
            background: rgba(255, 106, 0, 0.5);
            transform: scale(1.1);
            box-shadow: 0 0 30px rgba(255, 106, 0, 0.5);
        }

        .tasks-button svg {
            width: 28px;
            height: 28px;
            color: white;
        }

        /* Task Panel */
        .task-panel {
            position: fixed;
            bottom: calc(env(safe-area-inset-bottom, 100px));
            left: calc(env(safe-area-inset-left, 20px));
            background: rgba(20, 20, 40, 0.95);
            border: 2px solid rgba(255, 106, 0, 0.5);
            border-radius: 20px;
            padding: 20px;
            z-index: 1002;
            max-width: 350px;
            max-height: 400px;
            overflow-y: auto;
            box-shadow: 0 0 30px rgba(255, 106, 0, 0.3);
            display: none;
        }

        .task-panel.active {
            display: block;
        }

        .task-panel h3 {
            margin: 0 0 15px 0;
            font-size: 20px;
            background: linear-gradient(45deg, #ff6a00, #ff8c00, #ffa500);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .upload-conversation-btn {
            background: linear-gradient(45deg, #742774, #4a90e2);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 15px;
            cursor: pointer;
            font-size: 14px;
            margin: 10px 0;
            width: 100%;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .upload-conversation-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 20px rgba(116, 39, 116, 0.4);
        }

        .conversation-upload-input {
            display: none;
        }

        .task-item {
            background: rgba(255, 255, 255, 0.1);
            padding: 12px;
            margin: 8px 0;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 1px solid transparent;
        }

        .task-item:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 106, 0, 0.5);
            transform: translateX(5px);
        }

        .task-item strong {
            color: #ffa500;
            display: block;
            margin-bottom: 5px;
        }

        .task-item small {
            color: rgba(255, 255, 255, 0.6);
            display: block;
            margin-top: 5px;
        }

        .world-ui {
            position: absolute;
            top: env(safe-area-inset-top, 20px);
            left: env(safe-area-inset-left, 20px);
            z-index: 1001;
            pointer-events: none;
        }

        .world-title {
            font-size: 3em;
            font-weight: 100;
            letter-spacing: 0.2em;
            text-transform: uppercase;
            background: linear-gradient(45deg, #ff006e, #8338ec, #3a86ff, #06ffa5);
            background-size: 400% 100%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: shimmer 8s ease-in-out infinite;
            margin-bottom: 10px;
        }

        .world-description {
            font-size: 1.2em;
            color: rgba(255, 255, 255, 0.6);
            max-width: 400px;
        }

        @keyframes shimmer {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position : 100% 50%; }
        }

        .loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            font-size: 1.2em;
            color: rgba(255, 255, 255, 0.4);
            font-weight: 200;
            letter-spacing: 0.1em;
            z-index: 2000;
        }

        .loading::after {
            content: '';
            display: block;
            width: 60px;
            height: 1px;
            background: linear-gradient(90deg, transparent, #fff, transparent);
            margin: 30px auto;
            animation: scan 2s linear infinite;
        }

        @keyframes scan {
            0% { transform: translateX(-100px); }
            100% { transform: translateX(100px); }
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        @keyframes slideUp {
            from { 
                opacity: 0;
                transform: translateY(20px);
            }
            to { 
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes scaleIn {
            from { 
                opacity: 0;
                transform: scale(0.9);
            }
            to { 
                opacity: 1;
                transform: scale(1);
            }
        }

        @keyframes slideOut {
            from {
                transform: translateX(0);
                opacity: 1;
            }
            to {
                transform: translateX(100%);
                opacity: 0;
            }
        }

        .notification {
            position: fixed;
            top: 100px;
            right: 20px;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 15px 25px;
            border-radius: 10px;
            border: 2px solid rgba(0, 255, 255, 0.5);
            animation: slideIn 0.3s ease;
            z-index: 1005;
            backdrop-filter: blur(10px);
        }

        /* Inactive AI Companion Text */
        .inactive-companion-text {
            position: absolute;
            color: #ff6a00;
            font-size: 1.2em;
            text-align: center;
            width: 300px;
            margin-left: -150px;
            text-shadow: 0 0 10px rgba(255, 106, 0, 0.5);
            animation: floatText 3s ease-in-out infinite;
        }

        @keyframes floatText {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
        }

        @media (max-width: 768px) {
            .world-title {
                font-size: 2em;
            }

            .world-description {
                font-size: 1em;
                max-width: 300px;
            }

            .ai-chat-interface {
                width: calc(100% - 40px);
                right: 20px;
                left: 20px;
                height: 350px;
                bottom: calc(env(safe-area-inset-bottom, 20px) + 20px);
            }

            .voice-pause-button {
                width: 100px;
                height: 45px;
                font-size: 13px;
            }

            .settings-panel {
                width: 95%;
                padding: 20px;
            }

            .settings-tabs {
                flex-wrap: wrap;
            }

            .perspective-controls {
                grid-template-columns: 1fr;
            }
        }

        /* iOS specific fixes */
        @supports (-webkit-touch-callout: none) {
            body {
                position: fixed;
                height: 100vh;
                height: -webkit-fill-available;
            }

            #three-container {
                height: 100vh;
                height: -webkit-fill-available;
            }
        }

        /* Wrist mode notifications */
        .wrist-notification {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 10px 20px;
            border-radius: 20px;
            font-size: 14px;
            z-index: 3100;
            animation: slideDown 0.3s ease;
        }

        @keyframes slideDown {
            from {
                transform: translate(-50%, -100%);
                opacity: 0;
            }
            to {
                transform: translate(-50%, 0);
                opacity: 1;
            }
        }
    </style>
</head>
<body>
    <div id="three-container"></div>

    <!-- Wrist Mode Container -->
    <div class="wrist-mode-container">
        <!-- Orientation Notice for Portrait -->
        <div class="orientation-notice" id="orientation-notice">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <rect x="5" y="2" width="14" height="20" rx="2" ry="2"></rect>
                <line x1="12" y1="18" x2="12" y2="18"></line>
            </svg>
            <h2>Wrist Interface Mode</h2>
            <p>This interface is optimized for landscape orientation</p>
            <button onclick="window.worldNavigator.wristInterface.switchToNormalMode()">Use Normal Mode</button>
        </div>

        <!-- Wrist Interface -->
        <div class="wrist-interface" id="wrist-interface">
            <!-- Mini 3D Container -->
            <div id="mini-three-container" onclick="window.worldNavigator.wristInterface.switchToNormalMode()">
                <div class="mini-orb-label">Tap for 3D World</div>
            </div>

            <!-- Left Panel - Quick Actions -->
            <div class="left-panel">
                <button class="quick-action-btn" id="wrist-clear-btn" title="Clear conversation">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <polyline points="3 6 5 6 21 6"></polyline>
                        <path d="M19 6v14a2 2 0 01-2 2H7a2 2 0 01-2-2V6m3 0V4a2 2 0 012-2h4a2 2 0 012 2v2"></path>
                    </svg>
                </button>
                
                <button class="quick-action-btn" id="wrist-world-btn" title="3D World View">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <circle cx="12" cy="12" r="10"></circle>
                        <line x1="2" y1="12" x2="22" y2="12"></line>
                        <path d="M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1-4-10 15.3 15.3 0 0 1 4-10z"></path>
                    </svg>
                </button>
                
                <button class="quick-action-btn" id="wrist-home-btn" title="Home">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M3 9l9-7 9 7v11a2 2 0 01-2 2H5a2 2 0 01-2-2z"></path>
                        <polyline points="9 22 9 12 15 12 15 22"></polyline>
                    </svg>
                </button>
            </div>

            <!-- Center Panel - Main Display -->
            <div class="center-panel">
                <div class="preset-messages">
                    <div class="preset-msg" data-msg="What's the weather today?">Weather</div>
                    <div class="preset-msg" data-msg="Set a reminder">Reminder</div>
                    <div class="preset-msg" data-msg="Tell me a quick fact">Quick Fact</div>
                    <div class="preset-msg" data-msg="What time is it?">Time</div>
                    <div class="preset-msg" data-msg="Help">Help</div>
                </div>
                
                <div class="ai-display" id="wrist-ai-display">
                    <div class="ai-message ai">Hello! I'm your wrist AI companion. How can I help you today?</div>
                </div>
                
                <div class="wrist-input-container">
                    <input type="text" class="wrist-input" id="wrist-input" placeholder="Type or use voice...">
                    <button class="voice-btn" id="wrist-voice-btn">
                        <svg viewBox="0 0 24 24" width="20" height="20" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"></path>
                            <path d="M19 10v2a7 7 0 0 1-14 0v-2"></path>
                        </svg>
                    </button>
                </div>
            </div>

            <!-- Right Panel - Status & Controls -->
            <div class="right-panel">
                <div class="status-indicator">
                    <div><span class="status-dot"></span>Active</div>
                    <div style="margin-top: 5px; font-size: 11px; opacity: 0.7;">AI Ready</div>
                </div>
                
                <button class="pause-voice-btn" id="wrist-pause-voice-btn">
                    <svg viewBox="0 0 24 24" width="16" height="16" fill="none" stroke="currentColor" stroke-width="2" style="display: block; margin: 0 auto 5px;">
                        <path d="M10 9v6m4-6v6"></path>
                    </svg>
                    Pause Voice
                </button>
                
                <div class="status-indicator" style="background: rgba(138, 43, 226, 0.2);">
                    <div style="font-size: 20px;"></div>
                    <div style="font-size: 11px; margin-top: 5px;">Wrist Mode</div>
                </div>
            </div>
        </div>
    </div>

    <!-- Click to Chat Tooltip -->
    <div class="companion-tooltip" id="companion-tooltip">Click to chat</div>

    <!-- Viewer Mode Indicator -->
    <div class="viewer-mode-indicator" id="viewer-mode-indicator">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path>
            <circle cx="12" cy="12" r="3"></circle>
        </svg>
        <span>Viewing Mode</span>
    </div>

    <!-- Following Indicator -->
    <div class="following-indicator" id="following-indicator">
        <svg viewBox="0 0 24 24" width="16" height="16" fill="none" stroke="currentColor" stroke-width="2">
            <circle cx="12" cy="12" r="10"/>
            <polygon points="10 8 16 12 10 16 10 8"/>
        </svg>
        <span>Following Presenter's View</span>
    </div>

    <!-- Show Mode Status -->
    <div class="show-mode-status" id="show-mode-status">
        <div class="status-indicator" id="status-indicator"></div>
        <span class="status-text" id="status-text">Connecting...</span>
        <div class="viewer-count">
            <span id="viewer-count">1</span> viewers
        </div>
    </div>

    <!-- Voice Pause Button -->
    <div class="voice-pause-button" id="voice-pause-button">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M10 9v6m4-6v6m7-3a9 9 0 11-18 0 9 9 0 0118 0z"></path>
        </svg>
        <span id="voice-pause-text">Pause Voice</span>
    </div>

    <!-- Voice Paused Indicator -->
    <div class="voice-paused-indicator" id="voice-paused-indicator">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M10 9v6m4-6v6"></path>
        </svg>
        <span>Voice Paused</span>
    </div>

    <!-- Show Mode Button -->
    <div class="show-mode-button" id="show-mode-button">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path>
            <circle cx="12" cy="12" r="3"></circle>
        </svg>
    </div>

    <!-- Show Mode Modal -->
    <div class="show-mode-modal" id="show-mode-modal">
        <div class="show-mode-modal-content">
            <button class="modal-close" id="show-mode-close">&times;</button>
            <h3>Show Mode</h3>
            <p style="color: rgba(255, 255, 255, 0.7); margin-bottom: 20px;">
                Share your perspective in real-time. Others can scan the QR code to follow your view.
            </p>
            <div class="show-mode-info" id="show-mode-info">
                 Show Mode Active - Viewers will see what you see in real-time!
            </div>
            <div id="qr-code-container"></div>
            <p class="qr-url" id="qr-url"></p>
            <button class="copy-url-btn" id="copy-url-btn">Copy URL</button>
        </div>
    </div>

    <!-- Settings Panel -->
    <div class="settings-panel" id="settings-panel">
        <button class="close-settings" id="close-settings">&times;</button>
        <h2>AI Companion Settings</h2>
        
        <div class="settings-tabs">
            <button class="settings-tab active" data-tab="general">General</button>
            <button class="settings-tab" data-tab="voice">Voice</button>
            <button class="settings-tab" data-tab="perspective">3D View</button>
            <button class="settings-tab" data-tab="import-export">Import/Export</button>
        </div>

        <!-- General Settings -->
        <div class="settings-section active" id="general-settings">
            <div class="settings-group">
                <h3>API Configuration</h3>
                <div class="setting-item">
                    <label for="settings-api-key">API Key</label>
                    <input type="password" id="settings-api-key" placeholder="Enter your API key">
                </div>
                <div class="setting-item">
                    <label for="settings-endpoint">API Endpoint</label>
                    <input type="text" id="settings-endpoint" value="http://localhost:7071/api/businessinsightbot_function">
                </div>
            </div>

            <div class="settings-group">
                <h3>World Settings</h3>
                <div class="setting-item">
                    <label for="world-name">World Name</label>
                    <input type="text" id="world-name" value="AI Companion Hub">
                </div>
                <div class="setting-item">
                    <label for="world-description">World Description</label>
                    <input type="text" id="world-description" value="Your intelligent assistant awaits. Click on the AI companion to start chatting!">
                </div>
            </div>
        </div>

        <!-- Voice Settings -->
        <div class="settings-section" id="voice-settings">
            <div class="settings-group">
                <h3>Voice Output</h3>
                <div class="toggle-setting">
                    <label>Enable Voice Response</label>
                    <div class="toggle-switch" id="settings-voice-enabled"></div>
                </div>
                <div class="toggle-setting">
                    <label>Auto-speak Responses</label>
                    <div class="toggle-switch" id="settings-auto-speak"></div>
                </div>
                <div class="setting-item">
                    <label for="settings-azure-tts-key">Azure TTS API Key</label>
                    <input type="password" id="settings-azure-tts-key" placeholder="Enter Azure TTS key for premium voices">
                </div>
                <div class="setting-item">
                    <label for="settings-tts-voice">TTS Voice</label>
                    <select id="settings-tts-voice">
                        <option value="en-US-JennyNeural">Jenny (Female)</option>
                        <option value="en-US-GuyNeural">Guy (Male)</option>
                        <option value="en-US-AriaNeural">Aria (Female)</option>
                        <option value="en-US-DavisNeural">Davis (Male)</option>
                        <option value="en-US-AmberNeural">Amber (Female)</option>
                        <option value="en-US-JasonNeural">Jason (Male)</option>
                        <option value="en-GB-SoniaNeural">Sonia (British Female)</option>
                        <option value="en-GB-RyanNeural">Ryan (British Male)</option>
                    </select>
                </div>
            </div>

            <div class="settings-group">
                <h3>Voice Input</h3>
                <div class="toggle-setting">
                    <label>Enable Voice Input</label>
                    <div class="toggle-switch active" id="settings-voice-input-enabled"></div>
                </div>
                <div class="toggle-setting">
                    <label>Continuous Conversation Mode</label>
                    <div class="toggle-switch" id="settings-continuous-conversation"></div>
                </div>
                <div class="setting-item">
                    <label for="settings-push-to-talk">Push-to-Talk Key</label>
                    <select id="settings-push-to-talk">
                        <option value="Space">Space</option>
                        <option value="v">V</option>
                        <option value="t">T</option>
                        <option value="Control">Ctrl</option>
                        <option value="Alt">Alt</option>
                    </select>
                </div>
            </div>
        </div>

        <!-- Perspective Settings -->
        <div class="settings-section" id="perspective-settings">
            <div class="settings-group">
                <h3>Camera Controls</h3>
                <div class="perspective-controls">
                    <div class="setting-item">
                        <label>Position X <span class="range-value" id="pos-x-value">0</span></label>
                        <input type="range" id="camera-pos-x" min="-50" max="50" value="0" step="0.5">
                    </div>
                    <div class="setting-item">
                        <label>Position Y <span class="range-value" id="pos-y-value">5</span></label>
                        <input type="range" id="camera-pos-y" min="-20" max="50" value="5" step="0.5">
                    </div>
                    <div class="setting-item">
                        <label>Position Z <span class="range-value" id="pos-z-value">8</span></label>
                        <input type="range" id="camera-pos-z" min="-50" max="50" value="8" step="0.5">
                    </div>
                    <div class="setting-item">
                        <label>Rotation X <span class="range-value" id="rot-x-value">0</span></label>
                        <input type="range" id="camera-rot-x" min="-180" max="180" value="0" step="1">
                    </div>
                    <div class="setting-item">
                        <label>Rotation Y <span class="range-value" id="rot-y-value">0</span></label>
                        <input type="range" id="camera-rot-y" min="-180" max="180" value="0" step="1">
                    </div>
                    <div class="setting-item">
                        <label>FOV <span class="range-value" id="fov-value">75</span></label>
                        <input type="range" id="camera-fov" min="30" max="120" value="75" step="1">
                    </div>
                </div>
                
                <h4 style="margin-top: 20px; margin-bottom: 10px; color: #8a2be2;">Presets</h4>
                <div class="perspective-preset">
                    <button class="preset-btn" onclick="window.worldNavigator.perspectiveManager.applyPreset('default')">Default</button>
                    <button class="preset-btn" onclick="window.worldNavigator.perspectiveManager.applyPreset('overhead')">Overhead</button>
                    <button class="preset-btn" onclick="window.worldNavigator.perspectiveManager.applyPreset('close')">Close-up</button>
                    <button class="preset-btn" onclick="window.worldNavigator.perspectiveManager.applyPreset('side')">Side View</button>
                    <button class="preset-btn" onclick="window.worldNavigator.perspectiveManager.applyPreset('wide')">Wide Angle</button>
                    <button class="preset-btn" onclick="window.worldNavigator.perspectiveManager.applyPreset('dramatic')">Dramatic</button>
                </div>
            </div>

            <div class="settings-group">
                <h3>Visual Settings</h3>
                <div class="setting-item">
                    <label>Fog Density <span class="range-value" id="fog-density-value">50</span></label>
                    <input type="range" id="fog-density" min="10" max="200" value="50" step="5">
                </div>
                <div class="setting-item">
                    <label>Particle Count <span class="range-value" id="particle-count-value">300</span></label>
                    <input type="range" id="particle-count" min="0" max="1000" value="300" step="50">
                </div>
            </div>
        </div>

        <!-- Import/Export Settings -->
        <div class="settings-section" id="import-export-settings">
            <div class="import-export-section">
                <h4>Export Settings</h4>
                <p style="color: rgba(255, 255, 255, 0.6); margin-bottom: 15px; font-size: 14px;">
                    Export all your settings including API keys, voice configuration, and 3D perspective as a JSON file.
                </p>
                <div class="json-preview" id="json-preview"></div>
                <button class="settings-btn" onclick="window.worldNavigator.settingsManager.exportSettings()">
                    Export Settings to JSON
                </button>
            </div>

            <div class="import-export-section" style="margin-top: 30px;">
                <h4>Import Settings</h4>
                <p style="color: rgba(255, 255, 255, 0.6); margin-bottom: 15px; font-size: 14px;">
                    Import a previously exported settings file to restore your configuration.
                </p>
                <div class="file-input-wrapper">
                    <input type="file" id="import-settings-file" accept=".json" onchange="window.worldNavigator.settingsManager.importSettings(event)">
                    <label for="import-settings-file" class="file-input-label">
                        Click to select settings file or drag and drop here
                    </label>
                </div>
            </div>

            <div class="import-export-section" style="margin-top: 30px;">
                <h4>Danger Zone</h4>
                <p style="color: rgba(255, 165, 0, 0.8); margin-bottom: 15px; font-size: 14px;">
                     This action will reset all settings to their default values. This cannot be undone.
                </p>
                <button class="settings-btn danger" onclick="window.worldNavigator.settingsManager.resetSettings()">
                    Reset All Settings
                </button>
            </div>
        </div>

        <div class="settings-actions">
            <button class="settings-btn" onclick="window.worldNavigator.settingsManager.saveSettings()">Save Changes</button>
            <button class="settings-btn secondary" onclick="document.getElementById('settings-panel').classList.remove('active')">Cancel</button>
        </div>
    </div>

    <!-- AI Companion Modal -->
    <div class="ai-modal" id="ai-modal">
        <div class="ai-modal-content">
            <button class="ai-modal-close" id="ai-close">&times;</button>
            <h3>AI Companion Settings</h3>
            <p style="color: rgba(255, 255, 255, 0.7); margin-bottom: 20px;">
                Activate your AI companion to begin the collaborative experience.
            </p>
            <input type="password" class="ai-api-key-input" id="ai-api-key" placeholder="Enter your API key to activate AI companion">
            <button class="ai-activate-btn" id="ai-activate-btn">Activate AI Companion</button>
            
            <!-- Voice Settings Section -->
            <div class="voice-settings">
                <h4>Voice Output Settings</h4>
                
                <div class="settings-item">
                    <label for="voice-enabled-toggle">Enable Voice Response</label>
                    <div class="toggle-switch" id="voice-enabled-toggle"></div>
                </div>
                
                <div class="settings-item">
                    <label for="auto-speak-toggle">Auto-speak Responses</label>
                    <div class="toggle-switch" id="auto-speak-toggle"></div>
                </div>
                
                <div class="form-group">
                    <label for="azure-tts-key">Azure TTS API Key (Optional)</label>
                    <input type="password" id="azure-tts-key" placeholder="Enter Azure TTS key for premium voices">
                </div>
                
                <div class="form-group">
                    <label for="tts-voice-select">TTS Voice</label>
                    <select id="tts-voice-select">
                        <option value="en-US-JennyNeural">Jenny (Female)</option>
                        <option value="en-US-GuyNeural">Guy (Male)</option>
                        <option value="en-US-AriaNeural">Aria (Female)</option>
                        <option value="en-US-DavisNeural">Davis (Male)</option>
                        <option value="en-US-AmberNeural">Amber (Female)</option>
                        <option value="en-US-JasonNeural">Jason (Male)</option>
                        <option value="en-GB-SoniaNeural">Sonia (British Female)</option>
                        <option value="en-GB-RyanNeural">Ryan (British Male)</option>
                    </select>
                </div>
            </div>

            <!-- Voice Input Settings Section -->
            <div class="voice-input-settings">
                <h4>Voice Input Settings</h4>
                
                <div class="settings-item">
                    <label for="voice-input-enabled-toggle">Enable Voice Input</label>
                    <div class="toggle-switch active" id="voice-input-enabled-toggle"></div>
                </div>
                
                <div class="settings-item">
                    <label for="continuous-conversation-toggle">Continuous Conversation Mode</label>
                    <div class="toggle-switch" id="continuous-conversation-toggle"></div>
                </div>

                <div class="form-group">
                    <label for="voice-activation-key">Push-to-Talk Key (Desktop)</label>
                    <select id="voice-activation-key">
                        <option value="Space">Space</option>
                        <option value="v">V</option>
                        <option value="t">T</option>
                        <option value="Control">Ctrl</option>
                        <option value="Alt">Alt</option>
                    </select>
                </div>
            </div>
        </div>
    </div>

    <!-- Voice Indicator -->
    <div class="voice-indicator" id="voice-indicator">
        <i class="fas fa-volume-up"></i>
        <span>Speaking...</span>
    </div>

    <!-- Listening Indicator -->
    <div class="listening-indicator" id="listening-indicator">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"></path>
            <path d="M19 10v2a7 7 0 0 1-14 0v-2"></path>
            <line x1="12" y1="19" x2="12" y2="23"></line>
            <line x1="8" y1="23" x2="16" y2="23"></line>
        </svg>
        <span>Listening...</span>
    </div>

    <!-- AI Chat Interface -->
    <div class="ai-chat-interface" id="ai-chat-interface">
        <div class="ai-chat-header">
            <div class="ai-chat-title">
                AI Companion Chat
                <span class="viewer-chat-label" id="viewer-chat-label" style="display: none;">Viewer Mode</span>
            </div>
            <button class="ai-modal-close" onclick="document.getElementById('ai-chat-interface').classList.remove('active')">&times;</button>
        </div>
        <div class="ai-chat-messages" id="ai-chat-messages"></div>
        <div class="ai-chat-input-container">
            <input type="text" class="ai-chat-input" id="ai-chat-input" placeholder="Type a message..." onkeypress="if(event.key==='Enter') window.worldNavigator.aiManager.sendMessage()">
            <button class="voice-input-btn" id="voice-input-btn" title="Hold to speak">
                <svg viewBox="0 0 24 24" width="20" height="20" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"></path>
                    <path d="M19 10v2a7 7 0 0 1-14 0v-2"></path>
                    <line x1="12" y1="19" x2="12" y2="23"></line>
                    <line x1="8" y1="23" x2="16" y2="23"></line>
                </svg>
            </button>
            <button class="ai-chat-send" onclick="window.worldNavigator.aiManager.sendMessage()">Send</button>
        </div>
    </div>

    <!-- Task Panel -->
    <div class="task-panel" id="task-panel">
        <h3> Saved Conversations</h3>
        <button class="upload-conversation-btn" onclick="document.getElementById('conversation-upload-input').click()">
            <svg viewBox="0 0 24 24" width="16" height="16" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M21 15v4a2 2 0 01-2 2H5a2 2 0 01-2-2v-4"></path>
                <polyline points="17 8 12 3 7 8"></polyline>
                <line x1="12" y1="3" x2="12" y2="15"></line>
            </svg>
            Upload Conversation JSON
        </button>
        <input type="file" id="conversation-upload-input" class="conversation-upload-input" accept=".json" onchange="window.worldNavigator.taskManager.uploadConversation(event)">
        <div id="task-list">
            <!-- Tasks populated here -->
        </div>
    </div>

    <div class="world-ui">
        <h1 class="world-title" id="world-title">AI COMPANION HUB</h1>
        <p class="world-description" id="world-description">Your intelligent assistant awaits. Click on the AI companion to start chatting!</p>
    </div>

    <!-- AI Companion Button -->
    <div class="ai-companion-button" id="ai-companion-button">
        <svg class="view-toggle-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"></path>
        </svg>
    </div>

    <!-- Tasks Button -->
    <div class="tasks-button" id="tasks-button">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M9 11l3 3L22 4"></path>
            <path d="M21 12v7a2 2 0 01-2 2H5a2 2 0 01-2-2V5a2 2 0 012-2h11"></path>
        </svg>
    </div>

    <!-- Settings Button -->
    <div class="settings-button" id="settings-button">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <circle cx="12" cy="12" r="3"></circle>
            <path d="M12 1v6m0 6v6m4.22-10.22l1.42-1.42m-1.42 8.49l1.42 1.42M20 12h-6m-6 0H1m4.22 4.22l-1.42 1.42m1.42-8.49L3.8 7.73"></path>
        </svg>
    </div>

    <div class="loading" id="loading">Initializing AI Companion...</div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <script src="https://kit.fontawesome.com/your-fontawesome-kit.js" crossorigin="anonymous"></script>
    <script>
        // Configuration
        const WORLD_ATTRIBUTES = {
            name: "AI Companion Hub",
            description: "Your intelligent assistant awaits. Click on the AI companion to start chatting!",
            ambientColor: 0x1a1a2e,
            fogColor: 0x0a0a0f,
            groundColor: 0x16213e,
            skyColor: 0x0f3460,
            particleCount: 300,
            fogNear: 5,
            fogFar: 50,
            companionDistance: 5,
            cameraPositionY: 5,
            cameraPositionZ: 8
        };

        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || 
                        (window.matchMedia && window.matchMedia('(max-width: 768px)').matches) ||
                        (window.matchMedia && window.matchMedia('(pointer: coarse)').matches);

        const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;

        // Markdown Parser Class
        class MarkdownParser {
            constructor() {
                this.rules = {
                    // Headers
                    h1: /^# (.+)$/gm,
                    h2: /^## (.+)$/gm,
                    h3: /^### (.+)$/gm,
                    h4: /^#### (.+)$/gm,
                    h5: /^##### (.+)$/gm,
                    h6: /^###### (.+)$/gm,
                    
                    // Bold and italic
                    boldItalic: /\*\*\*(.+?)\*\*\*/g,
                    bold: /\*\*(.+?)\*\*/g,
                    italic: /\*(.+?)\*/g,
                    
                    // Links
                    link: /\[([^\]]+)\]\(([^)]+)\)/g,
                    
                    // Images
                    image: /!\[([^\]]*)\]\(([^)]+)\)/g,
                    
                    // Code
                    codeBlock: /```([\s\S]*?)```/g,
                    inlineCode: /`([^`]+)`/g,
                    
                    // Blockquote
                    blockquote: /^> (.+)$/gm,
                    
                    // Lists
                    unorderedList: /^[*\-+] (.+)$/gm,
                    orderedList: /^\d+\. (.+)$/gm,
                    
                    // Horizontal rule
                    hr: /^(---|\*\*\*|___)$/gm,
                    
                    // Line breaks
                    lineBreak: /  $/gm,
                    
                    // Tables (simplified)
                    table: /\|(.+)\|/g
                };
            }

            parse(text) {
                if (!text) return '';
                
                // Escape HTML
                text = this.escapeHtml(text);
                
                // Process block elements first
                text = this.processBlockElements(text);
                
                // Process inline elements
                text = this.processInlineElements(text);
                
                // Convert line breaks
                text = text.replace(/\n/g, '<br>');
                
                return text;
            }

            escapeHtml(text) {
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            }

            processBlockElements(text) {
                // Code blocks (process first to avoid other parsing inside)
                text = text.replace(this.rules.codeBlock, '<pre><code>$1</code></pre>');
                
                // Headers
                text = text.replace(this.rules.h6, '<h6>$1</h6>');
                text = text.replace(this.rules.h5, '<h5>$1</h5>');
                text = text.replace(this.rules.h4, '<h4>$1</h4>');
                text = text.replace(this.rules.h3, '<h3>$1</h3>');
                text = text.replace(this.rules.h2, '<h2>$1</h2>');
                text = text.replace(this.rules.h1, '<h1>$1</h1>');
                
                // Blockquotes
                text = text.replace(this.rules.blockquote, '<blockquote>$1</blockquote>');
                
                // Horizontal rules
                text = text.replace(this.rules.hr, '<hr>');
                
                // Lists
                text = this.processList(text);
                
                return text;
            }

            processInlineElements(text) {
                // Bold italic (process before individual bold/italic)
                text = text.replace(this.rules.boldItalic, '<strong><em>$1</em></strong>');
                
                // Bold
                text = text.replace(this.rules.bold, '<strong>$1</strong>');
                
                // Italic
                text = text.replace(this.rules.italic, '<em>$1</em>');
                
                // Links
                text = text.replace(this.rules.link, '<a href="../../$2" target="_blank" rel="noopener noreferrer">$1</a>');
                
                // Images
                text = text.replace(this.rules.image, '<img src="../../$2" alt="$1">');
                
                // Inline code
                text = text.replace(this.rules.inlineCode, '<code>$1</code>');
                
                // Line breaks
                text = text.replace(this.rules.lineBreak, '<br>');
                
                return text;
            }

            processList(text) {
                const lines = text.split('\n');
                let inUl = false;
                let inOl = false;
                let result = [];
                
                for (let line of lines) {
                    if (line.match(/^[*\-+] /)) {
                        if (!inUl) {
                            result.push('<ul>');
                            inUl = true;
                        }
                        if (inOl) {
                            result.push('</ol>');
                            inOl = false;
                        }
                        result.push('<li>' + line.replace(/^[*\-+] /, '') + '</li>');
                    } else if (line.match(/^\d+\. /)) {
                        if (!inOl) {
                            result.push('<ol>');
                            inOl = true;
                        }
                        if (inUl) {
                            result.push('</ul>');
                            inUl = false;
                        }
                        result.push('<li>' + line.replace(/^\d+\. /, '') + '</li>');
                    } else {
                        if (inUl) {
                            result.push('</ul>');
                            inUl = false;
                        }
                        if (inOl) {
                            result.push('</ol>');
                            inOl = false;
                        }
                        result.push(line);
                    }
                }
                
                if (inUl) result.push('</ul>');
                if (inOl) result.push('</ol>');
                
                return result.join('\n');
            }
        }

        // Wrist Interface Manager
        class WristInterface {
            constructor(worldInstance) {
                this.world = worldInstance;
                this.apiKey = localStorage.getItem('wrist_ai_api_key') || '';
                this.endpoint = 'http://localhost:7071/api/businessinsightbot_function';
                this.conversationHistory = [];
                this.isListening = false;
                this.recognition = null;
                this.synthesis = window.speechSynthesis;
                this.voicePaused = false;
                this.miniScene = null;
                this.miniCamera = null;
                this.miniRenderer = null;
                this.miniCompanion = null;
                
                this.setupEventListeners();
                this.initializeSpeechRecognition();
                this.initializeMini3D();
                this.syncWithMainAI();
            }

            initializeMini3D() {
                const container = document.getElementById('mini-three-container');
                
                // Create mini scene
                this.miniScene = new THREE.Scene();
                this.miniCamera = new THREE.PerspectiveCamera(50, 120 / 120, 0.1, 1000);
                this.miniCamera.position.z = 5;

                this.miniRenderer = new THREE.WebGLRenderer({ 
                    antialias: true, 
                    alpha: true 
                });
                this.miniRenderer.setSize(120, 120);
                this.miniRenderer.setPixelRatio(window.devicePixelRatio);
                container.appendChild(this.miniRenderer.domElement);

                // Create mini companion
                const geometry = new THREE.SphereGeometry(1, 32, 32);
                const material = new THREE.MeshPhongMaterial({
                    color: this.world.aiManager.isActive ? 0x06ffa5 : 0x666666,
                    emissive: this.world.aiManager.isActive ? 0x06ffa5 : 0x666666,
                    emissiveIntensity: 0.5,
                    shininess: 100
                });
                
                this.miniCompanion = new THREE.Mesh(geometry, material);
                this.miniScene.add(this.miniCompanion);

                // Add particles
                const particleGeometry = new THREE.BufferGeometry();
                const particleCount = 50;
                const positions = new Float32Array(particleCount * 3);

                for (let i = 0; i < particleCount * 3; i += 3) {
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.random() * Math.PI;
                    const radius = 2 + Math.random() * 0.5;

                    positions[i] = radius * Math.sin(phi) * Math.cos(theta);
                    positions[i + 1] = radius * Math.sin(phi) * Math.sin(theta);
                    positions[i + 2] = radius * Math.cos(phi);
                }

                particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

                const particleMaterial = new THREE.PointsMaterial({
                    color: this.world.aiManager.isActive ? 0x8338ec : 0x444444,
                    size: 0.05,
                    transparent: true,
                    opacity: 0.6
                });

                this.particles = new THREE.Points(particleGeometry, particleMaterial);
                this.miniScene.add(this.particles);

                // Add lights
                const light = new THREE.PointLight(0xffffff, 1, 100);
                light.position.set(10, 10, 10);
                this.miniScene.add(light);

                const ambientLight = new THREE.AmbientLight(0x404040);
                this.miniScene.add(ambientLight);

                // Animation
                this.animateMini3D();
            }

            animateMini3D() {
                const animate = () => {
                    requestAnimationFrame(animate);
                    
                    if (this.miniCompanion) {
                        this.miniCompanion.rotation.x += 0.01;
                        this.miniCompanion.rotation.y += 0.01;
                        
                        const scale = 1 + Math.sin(Date.now() * 0.001) * 0.1;
                        this.miniCompanion.scale.setScalar(scale);
                    }
                    
                    if (this.particles) {
                        this.particles.rotation.y += 0.002;
                    }
                    
                    if (this.miniRenderer) {
                        this.miniRenderer.render(this.miniScene, this.miniCamera);
                    }
                };
                animate();
            }

            syncWithMainAI() {
                // Sync with main AI manager
                if (this.world.aiManager) {
                    this.apiKey = this.world.aiManager.apiKey;
                    this.conversationHistory = [...this.world.aiManager.conversationHistory];
                    
                    // Update mini companion color based on AI status
                    if (this.miniCompanion) {
                        const isActive = this.world.aiManager.isActive;
                        this.miniCompanion.material.color.setHex(isActive ? 0x06ffa5 : 0x666666);
                        this.miniCompanion.material.emissive.setHex(isActive ? 0x06ffa5 : 0x666666);
                    }
                }
            }

            initializeSpeechRecognition() {
                const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
                
                if (!SpeechRecognition) {
                    this.showNotification('Speech recognition not supported');
                    return;
                }

                this.recognition = new SpeechRecognition();
                this.recognition.continuous = false;
                this.recognition.interimResults = true;
                this.recognition.lang = 'en-US';

                this.recognition.onstart = () => {
                    this.isListening = true;
                    document.getElementById('wrist-voice-btn').classList.add('recording');
                };

                this.recognition.onend = () => {
                    this.isListening = false;
                    document.getElementById('wrist-voice-btn').classList.remove('recording');
                };

                this.recognition.onresult = (event) => {
                    let finalTranscript = '';
                    
                    for (let i = event.resultIndex; i < event.results.length; i++) {
                        const transcript = event.results[i][0].transcript;
                        if (event.results[i].isFinal) {
                            finalTranscript += transcript;
                        }
                    }

                    if (finalTranscript) {
                        document.getElementById('wrist-input').value = finalTranscript;
                        this.sendMessage();
                    }
                };

                this.recognition.onerror = (event) => {
                    this.isListening = false;
                    document.getElementById('wrist-voice-btn').classList.remove('recording');
                    
                    if (event.error !== 'no-speech' && event.error !== 'aborted') {
                        this.showNotification(`Speech error: ${event.error}`);
                    }
                };
            }

            setupEventListeners() {
                // Check orientation on load and changes
                this.checkOrientation();
                window.addEventListener('orientationchange', () => this.checkOrientation());
                window.addEventListener('resize', () => this.checkOrientation());

                // Voice button
                const voiceBtn = document.getElementById('wrist-voice-btn');
                if (voiceBtn) {
                    voiceBtn.addEventListener('touchstart', (e) => {
                        e.preventDefault();
                        this.startListening();
                    });

                    voiceBtn.addEventListener('touchend', (e) => {
                        e.preventDefault();
                        this.stopListening();
                    });
                }

                // Text input
                const wristInput = document.getElementById('wrist-input');
                if (wristInput) {
                    wristInput.addEventListener('keypress', (e) => {
                        if (e.key === 'Enter') {
                            this.sendMessage();
                        }
                    });
                }

                // Preset messages
                document.querySelectorAll('.preset-msg').forEach(btn => {
                    btn.addEventListener('click', () => {
                        document.getElementById('wrist-input').value = btn.dataset.msg;
                        this.sendMessage();
                    });
                });

                // Quick actions
                const clearBtn = document.getElementById('wrist-clear-btn');
                if (clearBtn) {
                    clearBtn.addEventListener('click', () => this.clearConversation());
                }

                const worldBtn = document.getElementById('wrist-world-btn');
                if (worldBtn) {
                    worldBtn.addEventListener('click', () => this.switchToNormalMode());
                }

                const homeBtn = document.getElementById('wrist-home-btn');
                if (homeBtn) {
                    homeBtn.addEventListener('click', () => window.location.reload());
                }

                // Pause voice button
                const pauseBtn = document.getElementById('wrist-pause-voice-btn');
                if (pauseBtn) {
                    pauseBtn.addEventListener('click', () => this.toggleVoicePause());
                }
            }

            checkOrientation() {
                const isLandscape = window.matchMedia('(orientation: landscape)').matches;
                const isMobileDevice = window.matchMedia('(max-width: 768px)').matches;
                
                if (isMobileDevice && !isLandscape) {
                    document.getElementById('orientation-notice').style.display = 'flex';
                    document.getElementById('wrist-interface').style.display = 'none';
                } else if (isMobileDevice && isLandscape) {
                    document.getElementById('orientation-notice').style.display = 'none';
                    document.getElementById('wrist-interface').style.display = 'grid';
                }
            }

            switchToNormalMode() {
                document.querySelector('.wrist-mode-container').style.display = 'none';
                // Re-enable normal mode elements
                document.getElementById('three-container').style.display = 'block';
                document.querySelector('.world-ui').style.display = 'block';
                document.getElementById('ai-companion-button').style.display = 'flex';
                document.getElementById('tasks-button').style.display = 'flex';
                document.getElementById('settings-button').style.display = 'flex';
                document.getElementById('show-mode-button').style.display = 'flex';
                
                this.showNotification('Switched to normal mode');
            }

            startListening() {
                if (!this.recognition || this.isListening || this.voicePaused) return;
                
                try {
                    this.recognition.start();
                } catch (error) {
                    console.error('Error starting speech recognition:', error);
                }
            }

            stopListening() {
                if (!this.recognition || !this.isListening) return;
                
                try {
                    this.recognition.stop();
                } catch (error) {
                    console.error('Error stopping speech recognition:', error);
                }
            }

            async sendMessage() {
                const input = document.getElementById('wrist-input');
                const message = input.value.trim();
                
                if (!message) return;
                
                // Add user message
                this.addMessage(message, 'user');
                input.value = '';
                
                // Show typing indicator
                this.showTypingIndicator();
                
                // Add to conversation history
                this.conversationHistory.push({
                    role: 'user',
                    content: message
                });
                
                // Sync with main AI if available
                if (this.world.aiManager && this.world.aiManager.isActive) {
                    this.world.aiManager.conversationHistory.push({
                        role: 'user',
                        content: message
                    });
                    
                    try {
                        const response = await this.world.aiManager.sendToAPI(message);
                        this.hideTypingIndicator();
                        
                        if (response.assistant_response) {
                            this.addMessage(response.assistant_response, 'ai');
                            
                            this.conversationHistory.push({
                                role: 'assistant',
                                content: response.assistant_response
                            });
                            
                            this.world.aiManager.conversationHistory.push({
                                role: 'assistant',
                                content: response.assistant_response
                            });
                            
                            if (response.voice_response && !this.voicePaused) {
                                this.speak(response.voice_response);
                            }
                            
                            this.animateCompanionResponse();
                        }
                    } catch (error) {
                        console.error('Error:', error);
                        this.hideTypingIndicator();
                        this.addMessage('Sorry, I encountered an error. Please try again.', 'ai');
                    }
                } else {
                    // Fallback demo response
                    await this.simulateAIResponse(message);
                }
            }

            async simulateAIResponse(message) {
                // Simulate API delay
                await new Promise(resolve => setTimeout(resolve, 1500));
                
                this.hideTypingIndicator();
                
                // Simple demo responses
                let response = '';
                if (message.toLowerCase().includes('weather')) {
                    response = "It's currently 72F and sunny. Perfect weather for outdoor activities!";
                } else if (message.toLowerCase().includes('time')) {
                    const now = new Date();
                    response = `The current time is ${now.toLocaleTimeString()}.`;
                } else if (message.toLowerCase().includes('reminder')) {
                    response = "I'll help you set a reminder. What would you like to be reminded about?";
                } else if (message.toLowerCase().includes('fact')) {
                    const facts = [
                        "Did you know? The heart of a shrimp is located in its head!",
                        "Fun fact: A group of flamingos is called a 'flamboyance'!",
                        "Interesting: Honey never spoils. Archaeologists have found 3000-year-old honey that's still edible!"
                    ];
                    response = facts[Math.floor(Math.random() * facts.length)];
                } else if (message.toLowerCase().includes('help')) {
                    response = "I can help you with weather updates, setting reminders, telling time, sharing facts, and answering questions. Just ask!";
                } else {
                    response = `I understand you said: "${message}". How can I assist you with this?`;
                }
                
                this.addMessage(response, 'ai');
                
                // Speak response if voice not paused
                if (!this.voicePaused) {
                    this.speak(response);
                }
                
                // Add to conversation history
                this.conversationHistory.push({
                    role: 'assistant',
                    content: response
                });
                
                // Animate companion
                this.animateCompanionResponse();
            }

            addMessage(text, sender) {
                const display = document.getElementById('wrist-ai-display');
                const messageDiv = document.createElement('div');
                messageDiv.className = `ai-message ${sender}`;
                
                if (sender === 'ai' && this.world.aiManager) {
                    // Use markdown parser for AI messages
                    const parser = new MarkdownParser();
                    messageDiv.innerHTML = parser.parse(text);
                } else {
                    messageDiv.textContent = text;
                }
                
                display.appendChild(messageDiv);
                display.scrollTop = display.scrollHeight;
                
                // Also add to main chat if active
                if (this.world.aiManager && this.world.aiManager.isActive) {
                    this.world.aiManager.addMessage(text, sender);
                }
            }

            showTypingIndicator() {
                const display = document.getElementById('wrist-ai-display');
                const typingDiv = document.createElement('div');
                typingDiv.className = 'ai-typing';
                typingDiv.id = 'wrist-typing-indicator';
                typingDiv.innerHTML = `
                    <div class="typing-dot"></div>
                    <div class="typing-dot"></div>
                    <div class="typing-dot"></div>
                `;
                display.appendChild(typingDiv);
                display.scrollTop = display.scrollHeight;
            }

            hideTypingIndicator() {
                const indicator = document.getElementById('wrist-typing-indicator');
                if (indicator) {
                    indicator.remove();
                }
            }

            speak(text) {
                if (this.voicePaused) return;
                
                const utterance = new SpeechSynthesisUtterance(text);
                utterance.rate = 1.0;
                utterance.pitch = 1.0;
                utterance.volume = 1.0;
                
                this.synthesis.speak(utterance);
            }

            animateCompanionResponse() {
                if (!this.miniCompanion) return;
                
                let scale = 1;
                const animate = () => {
                    scale = Math.min(scale + 0.05, 1.5);
                    this.miniCompanion.scale.setScalar(scale);
                    
                    // Update material emissive intensity
                    this.miniCompanion.material.emissiveIntensity = 0.5 + (scale - 1) * 0.5;
                    
                    if (scale < 1.5) {
                        requestAnimationFrame(animate);
                    } else {
                        // Scale back down
                        const scaleDown = () => {
                            scale = Math.max(scale - 0.05, 1);
                            this.miniCompanion.scale.setScalar(scale);
                            this.miniCompanion.material.emissiveIntensity = 0.5 + (scale - 1) * 0.5;
                            
                            if (scale > 1) {
                                requestAnimationFrame(scaleDown);
                            }
                        };
                        scaleDown();
                    }
                };
                animate();
            }

            toggleVoicePause() {
                this.voicePaused = !this.voicePaused;
                const btn = document.getElementById('wrist-pause-voice-btn');
                
                if (this.voicePaused) {
                    btn.classList.add('paused');
                    btn.innerHTML = `
                        <svg viewBox="0 0 24 24" width="16" height="16" fill="none" stroke="currentColor" stroke-width="2" style="display: block; margin: 0 auto 5px;">
                            <polygon points="5 3 19 12 5 21 5 3"></polygon>
                        </svg>
                        Resume Voice
                    `;
                    this.synthesis.cancel();
                    this.showNotification('Voice paused');
                } else {
                    btn.classList.remove('paused');
                    btn.innerHTML = `
                        <svg viewBox="0 0 24 24" width="16" height="16" fill="none" stroke="currentColor" stroke-width="2" style="display: block; margin: 0 auto 5px;">
                            <path d="M10 9v6m4-6v6"></path>
                        </svg>
                        Pause Voice
                    `;
                    this.showNotification('Voice resumed');
                }
            }

            clearConversation() {
                const display = document.getElementById('wrist-ai-display');
                display.innerHTML = '<div class="ai-message ai">Conversation cleared. How can I help you?</div>';
                this.conversationHistory = [];
                this.showNotification('Conversation cleared');
            }

            showNotification(message) {
                const notification = document.createElement('div');
                notification.className = 'wrist-notification';
                notification.textContent = message;
                
                document.body.appendChild(notification);
                
                setTimeout(() => {
                    notification.style.opacity = '0';
                    setTimeout(() => notification.remove(), 300);
                }, 2000);
            }
        }

        // Show Mode Manager Class with Full Chat Sync
        class ShowModeManager {
            constructor(worldInstance) {
                this.world = worldInstance;
                this.peer = null;
                this.connections = new Map();
                this.isHost = false;
                this.roomId = null;
                this.isFollowing = false;
                this.updateInterval = 50; // ms
                this.lastUpdate = 0;
                this.viewerNames = new Map(); // Store viewer names

                this.initializePeer();
                this.setupEventListeners();
            }

            initializePeer() {
                const urlParams = new URLSearchParams(window.location.search);
                const hostId = urlParams.get('show');

                try {
                    if (hostId) {
                        // Joining a show
                        this.roomId = hostId;
                        this.peer = new Peer();
                        this.isFollowing = true;

                        this.peer.on('open', (id) => {
                            console.log('Viewer peer ID:', id);
                            console.log('Attempting to join show:', this.roomId);
                            
                            // Set viewer mode UI
                            this.setupViewerMode();
                            
                            setTimeout(() => {
                                this.connectToHost(this.roomId);
                            }, 1000);
                            
                            this.updateStatus('Connecting to presenter...', false);
                            document.getElementById('following-indicator').classList.add('active');
                        });
                    } else {
                        // Not in show mode initially
                        this.peer = new Peer();
                        
                        this.peer.on('open', (id) => {
                            console.log('Peer ID:', id);
                        });
                    }

                    // Handle incoming connections
                    this.peer.on('connection', (conn) => {
                        console.log('Incoming connection from:', conn.peer);
                        this.handleNewConnection(conn);
                    });

                    // Handle errors
                    this.peer.on('error', (err) => {
                        console.error('Peer error:', err);
                        
                        if (err.type === 'peer-unavailable') {
                            this.showError('Presenter not found. Make sure they are online.');
                        } else if (err.type === 'network') {
                            this.showError('Network error. Check your connection.');
                        } else {
                            this.showError('Connection error: ' + err.message);
                        }
                        
                        this.updateStatus('Error', false);
                    });

                    // Handle disconnection
                    this.peer.on('disconnected', () => {
                        console.log('Disconnected from peer server');
                        this.updateStatus('Disconnected', false);
                        
                        setTimeout(() => {
                            if (!this.peer.destroyed) {
                                console.log('Attempting to reconnect...');
                                this.peer.reconnect();
                            }
                        }, 3000);
                    });

                } catch (error) {
                    console.error('Failed to initialize peer:', error);
                    this.showError('Failed to initialize show mode');
                }
            }

            setupViewerMode() {
                // Show viewer mode indicator
                document.getElementById('viewer-mode-indicator').classList.add('active');
                
                // Update chat interface for viewer mode
                const chatInterface = document.getElementById('ai-chat-interface');
                chatInterface.classList.add('viewer-mode');
                
                // Show viewer label in chat
                document.getElementById('viewer-chat-label').style.display = 'inline-block';
                
                // Hide show mode button for viewers
                document.getElementById('show-mode-button').style.display = 'none';
                
                // Keep voice pause button visible but disabled for viewers
                const voicePauseBtn = document.getElementById('voice-pause-button');
                voicePauseBtn.style.opacity = '0.5';
                voicePauseBtn.style.pointerEvents = 'none';
                
                // Hide companion tooltip since viewers can't interact with the 3D companion
                document.getElementById('companion-tooltip').style.display = 'none';
                
                // Adjust camera for third person view
                if (this.world.camera) {
                    // Move camera back and up for better third person perspective
                    this.world.camera.position.z = 15;
                    this.world.camera.position.y = 8;
                    this.world.camera.lookAt(0, 3, 0);
                }
            }

            setupEventListeners() {
                // Show Mode button
                document.getElementById('show-mode-button').addEventListener('click', () => {
                    if (this.isHost) {
                        this.stopHosting();
                    } else {
                        this.startHosting();
                    }
                });

                // Modal close
                document.getElementById('show-mode-close').addEventListener('click', () => {
                    document.getElementById('show-mode-modal').classList.remove('show');
                });

                // Copy URL button
                document.getElementById('copy-url-btn').addEventListener('click', async () => {
                    const urlElement = document.getElementById('qr-url');
                    try {
                        await navigator.clipboard.writeText(urlElement.textContent);
                        const btn = document.getElementById('copy-url-btn');
                        btn.textContent = 'Copied!';
                        btn.classList.add('copied');
                        
                        setTimeout(() => {
                            btn.textContent = 'Copy URL';
                            btn.classList.remove('copied');
                        }, 2000);
                    } catch (err) {
                        console.error('Failed to copy:', err);
                    }
                });

                // Close modal on outside click
                document.getElementById('show-mode-modal').addEventListener('click', (e) => {
                    if (e.target.id === 'show-mode-modal') {
                        document.getElementById('show-mode-modal').classList.remove('show');
                    }
                });
            }

            startHosting() {
                this.isHost = true;
                this.roomId = this.peer.id;
                
                document.getElementById('show-mode-button').classList.add('active');
                document.getElementById('show-mode-modal').classList.add('show');
                document.getElementById('show-mode-status').classList.add('visible');
                
                this.updateStatus('Hosting Show', true);
                this.updateShareUrl();
                
                this.showNotification('Show Mode activated! Share the QR code for others to follow your view.');
            }

            stopHosting() {
                this.isHost = false;
                
                // Disconnect all viewers
                this.connections.forEach((conn) => {
                    conn.close();
                });
                this.connections.clear();
                this.viewerNames.clear();
                
                document.getElementById('show-mode-button').classList.remove('active');
                document.getElementById('show-mode-modal').classList.remove('show');
                document.getElementById('show-mode-status').classList.remove('visible');
                
                this.showNotification('Show Mode deactivated');
                this.updateViewerCount();
            }

            connectToHost(hostId) {
                try {
                    console.log('Connecting to host:', hostId);
                    
                    const viewerUsername = this.generateUsername();
                    
                    const conn = this.peer.connect(hostId, {
                        reliable: true,
                        serialization: 'json',
                        metadata: {
                            type: 'viewer',
                            username: viewerUsername
                        }
                    });

                    // Set connection timeout
                    const connectionTimeout = setTimeout(() => {
                        if (conn.open === false) {
                            console.error('Connection timeout');
                            this.showError('Connection timeout. Presenter may be offline.');
                            conn.close();
                            document.getElementById('following-indicator').classList.remove('active');
                        }
                    }, 10000);

                    conn.on('open', () => {
                        clearTimeout(connectionTimeout);
                        console.log('Connected to presenter successfully');
                        this.updateStatus('Following presenter', true);
                        this.showNotification('Connected to presenter! You are now following their view.');
                        
                        // Store our username for later use
                        this.myUsername = viewerUsername;
                        
                        // Request initial state
                        conn.send({ type: 'requestState' });
                    });

                    this.handleNewConnection(conn);
                } catch (error) {
                    console.error('Failed to connect to host:', error);
                    this.showError('Failed to connect to presenter');
                    document.getElementById('following-indicator').classList.remove('active');
                }
            }

            handleNewConnection(conn) {
                const peerId = conn.peer;

                conn.on('open', () => {
                    console.log('Connection opened with peer:', peerId);
                    this.connections.set(peerId, conn);

                    if (this.isHost) {
                        // Store viewer name
                        const viewerName = conn.metadata?.username || 'Anonymous';
                        this.viewerNames.set(peerId, viewerName);
                        
                        // Show notification for new viewer
                        this.showNotification(`New viewer joined: ${viewerName}`);
                        this.updateViewerCount();
                        
                        // Send current state to new viewer
                        this.sendCurrentState(conn);
                    }
                });

                conn.on('data', (data) => {
                    try {
                        this.handlePeerData(peerId, data);
                    } catch (error) {
                        console.error('Error handling peer data:', error);
                    }
                });

                conn.on('close', () => {
                    console.log('Peer disconnected:', peerId);
                    
                    if (this.isHost) {
                        const viewerName = this.viewerNames.get(peerId) || 'Anonymous';
                        this.showNotification(`${viewerName} left the show`);
                        this.viewerNames.delete(peerId);
                    }
                    
                    this.connections.delete(peerId);
                    
                    if (this.isHost) {
                        this.updateViewerCount();
                    } else if (this.isFollowing) {
                        this.updateStatus('Disconnected from presenter', false);
                        document.getElementById('following-indicator').classList.remove('active');
                        this.showNotification('Disconnected from presenter');
                    }
                });

                conn.on('error', (err) => {
                    console.error('Connection error with peer', peerId, ':', err);
                });
            }

            handlePeerData(peerId, data) {
                switch (data.type) {
                    case 'cameraUpdate':
                        if (this.isFollowing) {
                            this.updateCameraFromHost(data);
                        }
                        break;
                    
                    case 'chatMessage':
                        // Handle chat messages from both viewers and presenter
                        this.showChatMessage(data);
                        break;
                    
                    case 'viewerMessage':
                        // Host receives viewer messages
                        if (this.isHost) {
                            this.handleViewerMessage(peerId, data);
                        }
                        break;
                    
                    case 'aiInteraction':
                        if (this.isFollowing) {
                            this.showAIInteraction(data);
                        }
                        break;
                    
                    case 'voiceActivity':
                        if (this.isFollowing) {
                            this.showVoiceActivity(data);
                        }
                        break;
                    
                    case 'typingIndicator':
                        if (this.isFollowing) {
                            this.showTypingIndicator(data.isTyping);
                        }
                        break;
                    
                    case 'requestState':
                        if (this.isHost) {
                            const conn = this.connections.get(peerId);
                            if (conn) {
                                this.sendCurrentState(conn);
                            }
                        }
                        break;
                    
                    case 'currentState':
                        if (this.isFollowing) {
                            this.applyHostState(data.state);
                        }
                        break;
                }
            }

            handleViewerMessage(peerId, data) {
                const viewerName = this.viewerNames.get(peerId) || 'Anonymous Viewer';
                
                // Add the message to the chat
                const chatMessages = document.getElementById('ai-chat-messages');
                const messageDiv = document.createElement('div');
                messageDiv.className = 'ai-message user viewer-message';
                messageDiv.setAttribute('data-viewer-name', viewerName);
                messageDiv.textContent = data.message;
                
                chatMessages.appendChild(messageDiv);
                chatMessages.scrollTop = chatMessages.scrollHeight;
                
                // Broadcast to all other viewers
                this.connections.forEach((conn, connPeerId) => {
                    if (conn && conn.open && connPeerId !== peerId) {
                        conn.send({
                            type: 'chatMessage',
                            sender: 'user',
                            content: data.message,
                            isPresenter: false,
                            viewerName: viewerName,
                            timestamp: Date.now()
                        });
                    }
                });
                
                // If AI is active and it's a message for the AI, process it
                if (this.world.aiManager && this.world.aiManager.isActive) {
                    // Show notification that viewer sent a message
                    this.showNotification(`${viewerName} sent a message`);
                    
                    // Optionally, you could process viewer messages through AI here
                    // this.world.aiManager.processViewerMessage(data.message, viewerName);
                }
            }

            sendCurrentState(conn) {
                // Send all current chat messages
                const chatMessages = document.getElementById('ai-chat-messages');
                const messages = [];
                
                chatMessages.querySelectorAll('.ai-message').forEach(msg => {
                    const isViewer = msg.classList.contains('viewer-message');
                    messages.push({
                        type: msg.classList.contains('user') ? 'user' : 'ai',
                        content: msg.innerHTML,
                        isPresenter: !isViewer,
                        viewerName: isViewer ? msg.getAttribute('data-viewer-name') : null
                    });
                });
                
                const state = {
                    type: 'currentState',
                    state: {
                        camera: {
                            position: {
                                x: this.world.camera.position.x,
                                y: this.world.camera.position.y,
                                z: this.world.camera.position.z
                            },
                            rotation: {
                                x: this.world.camera.rotation.x,
                                y: this.world.camera.rotation.y,
                                z: this.world.camera.rotation.z
                            }
                        },
                        chatMessages: messages,
                        aiActive: this.world.aiManager.isActive
                    }
                };
                
                conn.send(state);
            }

            applyHostState(state) {
                // Apply camera state
                if (state.camera) {
                    this.updateCameraFromHost({ 
                        position: state.camera.position, 
                        rotation: state.camera.rotation 
                    });
                }
                
                // Apply chat messages
                if (state.chatMessages) {
                    const chatMessages = document.getElementById('ai-chat-messages');
                    chatMessages.innerHTML = '';
                    
                    state.chatMessages.forEach(msg => {
                        this.showChatMessage({
                            sender: msg.type,
                            content: msg.content,
                            isPresenter: msg.isPresenter,
                            viewerName: msg.viewerName
                        });
                    });
                }
                
                // Show chat if AI is active
                if (state.aiActive) {
                    document.getElementById('ai-chat-interface').classList.add('active');
                }
            }

            updateCameraFromHost(data) {
                if (!this.world.camera) return;

                // Smoothly interpolate camera position
                const targetPos = new THREE.Vector3(
                    data.position.x,
                    data.position.y,
                    data.position.z
                );

                // For viewers, offset the camera to show third person perspective
                if (this.isFollowing) {
                    targetPos.z += 7; // Move camera back
                    targetPos.y += 3; // Move camera up
                }

                this.world.camera.position.lerp(targetPos, 0.3);
                
                // Update camera rotation
                this.world.camera.rotation.x = data.rotation.x;
                this.world.camera.rotation.y = data.rotation.y;
                this.world.camera.rotation.z = data.rotation.z;
            }

            showChatMessage(data) {
                const chatMessages = document.getElementById('ai-chat-messages');
                const messageDiv = document.createElement('div');
                messageDiv.className = `ai-message ${data.sender}`;
                
                if (data.isPresenter && this.isFollowing) {
                    messageDiv.classList.add('presenter-message');
                } else if (!data.isPresenter && data.viewerName) {
                    messageDiv.classList.add('viewer-message');
                    messageDiv.setAttribute('data-viewer-name', data.viewerName);
                }
                
                // Use innerHTML to preserve formatting
                messageDiv.innerHTML = data.content;
                
                chatMessages.appendChild(messageDiv);
                chatMessages.scrollTop = chatMessages.scrollHeight;
                
                // Ensure chat is visible
                if (!document.getElementById('ai-chat-interface').classList.contains('active')) {
                    document.getElementById('ai-chat-interface').classList.add('active');
                }
                
                // Animate companion if AI message
                if (data.sender === 'ai' && this.world.aiManager) {
                    this.world.aiManager.animateCompanionSpeaking();
                    
                    // Show 3D text if available
                    if (data.voiceResponse) {
                        this.world.aiManager.animateTextResponse(data.voiceResponse);
                    }
                }
            }

            showTypingIndicator(isTyping) {
                if (isTyping) {
                    this.world.aiManager.showTypingIndicator();
                } else {
                    this.world.aiManager.hideTypingIndicator();
                }
            }

            showVoiceActivity(data) {
                if (data.activity === 'speaking') {
                    document.getElementById('voice-indicator').classList.add('active');
                } else if (data.activity === 'listening') {
                    document.getElementById('listening-indicator').classList.add('active');
                } else {
                    document.getElementById('voice-indicator').classList.remove('active');
                    document.getElementById('listening-indicator').classList.remove('active');
                }
            }

            showAIInteraction(data) {
                // Show notification when presenter interacts with AI
                if (data.action === 'chat_opened') {
                    this.showNotification('Presenter opened AI chat');
                } else if (data.action === 'message_sent') {
                    this.showNotification('Presenter is chatting with AI');
                }
            }

            broadcastCameraUpdate() {
                if (!this.isHost || this.connections.size === 0) return;

                const now = Date.now();
                if (now - this.lastUpdate < this.updateInterval) return;

                const cameraData = {
                    type: 'cameraUpdate',
                    position: {
                        x: this.world.camera.position.x,
                        y: this.world.camera.position.y,
                        z: this.world.camera.position.z
                    },
                    rotation: {
                        x: this.world.camera.rotation.x,
                        y: this.world.camera.rotation.y,
                        z: this.world.camera.rotation.z
                    }
                };

                this.connections.forEach((conn) => {
                    if (conn && conn.open) {
                        try {
                            conn.send(cameraData);
                        } catch (error) {
                            console.error('Failed to send camera update:', error);
                        }
                    }
                });

                this.lastUpdate = now;
            }

            broadcastChatMessage(sender, content, voiceResponse = null) {
                if (!this.isHost || this.connections.size === 0) return;

                const data = {
                    type: 'chatMessage',
                    sender: sender,
                    content: content,
                    voiceResponse: voiceResponse,
                    isPresenter: true,
                    timestamp: Date.now()
                };

                this.connections.forEach((conn) => {
                    if (conn && conn.open) {
                        try {
                            conn.send(data);
                        } catch (error) {
                            console.error('Failed to send chat message:', error);
                        }
                    }
                });
            }

            // New method for viewers to send messages
            sendViewerMessage(message) {
                if (!this.isFollowing) return;
                
                // Find the host connection
                const hostConn = Array.from(this.connections.values())[0];
                if (hostConn && hostConn.open) {
                    hostConn.send({
                        type: 'viewerMessage',
                        message: message,
                        timestamp: Date.now()
                    });
                }
            }

            broadcastTypingIndicator(isTyping) {
                if (!this.isHost || this.connections.size === 0) return;

                const data = {
                    type: 'typingIndicator',
                    isTyping: isTyping
                };

                this.connections.forEach((conn) => {
                    if (conn && conn.open) {
                        try {
                            conn.send(data);
                        } catch (error) {
                            console.error('Failed to send typing indicator:', error);
                        }
                    }
                });
            }

            broadcastVoiceActivity(activity) {
                if (!this.isHost || this.connections.size === 0) return;

                const data = {
                    type: 'voiceActivity',
                    activity: activity // 'speaking', 'listening', or 'idle'
                };

                this.connections.forEach((conn) => {
                    if (conn && conn.open) {
                        try {
                            conn.send(data);
                        } catch (error) {
                            console.error('Failed to send voice activity:', error);
                        }
                    }
                });
            }

            broadcastAIInteraction(action) {
                if (!this.isHost || this.connections.size === 0) return;

                const data = {
                    type: 'aiInteraction',
                    action: action,
                    timestamp: Date.now()
                };

                this.connections.forEach((conn) => {
                    if (conn && conn.open) {
                        try {
                            conn.send(data);
                        } catch (error) {
                            console.error('Failed to send AI interaction:', error);
                        }
                    }
                });
            }

            updateShareUrl() {
                const currentFile = window.location.pathname.split('/').pop() || 'index.html';
                const params = new URLSearchParams({
                    show: this.roomId
                });
                const shareUrl = `${window.location.origin}${window.location.pathname.replace(/[^/]*$/, '')}${currentFile}?${params}`;

                // Update QR code
                const qrUrlElement = document.getElementById('qr-url');
                if (qrUrlElement) {
                    qrUrlElement.textContent = shareUrl;
                }

                // Generate QR code
                this.generateQRCode(shareUrl);

                // Update button appearance
                const showModeButton = document.getElementById('show-mode-button');
                if (showModeButton) {
                    showModeButton.classList.add('active');
                }
            }

            generateQRCode(url) {
                const container = document.getElementById('qr-code-container');
                container.innerHTML = '';

                const loadQRious = () => {
                    return new Promise((resolve, reject) => {
                        if (window.QRious) {
                            resolve();
                        } else {
                            const script = document.createElement('script');
                            script.src = 'https://cdnjs.cloudflare.com/ajax/libs/qrious/4.0.2/qrious.min.js';
                            script.onload = resolve;
                            script.onerror = reject;
                            document.head.appendChild(script);
                        }
                    });
                };

                loadQRious().then(() => {
                    const canvas = document.createElement('canvas');
                    container.appendChild(canvas);

                    new window.QRious({
                        element: canvas,
                        value: url,
                        size: 250,
                        background: 'white',
                        foreground: 'black',
                        level: 'H'
                    });
                }).catch(() => {
                    const img = document.createElement('img');
                    img.src = `https://api.qrserver.com/v1/create-qr-code/?size=250x250&data=${encodeURIComponent(url)}`;
                    img.alt = 'QR Code';
                    container.appendChild(img);
                });
            }

            updateStatus(status, connected) {
                const statusText = document.getElementById('status-text');
                const statusIndicator = document.getElementById('status-indicator');

                if (statusText) statusText.textContent = status;
                if (statusIndicator) {
                    statusIndicator.classList.toggle('connected', connected);
                    statusIndicator.classList.toggle('hosting', this.isHost);
                }
            }

            updateViewerCount() {
                const count = this.connections.size + 1; // +1 for self
                const viewerCountEl = document.getElementById('viewer-count');
                if (viewerCountEl) viewerCountEl.textContent = count;
            }

            generateUsername() {
                const adjectives = ['Swift', 'Curious', 'Bright', 'Eager', 'Active'];
                const nouns = ['Viewer', 'Observer', 'Student', 'Attendee', 'Participant'];
                const adj = adjectives[Math.floor(Math.random() * adjectives.length)];
                const noun = nouns[Math.floor(Math.random() * nouns.length)];
                return `${adj}${noun}${Math.floor(Math.random() * 100)}`;
            }

            showNotification(message) {
                const notification = document.createElement('div');
                notification.className = 'show-mode-notification';
                notification.textContent = message;

                document.body.appendChild(notification);

                setTimeout(() => {
                    notification.style.animation = 'slideOut 0.3s ease';
                    setTimeout(() => notification.remove(), 300);
                }, 3000);
            }

            showError(message) {
                console.error(message);
                this.showNotification(' ' + message);
            }

            // Call this in the animation loop
            update() {
                this.broadcastCameraUpdate();
            }
        }

        // Settings Manager
        class SettingsManager {
            constructor(worldInstance) {
                this.world = worldInstance;
                this.settings = this.loadAllSettings();
                this.setupEventListeners();
                this.updatePreview();
            }

            loadAllSettings() {
                const stored = localStorage.getItem('aiCompanionAllSettings');
                if (stored) {
                    return JSON.parse(stored);
                }

                return {
                    version: "1.0",
                    timestamp: new Date().toISOString(),
                    api: {
                        key: localStorage.getItem('nexus_ai_api_key') || '',
                        endpoint: 'http://localhost:7071/api/businessinsightbot_function'
                    },
                    voice: {
                        output: {
                            enabled: true,
                            autoSpeak: false,
                            azureTTSKey: '',
                            ttsVoiceName: 'en-US-JennyNeural'
                        },
                        input: {
                            enabled: true,
                            continuousConversation: false,
                            pushToTalkKey: 'Space'
                        }
                    },
                    perspective: {
                        camera: {
                            position: { x: 0, y: 5, z: 8 },
                            rotation: { x: 0, y: 0, z: 0 },
                            fov: 75
                        },
                        visual: {
                            fogDensity: 50,
                            particleCount: 300
                        }
                    },
                    world: {
                        name: "AI Companion Hub",
                        description: "Your intelligent assistant awaits. Click on the AI companion to start chatting!"
                    }
                };
            }

            setupEventListeners() {
                // Tab switching
                document.querySelectorAll('.settings-tab').forEach(tab => {
                    tab.addEventListener('click', (e) => {
                        document.querySelectorAll('.settings-tab').forEach(t => t.classList.remove('active'));
                        document.querySelectorAll('.settings-section').forEach(s => s.classList.remove('active'));
                        
                        e.target.classList.add('active');
                        const tabName = e.target.dataset.tab;
                        document.getElementById(`${tabName}-settings`).classList.add('active');
                    });
                });

                // Close button
                document.getElementById('close-settings').addEventListener('click', () => {
                    document.getElementById('settings-panel').classList.remove('active');
                });

                // Settings button
                document.getElementById('settings-button').addEventListener('click', () => {
                    this.openSettings();
                });

                // Toggle switches
                this.setupToggleSwitch('settings-voice-enabled', 'voice.output.enabled');
                this.setupToggleSwitch('settings-auto-speak', 'voice.output.autoSpeak');
                this.setupToggleSwitch('settings-voice-input-enabled', 'voice.input.enabled');
                this.setupToggleSwitch('settings-continuous-conversation', 'voice.input.continuousConversation');

                // Input fields
                this.setupInputField('settings-api-key', 'api.key');
                this.setupInputField('settings-endpoint', 'api.endpoint');
                this.setupInputField('settings-azure-tts-key', 'voice.output.azureTTSKey');
                this.setupInputField('world-name', 'world.name');
                this.setupInputField('world-description', 'world.description');

                // Select fields
                this.setupSelectField('settings-tts-voice', 'voice.output.ttsVoiceName');
                this.setupSelectField('settings-push-to-talk', 'voice.input.pushToTalkKey');

                // Real-time preview update
                setInterval(() => this.updatePreview(), 1000);
            }

            setupToggleSwitch(elementId, settingPath) {
                const element = document.getElementById(elementId);
                if (!element) return;

                const value = this.getNestedValue(this.settings, settingPath);
                element.classList.toggle('active', value);

                element.addEventListener('click', () => {
                    const isActive = element.classList.toggle('active');
                    this.setNestedValue(this.settings, settingPath, isActive);
                    this.updatePreview();
                });
            }

            setupInputField(elementId, settingPath) {
                const element = document.getElementById(elementId);
                if (!element) return;

                const value = this.getNestedValue(this.settings, settingPath);
                element.value = value || '';

                element.addEventListener('input', (e) => {
                    this.setNestedValue(this.settings, settingPath, e.target.value);
                    this.updatePreview();
                });
            }

            setupSelectField(elementId, settingPath) {
                const element = document.getElementById(elementId);
                if (!element) return;

                const value = this.getNestedValue(this.settings, settingPath);
                element.value = value || '';

                element.addEventListener('change', (e) => {
                    this.setNestedValue(this.settings, settingPath, e.target.value);
                    this.updatePreview();
                });
            }

            getNestedValue(obj, path) {
                return path.split('.').reduce((curr, prop) => curr?.[prop], obj);
            }

            setNestedValue(obj, path, value) {
                const props = path.split('.');
                const last = props.pop();
                const target = props.reduce((curr, prop) => {
                    if (!curr[prop]) curr[prop] = {};
                    return curr[prop];
                }, obj);
                target[last] = value;
            }

            openSettings() {
                this.loadSettingsToUI();
                document.getElementById('settings-panel').classList.add('active');
                this.updatePreview();
            }

            loadSettingsToUI() {
                // Load all current settings into UI
                this.loadToggleSwitch('settings-voice-enabled', 'voice.output.enabled');
                this.loadToggleSwitch('settings-auto-speak', 'voice.output.autoSpeak');
                this.loadToggleSwitch('settings-voice-input-enabled', 'voice.input.enabled');
                this.loadToggleSwitch('settings-continuous-conversation', 'voice.input.continuousConversation');

                this.loadInputField('settings-api-key', 'api.key');
                this.loadInputField('settings-endpoint', 'api.endpoint');
                this.loadInputField('settings-azure-tts-key', 'voice.output.azureTTSKey');
                this.loadInputField('world-name', 'world.name');
                this.loadInputField('world-description', 'world.description');

                this.loadSelectField('settings-tts-voice', 'voice.output.ttsVoiceName');
                this.loadSelectField('settings-push-to-talk', 'voice.input.pushToTalkKey');
            }

            loadToggleSwitch(elementId, settingPath) {
                const element = document.getElementById(elementId);
                if (!element) return;
                const value = this.getNestedValue(this.settings, settingPath);
                element.classList.toggle('active', value);
            }

            loadInputField(elementId, settingPath) {
                const element = document.getElementById(elementId);
                if (!element) return;
                const value = this.getNestedValue(this.settings, settingPath);
                element.value = value || '';
            }

            loadSelectField(elementId, settingPath) {
                const element = document.getElementById(elementId);
                if (!element) return;
                const value = this.getNestedValue(this.settings, settingPath);
                element.value = value || '';
            }

            updatePreview() {
                const preview = document.getElementById('json-preview');
                if (preview) {
                    const displaySettings = JSON.parse(JSON.stringify(this.settings));
                    
                    // Mask sensitive data for display
                    if (displaySettings.api.key) {
                        displaySettings.api.key = displaySettings.api.key.substring(0, 8) + '...';
                    }
                    if (displaySettings.voice.output.azureTTSKey) {
                        displaySettings.voice.output.azureTTSKey = displaySettings.voice.output.azureTTSKey.substring(0, 8) + '...';
                    }
                    
                    preview.textContent = JSON.stringify(displaySettings, null, 2);
                }
            }

            saveSettings() {
                this.settings.timestamp = new Date().toISOString();
                localStorage.setItem('aiCompanionAllSettings', JSON.stringify(this.settings));
                
                // Apply settings to various components
                if (this.world.aiManager) {
                    this.world.aiManager.apiKey = this.settings.api.key;
                    this.world.aiManager.endpoint = this.settings.api.endpoint;
                    this.world.aiManager.applySettings();
                }

                if (this.world.perspectiveManager) {
                    this.world.perspectiveManager.applySettings(this.settings.perspective);
                }

                // Update world UI
                document.getElementById('world-title').textContent = this.settings.world.name;
                document.getElementById('world-description').textContent = this.settings.world.description;

                this.world.showNotification('Settings saved successfully!');
                document.getElementById('settings-panel').classList.remove('active');
            }

            exportSettings() {
                const dataStr = JSON.stringify(this.settings, null, 2);
                const dataUri = 'data:application/json;charset=utf-8,'+ encodeURIComponent(dataStr);
                
                const exportFileDefaultName = `ai-companion-settings-${new Date().toISOString().split('T')[0]}.json`;
                
                const linkElement = document.createElement('a');
                linkElement.setAttribute('href', dataUri);
                linkElement.setAttribute('download', exportFileDefaultName);
                linkElement.click();
                
                this.world.showNotification('Settings exported successfully!');
            }

            async importSettings(event) {
                const file = event.target.files[0];
                if (!file) return;

                try {
                    const text = await file.text();
                    const imported = JSON.parse(text);
                    
                    // Validate imported settings
                    if (!imported.version || !imported.api || !imported.voice || !imported.perspective) {
                        throw new Error('Invalid settings file format');
                    }
                    
                    // Merge with current settings
                    this.settings = { ...this.settings, ...imported };
                    this.settings.timestamp = new Date().toISOString();
                    
                    // Save and apply
                    this.saveSettings();
                    this.loadSettingsToUI();
                    this.updatePreview();
                    this.world.showNotification('Settings imported successfully!');
                } catch (error) {
                    console.error('Error importing settings:', error);
                    this.world.showNotification('Failed to import settings. Please check the file format.');
                }
                
                event.target.value = '';
            }

            resetSettings() {
                if (confirm('Are you sure you want to reset all settings? This cannot be undone.')) {
                    localStorage.removeItem('aiCompanionAllSettings');
                    localStorage.removeItem('nexus_ai_api_key');
                    localStorage.removeItem('nexusAISettings');
                    
                    this.settings = this.loadAllSettings();
                    this.loadSettingsToUI();
                    this.updatePreview();
                    
                    this.world.showNotification('All settings have been reset to defaults.');
                }
            }
        }

        // Perspective Manager
        class PerspectiveManager {
            constructor(worldInstance) {
                this.world = worldInstance;
                this.setupControls();
                this.presets = {
                    default: { position: { x: 0, y: 5, z: 8 }, rotation: { x: 0, y: 0 }, fov: 75 },
                    overhead: { position: { x: 0, y: 20, z: 5 }, rotation: { x: -60, y: 0 }, fov: 60 },
                    close: { position: { x: 0, y: 4, z: 3 }, rotation: { x: 0, y: 0 }, fov: 90 },
                    side: { position: { x: 10, y: 5, z: 0 }, rotation: { x: 0, y: 90 }, fov: 75 },
                    wide: { position: { x: 0, y: 8, z: 15 }, rotation: { x: 0, y: 0 }, fov: 100 },
                    dramatic: { position: { x: -5, y: 2, z: 5 }, rotation: { x: 10, y: -45 }, fov: 85 }
                };
            }

            setupControls() {
                // Camera position controls
                this.setupRangeControl('camera-pos-x', 'pos-x-value', (value) => {
                    if (this.world.camera) this.world.camera.position.x = parseFloat(value);
                });

                this.setupRangeControl('camera-pos-y', 'pos-y-value', (value) => {
                    if (this.world.camera) this.world.camera.position.y = parseFloat(value);
                });

                this.setupRangeControl('camera-pos-z', 'pos-z-value', (value) => {
                    if (this.world.camera) this.world.camera.position.z = parseFloat(value);
                });

                // Camera rotation controls
                this.setupRangeControl('camera-rot-x', 'rot-x-value', (value) => {
                    if (this.world.camera) this.world.camera.rotation.x = THREE.MathUtils.degToRad(parseFloat(value));
                });

                this.setupRangeControl('camera-rot-y', 'rot-y-value', (value) => {
                    if (this.world.camera) this.world.camera.rotation.y = THREE.MathUtils.degToRad(parseFloat(value));
                });

                // FOV control
                this.setupRangeControl('camera-fov', 'fov-value', (value) => {
                    if (this.world.camera) {
                        this.world.camera.fov = parseFloat(value);
                        this.world.camera.updateProjectionMatrix();
                    }
                });

                // Visual settings
                this.setupRangeControl('fog-density', 'fog-density-value', (value) => {
                    if (this.world.scene && this.world.scene.fog) {
                        this.world.scene.fog.far = parseFloat(value);
                    }
                });

                this.setupRangeControl('particle-count', 'particle-count-value', (value) => {
                    this.updateParticleCount(parseInt(value));
                });
            }

            setupRangeControl(inputId, displayId, onChange) {
                const input = document.getElementById(inputId);
                const display = document.getElementById(displayId);
                
                if (input && display) {
                    input.addEventListener('input', (e) => {
                        display.textContent = e.target.value;
                        onChange(e.target.value);
                        this.updateSettingsFromUI();
                    });
                }
            }

            updateSettingsFromUI() {
                if (this.world.settingsManager) {
                    const settings = this.world.settingsManager.settings;
                    
                    settings.perspective.camera.position.x = parseFloat(document.getElementById('camera-pos-x').value);
                    settings.perspective.camera.position.y = parseFloat(document.getElementById('camera-pos-y').value);
                    settings.perspective.camera.position.z = parseFloat(document.getElementById('camera-pos-z').value);
                    
                    settings.perspective.camera.rotation.x = parseFloat(document.getElementById('camera-rot-x').value);
                    settings.perspective.camera.rotation.y = parseFloat(document.getElementById('camera-rot-y').value);
                    
                    settings.perspective.camera.fov = parseFloat(document.getElementById('camera-fov').value);
                    settings.perspective.visual.fogDensity = parseFloat(document.getElementById('fog-density').value);
                    settings.perspective.visual.particleCount = parseInt(document.getElementById('particle-count').value);
                    
                    this.world.settingsManager.updatePreview();
                }
            }

            applyPreset(presetName) {
                const preset = this.presets[presetName];
                if (!preset) return;

                // Update camera
                if (this.world.camera) {
                    this.world.camera.position.set(preset.position.x, preset.position.y, preset.position.z);
                    this.world.camera.rotation.x = THREE.MathUtils.degToRad(preset.rotation.x);
                    this.world.camera.rotation.y = THREE.MathUtils.degToRad(preset.rotation.y);
                    this.world.camera.fov = preset.fov;
                    this.world.camera.updateProjectionMatrix();
                }

                // Update UI controls
                document.getElementById('camera-pos-x').value = preset.position.x;
                document.getElementById('pos-x-value').textContent = preset.position.x;
                
                document.getElementById('camera-pos-y').value = preset.position.y;
                document.getElementById('pos-y-value').textContent = preset.position.y;
                
                document.getElementById('camera-pos-z').value = preset.position.z;
                document.getElementById('pos-z-value').textContent = preset.position.z;
                
                document.getElementById('camera-rot-x').value = preset.rotation.x;
                document.getElementById('rot-x-value').textContent = preset.rotation.x;
                
                document.getElementById('camera-rot-y').value = preset.rotation.y;
                document.getElementById('rot-y-value').textContent = preset.rotation.y;
                
                document.getElementById('camera-fov').value = preset.fov;
                document.getElementById('fov-value').textContent = preset.fov;

                this.updateSettingsFromUI();
                this.world.showNotification(`Applied ${presetName} preset`);
            }

            applySettings(perspectiveSettings) {
                if (!perspectiveSettings) return;

                // Apply camera settings
                if (this.world.camera && perspectiveSettings.camera) {
                    const cam = perspectiveSettings.camera;
                    this.world.camera.position.set(cam.position.x, cam.position.y, cam.position.z);
                    this.world.camera.rotation.set(
                        THREE.MathUtils.degToRad(cam.rotation.x),
                        THREE.MathUtils.degToRad(cam.rotation.y),
                        THREE.MathUtils.degToRad(cam.rotation.z || 0)
                    );
                    this.world.camera.fov = cam.fov;
                    this.world.camera.updateProjectionMatrix();
                }

                // Apply visual settings
                if (perspectiveSettings.visual) {
                    if (this.world.scene && this.world.scene.fog) {
                        this.world.scene.fog.far = perspectiveSettings.visual.fogDensity;
                    }
                    this.updateParticleCount(perspectiveSettings.visual.particleCount);
                }
            }

            updateParticleCount(count) {
                // Find and update particle system
                const particles = this.world.scene.getObjectByProperty('type', 'Points');
                if (particles) {
                    const positions = new Float32Array(count * 3);
                    const colors = new Float32Array(count * 3);

                    for (let i = 0; i < count * 3; i += 3) {
                        positions[i] = (Math.random() - 0.5) * 80;
                        positions[i + 1] = Math.random() * 30 + 5;
                        positions[i + 2] = (Math.random() - 0.5) * 80;

                        colors[i] = Math.random() * 0.5 + 0.5;
                        colors[i + 1] = Math.random() * 0.5;
                        colors[i + 2] = Math.random() * 0.5 + 0.5;
                    }

                    particles.geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                    particles.geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                }
            }
        }

        // Voice Input Manager
        class VoiceInputManager {
            constructor(aiManager) {
                this.aiManager = aiManager;
                this.recognition = null;
                this.isListening = false;
                this.isEnabled = true;
                this.continuousMode = false;
                this.pushToTalkKey = 'Space';
                this.isKeyPressed = false;
                this.isPaused = false;
                this.wasListeningBeforePause = false;
                
                this.initializeSpeechRecognition();
                
                this.voiceInputBtn = document.getElementById('voice-input-btn');
                this.listeningIndicator = document.getElementById('listening-indicator');
                
                this.setupEventListeners();
            }

            initializeSpeechRecognition() {
                const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
                
                if (!SpeechRecognition) {
                    console.error('Speech recognition not supported');
                    this.showNotification('Speech recognition not supported in this browser');
                    return;
                }

                this.recognition = new SpeechRecognition();
                this.recognition.continuous = false;
                this.recognition.interimResults = true;
                this.recognition.lang = 'en-US';

                this.recognition.onstart = () => {
                    console.log('Speech recognition started');
                    this.isListening = true;
                    this.voiceInputBtn.classList.add('recording');
                    this.listeningIndicator.classList.add('active');
                    
                    // Broadcast voice activity
                    if (this.aiManager.world.showModeManager && this.aiManager.world.showModeManager.isHost) {
                        this.aiManager.world.showModeManager.broadcastVoiceActivity('listening');
                    }
                };

                this.recognition.onend = () => {
                    console.log('Speech recognition ended');
                    this.isListening = false;
                    this.voiceInputBtn.classList.remove('recording');
                    this.listeningIndicator.classList.remove('active');
                    
                    // Broadcast voice activity
                    if (this.aiManager.world.showModeManager && this.aiManager.world.showModeManager.isHost) {
                        this.aiManager.world.showModeManager.broadcastVoiceActivity('idle');
                    }
                    
                    // Only restart if continuous mode is enabled and not paused
                    if (this.continuousMode && this.isEnabled && this.aiManager.isActive && !this.isPaused) {
                        setTimeout(() => {
                            if (!this.aiManager.voiceManager.isSpeaking && !this.isPaused) {
                                this.startListening();
                            }
                        }, 500);
                    }
                };

                this.recognition.onresult = (event) => {
                    let finalTranscript = '';
                    let interimTranscript = '';

                    for (let i = event.resultIndex; i < event.results.length; i++) {
                        const transcript = event.results[i][0].transcript;
                        if (event.results[i].isFinal) {
                            finalTranscript += transcript;
                        } else {
                            interimTranscript += transcript;
                        }
                    }

                    if (interimTranscript) {
                        document.getElementById('ai-chat-input').value = interimTranscript;
                    }

                    if (finalTranscript) {
                        console.log('Final transcript:', finalTranscript);
                        document.getElementById('ai-chat-input').value = finalTranscript;
                        this.aiManager.sendMessage();
                        
                        if (!this.continuousMode) {
                            this.stopListening();
                        }
                    }
                };

                this.recognition.onerror = (event) => {
                    console.error('Speech recognition error:', event.error);
                    this.isListening = false;
                    this.voiceInputBtn.classList.remove('recording');
                    this.listeningIndicator.classList.remove('active');
                    
                    // Ignore aborted errors when pausing
                    if (event.error === 'aborted') {
                        console.log('Speech recognition aborted (likely due to pause)');
                        return;
                    }
                    
                    if (event.error === 'no-speech') {
                        return;
                    }
                    
                    this.showNotification(`Speech recognition error: ${event.error}`);
                };
            }

            setupEventListeners() {
                if (this.voiceInputBtn) {
                    if (isMobile) {
                        this.voiceInputBtn.addEventListener('touchstart', (e) => {
                            e.preventDefault();
                            if (this.isEnabled && this.aiManager.isActive && !this.isPaused) {
                                this.startListening();
                            }
                        });

                        this.voiceInputBtn.addEventListener('touchend', (e) => {
                            e.preventDefault();
                            if (!this.continuousMode) {
                                this.stopListening();
                            }
                        });
                    } else {
                        this.voiceInputBtn.addEventListener('mousedown', (e) => {
                            e.preventDefault();
                            if (this.isEnabled && this.aiManager.isActive && !this.isPaused) {
                                this.startListening();
                            }
                        });

                        this.voiceInputBtn.addEventListener('mouseup', (e) => {
                            e.preventDefault();
                            if (!this.continuousMode) {
                                this.stopListening();
                            }
                        });

                        this.voiceInputBtn.addEventListener('mouseleave', (e) => {
                            if (this.isListening && !this.continuousMode) {
                                this.stopListening();
                            }
                        });
                    }
                }

                if (!isMobile) {
                    window.addEventListener('keydown', (e) => {
                        if (e.key === this.pushToTalkKey && !this.isKeyPressed && this.isEnabled && this.aiManager.isActive && !e.repeat && !this.isPaused) {
                            this.isKeyPressed = true;
                            this.startListening();
                        }
                    });

                    window.addEventListener('keyup', (e) => {
                        if (e.key === this.pushToTalkKey && this.isKeyPressed) {
                            this.isKeyPressed = false;
                            if (!this.continuousMode) {
                                this.stopListening();
                            }
                        }
                    });
                }
            }

            startListening() {
                if (!this.recognition || this.isListening || this.aiManager.voiceManager.isSpeaking || this.isPaused) {
                    return;
                }

                try {
                    this.recognition.start();
                } catch (error) {
                    console.error('Error starting speech recognition:', error);
                }
            }

            stopListening() {
                if (!this.recognition || !this.isListening) {
                    return;
                }

                try {
                    this.recognition.stop();
                } catch (error) {
                    console.error('Error stopping speech recognition:', error);
                }
            }

            setEnabled(enabled) {
                this.isEnabled = enabled;
                if (!enabled) {
                    this.stopListening();
                }
                this.updateButtonState();
            }

            setContinuousMode(enabled) {
                this.continuousMode = enabled;
                if (enabled && this.isEnabled && this.aiManager.isActive && !this.isListening && !this.isPaused) {
                    this.startListening();
                } else if (!enabled && this.isListening) {
                    this.stopListening();
                }
            }

            setPushToTalkKey(key) {
                this.pushToTalkKey = key;
            }

            setPaused(paused) {
                this.isPaused = paused;
                
                if (paused) {
                    // Remember if we were listening before pause
                    this.wasListeningBeforePause = this.isListening;
                    
                    // Stop listening gracefully
                    if (this.isListening) {
                        try {
                            this.recognition.abort(); // Use abort instead of stop to prevent error
                        } catch (error) {
                            console.log('Error aborting speech recognition:', error);
                        }
                        this.isListening = false;
                        this.voiceInputBtn.classList.remove('recording');
                        this.listeningIndicator.classList.remove('active');
                    }
                } else {
                    // Resume if we were listening before and continuous mode is on
                    if (this.continuousMode && this.isEnabled && this.aiManager.isActive && this.wasListeningBeforePause) {
                        setTimeout(() => {
                            this.startListening();
                        }, 500);
                    }
                    this.wasListeningBeforePause = false;
                }
                
                this.updateButtonState();
            }

            updateButtonState() {
                if (this.voiceInputBtn) {
                    if (this.isPaused || !this.isEnabled) {
                        this.voiceInputBtn.classList.add('disabled');
                        this.voiceInputBtn.title = this.isPaused ? 'Voice input paused' : 'Voice input disabled';
                    } else {
                        this.voiceInputBtn.classList.remove('disabled');
                        this.voiceInputBtn.title = 'Hold to speak';
                    }
                }
            }

            showNotification(message) {
                if (this.aiManager && this.aiManager.showNotification) {
                    this.aiManager.showNotification(message);
                }
            }
        }

        // Voice Manager with Azure TTS
        class VoiceManager {
            constructor() {
                this.synthesis = window.speechSynthesis;
                this.enabled = true;
                this.autoSpeak = false;
                this.isSpeaking = false;
                this.azureKey = '';
                this.azureRegion = 'eastus2';
                this.voiceName = 'en-US-JennyNeural';
                this.isSdkLoaded = false;
                this.speechSynthesizer = null;
                this.maxCharacters = 5000;
                this.isPaused = false;
                
                this.loadSpeechSdk();
            }

            loadSpeechSdk() {
                if (window.SpeechSDK) {
                    this.isSdkLoaded = true;
                    return;
                }

                const script = document.createElement("script");
                script.src = "https://aka.ms/csspeech/jsbrowserpackageraw";
                script.async = true;
                script.onload = () => {
                    console.log("Microsoft Speech SDK loaded");
                    this.isSdkLoaded = true;
                };
                script.onerror = () => {
                    console.error("Failed to load Microsoft Speech SDK");
                };

                document.body.appendChild(script);
            }

            setEnabled(enabled) {
                this.enabled = enabled;
                if (!enabled) {
                    this.stopSpeaking();
                }
            }

            setAutoSpeak(autoSpeak) {
                this.autoSpeak = autoSpeak;
            }

            setAzureKey(key) {
                this.azureKey = key;
            }

            setVoiceName(voiceName) {
                this.voiceName = voiceName;
            }

            setPaused(paused) {
                this.isPaused = paused;
                if (paused) {
                    this.stopSpeaking();
                }
            }

            async speak(text, aiManager = null) {
                if (!this.enabled || !text || this.isSpeaking || this.isPaused) return;

                this.stopSpeaking();
                
                const cleanText = this.cleanTextForSpeech(text);
                
                // Broadcast voice activity
                if (aiManager && aiManager.world.showModeManager && aiManager.world.showModeManager.isHost) {
                    aiManager.world.showModeManager.broadcastVoiceActivity('speaking');
                }
                
                if (this.azureKey && this.isSdkLoaded && window.SpeechSDK) {
                    await this.speakWithAzure(cleanText, aiManager);
                } else {
                    await this.speakWithBrowser(cleanText, aiManager);
                }
                
                // Broadcast voice activity end
                if (aiManager && aiManager.world.showModeManager && aiManager.world.showModeManager.isHost) {
                    aiManager.world.showModeManager.broadcastVoiceActivity('idle');
                }
            }

            async speakWithAzure(text, aiManager = null) {
                if (this.isPaused) return;
                
                try {
                    const truncatedText = text.length > this.maxCharacters
                        ? text.substring(0, this.maxCharacters) + "... (text truncated for speech)"
                        : text;

                    const speechConfig = window.SpeechSDK.SpeechConfig.fromSubscription(
                        this.azureKey,
                        this.azureRegion
                    );
                    speechConfig.speechSynthesisVoiceName = this.voiceName;

                    const audioConfig = window.SpeechSDK.AudioConfig.fromDefaultSpeakerOutput();
                    this.speechSynthesizer = new window.SpeechSDK.SpeechSynthesizer(
                        speechConfig,
                        audioConfig
                    );

                    this.isSpeaking = true;
                    document.getElementById('voice-indicator').classList.add('active');

                    await new Promise((resolve, reject) => {
                        this.speechSynthesizer.speakTextAsync(
                            truncatedText,
                            (result) => {
                                if (
                                    result.reason ===
                                    window.SpeechSDK.ResultReason.SynthesizingAudioCompleted
                                ) {
                                    console.log("Azure TTS synthesis completed");
                                    this.isSpeaking = false;
                                    document.getElementById('voice-indicator').classList.remove('active');
                                    
                                    if (this.speechSynthesizer) {
                                        this.speechSynthesizer.close();
                                        this.speechSynthesizer = null;
                                    }
                                    resolve();
                                } else {
                                    console.error(
                                        `Speech synthesis canceled, reason: ${result.reason}`
                                    );
                                    
                                    if (this.speechSynthesizer) {
                                        this.speechSynthesizer.close();
                                        this.speechSynthesizer = null;
                                    }

                                    this.isSpeaking = false;
                                    document.getElementById('voice-indicator').classList.remove('active');
                                    reject(new Error(`Speech synthesis failed.`));
                                }
                            },
                            (error) => {
                                console.error("Azure TTS error:", error);

                                if (this.speechSynthesizer) {
                                    this.speechSynthesizer.close();
                                    this.speechSynthesizer = null;
                                }

                                this.isSpeaking = false;
                                document.getElementById('voice-indicator').classList.remove('active');
                                reject(error);
                            }
                        );
                    });
                } catch (error) {
                    console.error("Azure TTS error:", error);
                    this.isSpeaking = false;
                    document.getElementById('voice-indicator').classList.remove('active');
                    await this.speakWithBrowser(text, aiManager);
                }
            }

            async speakWithBrowser(text, aiManager = null) {
                if (this.isPaused) return;
                
                return new Promise((resolve, reject) => {
                    try {
                        const utterance = new SpeechSynthesisUtterance(text);
                        utterance.rate = 1.0;
                        utterance.pitch = 1.0;
                        utterance.volume = 1.0;
                        
                        const voices = this.synthesis.getVoices();
                        const preferredVoice = voices.find(voice => 
                            voice.name.includes('Microsoft') || 
                            voice.name.includes('Google') ||
                            voice.name.includes('Natural')
                        ) || voices[0];
                        
                        if (preferredVoice) {
                            utterance.voice = preferredVoice;
                        }
                        
                        utterance.onstart = () => {
                            this.isSpeaking = true;
                            document.getElementById('voice-indicator').classList.add('active');
                        };
                        
                        utterance.onend = () => {
                            this.isSpeaking = false;
                            document.getElementById('voice-indicator').classList.remove('active');
                            resolve();
                        };
                        
                        utterance.onerror = (error) => {
                            this.isSpeaking = false;
                            document.getElementById('voice-indicator').classList.remove('active');
                            reject(error);
                        };
                        
                        this.synthesis.speak(utterance);
                    } catch (error) {
                        this.isSpeaking = false;
                        document.getElementById('voice-indicator').classList.remove('active');
                        reject(error);
                    }
                });
            }

            stopSpeaking() {
                if (this.speechSynthesizer) {
                    try {
                        this.speechSynthesizer.close();
                    } catch (e) {
                        console.warn("Error closing speech synthesizer:", e);
                    }
                    this.speechSynthesizer = null;
                }

                if (window.speechSynthesis) {
                    try {
                        window.speechSynthesis.cancel();
                    } catch (e) {
                        console.warn("Error canceling speech synthesis:", e);
                    }
                }

                this.isSpeaking = false;
                document.getElementById('voice-indicator').classList.remove('active');
            }

            cleanTextForSpeech(text) {
                let cleanText = text.replace(/<[^>]*>/g, " ");

                cleanText = cleanText
                    .replace(/\*\*([^*]+)\*\*/g, "$1")
                    .replace(/\*([^*]+)\*/g, "$1")
                    .replace(/`([^`]+)`/g, "$1")
                    .replace(/\[([^\]]+)\]\([^)]+\)/g, "$1")
                    .replace(/#{1,6}\s+([^\n]+)/g, "$1")
                    .replace(/```[\s\S]*?```/g, "")
                    .replace(/\n/g, " ")
                    .replace(/\s+/g, " ")
                    .trim();

                return cleanText;
            }
        }

        // Task Manager for conversation replay
        class TaskManager {
            constructor(worldInstance) {
                this.world = worldInstance;
                this.conversations = new Map();
                this.currentReplay = null;
                this.isReplaying = false;

                this.setupEventListeners();
            }

            setupEventListeners() {
                document.getElementById('tasks-button').addEventListener('click', () => {
                    this.toggleTaskPanel();
                });
            }

            toggleTaskPanel() {
                const panel = document.getElementById('task-panel');
                panel.classList.toggle('active');
                if (panel.classList.contains('active')) {
                    this.updateTaskList();
                }
            }

            updateTaskList() {
                const taskList = document.getElementById('task-list');
                taskList.innerHTML = '';

                if (this.conversations.size === 0) {
                    taskList.innerHTML = '<p style="color: rgba(255, 255, 255, 0.5); text-align: center; margin-top: 20px;">No conversations loaded yet. Upload a Teacher-Learner conversation JSON to replay it in 3D space!</p>';
                    return;
                }

                this.conversations.forEach((conversation, conversationId) => {
                    const taskEl = document.createElement('div');
                    taskEl.className = 'task-item';
                    
                    const messageCount = conversation.conversation ? conversation.conversation.length : 0;
                    const timestamp = conversation.timestamp ? new Date(conversation.timestamp).toLocaleString() : 'Unknown';
                    const appName = conversation.appName || 'Unnamed Conversation';
                    
                    taskEl.innerHTML = `<strong>${appName}</strong>
                        <small>Saved: ${timestamp}</small>
                        <div style="font-size: 0.85em; color: rgba(255, 255, 255, 0.7); margin-top: 8px;">
                            ${messageCount} messages
                        </div>
                    `;
                    taskEl.onclick = () => this.startConversationReplay(conversationId);
                    taskList.appendChild(taskEl);
                });
            }

            async uploadConversation(event) {
                const file = event.target.files[0];
                if (!file) return;

                try {
                    const text = await file.text();
                    const conversationData = JSON.parse(text);

                    if (!conversationData.conversation || !Array.isArray(conversationData.conversation)) {
                        throw new Error('Invalid conversation format');
                    }

                    const conversationId = `conv_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
                    
                    this.conversations.set(conversationId, conversationData);

                    this.updateTaskList();
                    this.world.showNotification('Conversation uploaded successfully!');

                } catch (error) {
                    console.error('Error uploading conversation:', error);
                    this.world.showNotification('Failed to upload conversation. Check file format.');
                }

                event.target.value = '';
            }

            async startConversationReplay(conversationId) {
                const conversation = this.conversations.get(conversationId);
                if (!conversation) return;

                this.world.showNotification(`Starting conversation replay...`);

                document.getElementById('ai-chat-interface').classList.add('active');

                const chatMessages = document.getElementById('ai-chat-messages');
                chatMessages.innerHTML = '';

                this.isReplaying = true;
                this.currentReplay = {
                    conversation: conversation,
                    currentIndex: 0
                };

                for (const message of conversation.conversation) {
                    await this.processMessage(message);
                    await this.delay(2000);
                }

                this.isReplaying = false;
                this.world.showNotification('Conversation replay completed!');
            }

            async processMessage(message) {
                if (message.role === 'user') {
                    this.addReplayMessage(message.content, 'user');
                    
                } else if (message.role === 'assistant') {
                    this.world.aiManager.showTypingIndicator();
                    
                    await this.delay(1500);
                    
                    this.world.aiManager.hideTypingIndicator();
                    this.addReplayMessage(message.content, 'ai');
                    
                    if (this.world.aiManager && this.world.aiManager.isActive) {
                        this.world.aiManager.animateTextResponse(message.content);
                    }
                    
                } else if (message.role === 'system') {
                    this.addReplayMessage(message.content, 'system');
                }
            }

            addReplayMessage(text, sender) {
                const chatMessages = document.getElementById('ai-chat-messages');
                const messageDiv = document.createElement('div');
                messageDiv.className = `ai-message ${sender} task-replay`;
                
                if (sender === 'ai') {
                    // Parse markdown for AI messages
                    const parser = new MarkdownParser();
                    messageDiv.innerHTML = parser.parse(text);
                } else {
                    messageDiv.textContent = text;
                }

                chatMessages.appendChild(messageDiv);
                chatMessages.scrollTop = chatMessages.scrollHeight;

                if (sender === 'ai' && this.world.aiManager && this.world.aiManager.isActive) {
                    this.world.aiManager.animateCompanionSpeaking();
                }
            }

            delay(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }
        }

        // AI Manager Class with Persistent Text Display
        class AIManager {
            constructor(worldInstance) {
                this.world = worldInstance;
                this.apiKey = null;
                this.endpoint = 'http://localhost:7071/api/businessinsightbot_function';
                this.conversationHistory = [];
                this.isActive = false;
                this.voicePaused = false;

                this.markdownParser = new MarkdownParser();

                this.voiceManager = new VoiceManager();
                this.voiceInputManager = null;

                this.settings = this.loadSettings();

                this.chatInterface = document.getElementById('ai-chat-interface');
                this.chatMessages = document.getElementById('ai-chat-messages');
                this.chatInput = document.getElementById('ai-chat-input');
                this.companionButton = document.getElementById('ai-companion-button');
                this.aiModal = document.getElementById('ai-modal');

                this.companion = null;
                this.textMeshes = [];
                this.font = null;
                this.textGroup = null;
                this.textContainer = null;
                this.inactiveText = null;
                this.persistentTextGroup = null; // New group for persistent text

                this.lastVoiceResponse = null;
                this.activeTextAnimation = null;

                this.setupEventListeners();
                this.checkCachedApiKey();
                this.applySettings();
                
                this.voiceInputManager = new VoiceInputManager(this);

                this.setupVoicePauseButton();
            }

            loadSettings() {
                if (this.world.settingsManager) {
                    const allSettings = this.world.settingsManager.settings;
                    return {
                        voiceEnabled: allSettings.voice.output.enabled,
                        autoSpeak: allSettings.voice.output.autoSpeak,
                        azureTTSKey: allSettings.voice.output.azureTTSKey,
                        ttsVoiceName: allSettings.voice.output.ttsVoiceName,
                        voiceInputEnabled: allSettings.voice.input.enabled,
                        continuousConversation: allSettings.voice.input.continuousConversation,
                        pushToTalkKey: allSettings.voice.input.pushToTalkKey
                    };
                }

                const settings = localStorage.getItem('nexusAISettings');
                return settings ? JSON.parse(settings) : {
                    voiceEnabled: true,
                    autoSpeak: false,
                    azureTTSKey: '',
                    ttsVoiceName: 'en-US-JennyNeural',
                    voiceInputEnabled: true,
                    continuousConversation: false,
                    pushToTalkKey: 'Space'
                };
            }

            saveSettings() {
                localStorage.setItem('nexusAISettings', JSON.stringify(this.settings));
            }

            applySettings() {
                this.voiceManager.setEnabled(this.settings.voiceEnabled);
                this.voiceManager.setAutoSpeak(this.settings.autoSpeak);
                this.voiceManager.setAzureKey(this.settings.azureTTSKey);
                this.voiceManager.setVoiceName(this.settings.ttsVoiceName);

                if (this.voiceInputManager) {
                    this.voiceInputManager.setEnabled(this.settings.voiceInputEnabled);
                    this.voiceInputManager.setContinuousMode(this.settings.continuousConversation);
                    this.voiceInputManager.setPushToTalkKey(this.settings.pushToTalkKey);
                }

                const voiceEnabledToggle = document.getElementById('voice-enabled-toggle');
                if (voiceEnabledToggle) {
                    voiceEnabledToggle.classList.toggle('active', this.settings.voiceEnabled);
                }

                const autoSpeakToggle = document.getElementById('auto-speak-toggle');
                if (autoSpeakToggle) {
                    autoSpeakToggle.classList.toggle('active', this.settings.autoSpeak);
                }

                const voiceInputEnabledToggle = document.getElementById('voice-input-enabled-toggle');
                if (voiceInputEnabledToggle) {
                    voiceInputEnabledToggle.classList.toggle('active', this.settings.voiceInputEnabled);
                }

                const continuousConversationToggle = document.getElementById('continuous-conversation-toggle');
                if (continuousConversationToggle) {
                    continuousConversationToggle.classList.toggle('active', this.settings.continuousConversation);
                }

                const azureTTSKeyInput = document.getElementById('azure-tts-key');
                if (azureTTSKeyInput && this.settings.azureTTSKey) {
                    azureTTSKeyInput.value = this.settings.azureTTSKey;
                }

                const ttsVoiceSelect = document.getElementById('tts-voice-select');
                if (ttsVoiceSelect) {
                    ttsVoiceSelect.value = this.settings.ttsVoiceName;
                }

                const voiceActivationKeySelect = document.getElementById('voice-activation-key');
                if (voiceActivationKeySelect) {
                    voiceActivationKeySelect.value = this.settings.pushToTalkKey;
                }
            }

            setupVoicePauseButton() {
                const pauseButton = document.getElementById('voice-pause-button');
                const pauseIndicator = document.getElementById('voice-paused-indicator');
                const pauseText = document.getElementById('voice-pause-text');

                pauseButton.addEventListener('click', () => {
                    this.voicePaused = !this.voicePaused;

                    if (this.voicePaused) {
                        this.voiceManager.setPaused(true);
                        this.voiceInputManager.setPaused(true);
                        
                        pauseButton.classList.add('paused');
                        pauseIndicator.classList.add('active');
                        pauseText.textContent = 'Resume Voice';
                        
                        this.showNotification('Voice activity paused for Teams call');
                    } else {
                        this.voiceManager.setPaused(false);
                        this.voiceInputManager.setPaused(false);
                        
                        pauseButton.classList.remove('paused');
                        pauseIndicator.classList.remove('active');
                        pauseText.textContent = 'Pause Voice';
                        
                        this.showNotification('Voice activity resumed');
                        
                        if (this.settings.continuousConversation && this.voiceInputManager) {
                            setTimeout(() => {
                                this.voiceInputManager.startListening();
                            }, 500);
                        }
                    }
                });

                window.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape' && this.isActive) {
                        pauseButton.click();
                    }
                });
            }

            async checkCachedApiKey() {
                const cachedApiKey = this.world.settingsManager ? 
                    this.world.settingsManager.settings.api.key :
                    localStorage.getItem('nexus_ai_api_key');
                    
                if (cachedApiKey) {
                    this.apiKey = cachedApiKey;
                    try {
                        const response = await this.sendToAPI('System check - testing cached API key.');
                        if (response.assistant_response) {
                            this.isActive = true;
                            this.companionButton.classList.add('active');
                            this.createAICompanion(true);
                            this.showNotification('AI Companion activated!');
                            
                            if (this.settings.continuousConversation && this.voiceInputManager && !this.voicePaused) {
                                this.voiceInputManager.startListening();
                            }
                        }
                    } catch (error) {
                        if (this.world.settingsManager) {
                            this.world.settingsManager.settings.api.key = '';
                        }
                        localStorage.removeItem('nexus_ai_api_key');
                        this.apiKey = null;
                        this.createAICompanion(false);
                    }
                } else {
                    this.createAICompanion(false);
                }
            }

            setupEventListeners() {
                this.companionButton.addEventListener('click', () => {
                    // Both presenter and viewers can open the chat
                    if (this.isActive) {
                        this.chatInterface.classList.toggle('active');
                        
                        // Broadcast AI interaction in show mode
                        if (this.world.showModeManager && this.world.showModeManager.isHost) {
                            this.world.showModeManager.broadcastAIInteraction('chat_opened');
                        }
                    } else {
                        // Only presenter can activate AI
                        if (!this.world.showModeManager || !this.world.showModeManager.isFollowing) {
                            this.aiModal.classList.add('show');
                        }
                    }
                });

                document.getElementById('ai-close').addEventListener('click', () => {
                    this.aiModal.classList.remove('show');
                });

                document.getElementById('ai-activate-btn').addEventListener('click', () => {
                    this.activateAI();
                });

                // Update the chat input event listener for viewers
                this.chatInput.addEventListener('keypress', (event) => {
                    if (event.key === 'Enter') {
                        // Check if we're a viewer
                        if (this.world.showModeManager && this.world.showModeManager.isFollowing) {
                            this.sendViewerMessage();
                        } else {
                            this.sendMessage();
                        }
                    }
                });

                // Update the send button click handler
                const sendButton = document.querySelector('.ai-chat-send');
                sendButton.onclick = () => {
                    if (this.world.showModeManager && this.world.showModeManager.isFollowing) {
                        this.sendViewerMessage();
                    } else {
                        this.sendMessage();
                    }
                };

                document.getElementById('voice-enabled-toggle').addEventListener('click', (e) => {
                    const isActive = e.target.classList.toggle('active');
                    this.settings.voiceEnabled = isActive;
                    this.saveSettings();
                    this.voiceManager.setEnabled(isActive);
                });

                document.getElementById('auto-speak-toggle').addEventListener('click', (e) => {
                    const isActive = e.target.classList.toggle('active');
                    this.settings.autoSpeak = isActive;
                    this.saveSettings();
                    this.voiceManager.setAutoSpeak(isActive);
                });

                document.getElementById('voice-input-enabled-toggle').addEventListener('click', (e) => {
                    const isActive = e.target.classList.toggle('active');
                    this.settings.voiceInputEnabled = isActive;
                    this.saveSettings();
                    if (this.voiceInputManager) {
                        this.voiceInputManager.setEnabled(isActive);
                    }
                });

                document.getElementById('continuous-conversation-toggle').addEventListener('click', (e) => {
                    const isActive = e.target.classList.toggle('active');
                    this.settings.continuousConversation = isActive;
                    this.saveSettings();
                    if (this.voiceInputManager) {
                        this.voiceInputManager.setContinuousMode(isActive);
                    }
                });

                document.getElementById('azure-tts-key').addEventListener('change', (e) => {
                    this.settings.azureTTSKey = e.target.value.trim();
                    this.saveSettings();
                    this.voiceManager.setAzureKey(this.settings.azureTTSKey);
                });

                document.getElementById('tts-voice-select').addEventListener('change', (e) => {
                    this.settings.ttsVoiceName = e.target.value;
                    this.saveSettings();
                    this.voiceManager.setVoiceName(this.settings.ttsVoiceName);
                });

                document.getElementById('voice-activation-key').addEventListener('change', (e) => {
                    this.settings.pushToTalkKey = e.target.value;
                    this.saveSettings();
                    if (this.voiceInputManager) {
                        this.voiceInputManager.setPushToTalkKey(this.settings.pushToTalkKey);
                    }
                });
            }

            // New method for viewers to send messages
            sendViewerMessage() {
                const message = this.chatInput.value.trim();
                if (!message) return;

                // Add the message locally
                this.addMessage(message, 'user');
                this.chatInput.value = '';

                // Send through show mode manager
                if (this.world.showModeManager) {
                    this.world.showModeManager.sendViewerMessage(message);
                }
            }

            async activateAI() {
                const apiKeyInput = document.getElementById('ai-api-key');
                const apiKey = apiKeyInput.value.trim();

                if (!apiKey) {
                    this.showNotification('Please enter an API key');
                    return;
                }

                this.apiKey = apiKey;

                try {
                    const response = await this.sendToAPI('Hello! I am your AI companion ready to assist you.');

                    if (response.assistant_response) {
                        this.isActive = true;
                        this.companionButton.classList.add('active');
                        this.aiModal.classList.remove('show');
                        this.showNotification('AI Companion activated!');
                        
                        // Save API key
                        if (this.world.settingsManager) {
                            this.world.settingsManager.settings.api.key = apiKey;
                            this.world.settingsManager.saveSettings();
                        } else {
                            localStorage.setItem('nexus_ai_api_key', apiKey);
                        }

                        // Update companion to active state
                        if (this.companion) {
                            this.companion.orb.material.color.setHex(0x06ffa5);
                            this.companion.orb.material.emissive.setHex(0x06ffa5);
                            this.companion.light.color.setHex(0x06ffa5);
                            if (this.inactiveText) {
                                this.companion.object.remove(this.inactiveText);
                                this.inactiveText = null;
                            }
                        }

                        this.addMessage(response.assistant_response, 'ai');
                        
                        if (response.voice_response) {
                            this.lastVoiceResponse = response.voice_response;
                            this.animateTextResponse(response.voice_response);
                            
                            if (this.settings.autoSpeak && !this.voicePaused) {
                                await this.voiceManager.speak(response.voice_response, this);
                            }
                        } else {
                            this.animateTextResponse(response.assistant_response);
                        }
                        
                        if (this.settings.continuousConversation && this.voiceInputManager && !this.voicePaused) {
                            setTimeout(() => {
                                this.voiceInputManager.startListening();
                            }, 2000);
                        }
                        
                        apiKeyInput.value = '';
                    }
                } catch (error) {
                    console.error('Failed to activate AI:', error);
                    this.showNotification('Failed to activate AI. Please check your API key.');
                }
            }

            createAICompanion(isActive = false) {
                const companionGroup = new THREE.Group();

                // Glowing orb
                const geometry = new THREE.SphereGeometry(1.5, 32, 32);
                const material = new THREE.MeshStandardMaterial({
                    color: isActive ? 0x06ffa5 : 0x666666,
                    emissive: isActive ? 0x06ffa5 : 0x666666,
                    emissiveIntensity: 0.5,
                    metalness: 0.8,
                    roughness: 0.2,
                    transparent: true,
                    opacity: 0.8
                });

                const orb = new THREE.Mesh(geometry, material);
                orb.position.y = 4;
                companionGroup.add(orb);

                // Make orb clickable
                orb.userData.clickable = true;
                orb.userData.isCompanion = true;

                // Glow effect
                const glowLight = new THREE.PointLight(isActive ? 0x06ffa5 : 0x666666, 2, 10);
                glowLight.position.y = 4;
                companionGroup.add(glowLight);

                // Particles around orb
                const particleGeometry = new THREE.BufferGeometry();
                const particleCount = 100;
                const positions = new Float32Array(particleCount * 3);

                for (let i = 0; i < particleCount * 3; i += 3) {
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.random() * Math.PI;
                    const radius = 2.5 + Math.random() * 1;

                    positions[i] = radius * Math.sin(phi) * Math.cos(theta);
                    positions[i + 1] = radius * Math.sin(phi) * Math.sin(theta) + 4;
                    positions[i + 2] = radius * Math.cos(phi);
                }

                particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

                const particleMaterial = new THREE.PointsMaterial({
                    color: isActive ? 0x8338ec : 0x444444,
                    size: 0.1,
                    transparent: true,
                    opacity: 0.6
                });

                const particles = new THREE.Points(particleGeometry, particleMaterial);
                companionGroup.add(particles);

                // Text display group
                this.textContainer = new THREE.Group();
                this.textGroup = new THREE.Group();
                this.textContainer.add(this.textGroup);
                this.textContainer.position.y = 7;
                companionGroup.add(this.textContainer);

                // Persistent text group
                this.persistentTextGroup = new THREE.Group();
                this.persistentTextGroup.position.y = 6.5;
                companionGroup.add(this.persistentTextGroup);

                // Add inactive text if not active
                if (!isActive) {
                    const loader = new THREE.FontLoader();
                    loader.load('https://threejs.org/examples/fonts/helvetiker_regular.typeface.json', (font) => {
                        const textGeometry = new THREE.TextGeometry('API Key Required', {
                            font: font,
                            size: 0.5,
                            height: 0.1,
                            curveSegments: 12,
                            bevelEnabled: true,
                            bevelThickness: 0.02,
                            bevelSize: 0.02,
                            bevelSegments: 8
                        });

                        textGeometry.center();

                        const textMaterial = new THREE.MeshStandardMaterial({
                            color: 0xff6a00,
                            emissive: 0xff6a00,
                            emissiveIntensity: 0.3
                        });

                        this.inactiveText = new THREE.Mesh(textGeometry, textMaterial);
                        this.inactiveText.position.y = 6;
                        companionGroup.add(this.inactiveText);
                    });
                }

                // Position companion in scene
                companionGroup.position.set(0, 0, -WORLD_ATTRIBUTES.companionDistance);
                
                // Rotate the companion to show higher
                companionGroup.rotation.x = THREE.MathUtils.degToRad(-20);
                
                this.world.scene.add(companionGroup);

                this.companion = {
                    object: companionGroup,
                    orb: orb,
                    particles: particles,
                    light: glowLight
                };

                // Load font for 3D text
                this.loadFont();

                // Animate companion
                this.animateCompanion();
            }

            loadFont() {
                const loader = new THREE.FontLoader();
                loader.load('https://threejs.org/examples/fonts/helvetiker_regular.typeface.json', (font) => {
                    this.font = font;
                });
            }

            animateCompanion() {
                const animate = () => {
                    if (!this.companion) return;

                    const time = Date.now() * 0.001;

                    // Float animation
                    this.companion.orb.position.y = 4 + Math.sin(time * 2) * 0.3;

                    // Rotate particles
                    this.companion.particles.rotation.y = time * 0.5;

                    // Pulse glow
                    this.companion.light.intensity = 2 + Math.sin(time * 3) * 0.5;

                    // Make text containers face camera
                    if (this.textContainer) {
                        this.textContainer.lookAt(this.world.camera.position);
                    }
                    
                    if (this.persistentTextGroup) {
                        this.persistentTextGroup.lookAt(this.world.camera.position);
                    }

                    // Rotate inactive text if present
                    if (this.inactiveText) {
                        this.inactiveText.rotation.y = Math.sin(time) * 0.1;
                        this.inactiveText.position.y = 6 + Math.sin(time * 3) * 0.1;
                    }

                    requestAnimationFrame(animate);
                };

                animate();
            }

            async sendToAPI(message) {
                const endpoint = this.world.settingsManager ? 
                    this.world.settingsManager.settings.api.endpoint : 
                    this.endpoint;
                    
                const headers = {
                    'Content-Type': 'application/json',
                    'x-functions-key': this.apiKey
                };

                // Updated to NOT send user_guid
                const body = {
                    user_input: message,
                    conversation_history: this.conversationHistory
                    // NO user_guid field
                };

                const response = await fetch(endpoint, {
                    method: 'POST',
                    headers: headers,
                    body: JSON.stringify(body)
                });

                if (!response.ok) {
                    throw new Error(`API request failed: ${response.status}`);
                }

                return await response.json();
            }

            async sendMessage() {
                const message = this.chatInput.value.trim();
                if (!message || !this.isActive) return;

                if (this.world.taskManager && this.world.taskManager.isReplaying) {
                    this.showNotification('Cannot send messages during conversation replay');
                    return;
                }

                this.addMessage(message, 'user');
                this.chatInput.value = '';

                // Broadcast AI interaction in show mode
                if (this.world.showModeManager && this.world.showModeManager.isHost) {
                    this.world.showModeManager.broadcastAIInteraction('message_sent');
                }

                this.showTypingIndicator();

                this.conversationHistory.push({
                    role: 'user',
                    content: message
                });

                try {
                    const response = await this.sendToAPI(message);

                    this.hideTypingIndicator();

                    if (response.assistant_response) {
                        this.addMessage(response.assistant_response, 'ai', response.voice_response);

                        this.conversationHistory.push({
                            role: 'assistant',
                            content: response.assistant_response
                        });

                        if (response.voice_response) {
                            this.lastVoiceResponse = response.voice_response;
                            this.animateTextResponse(response.voice_response);
                            
                            if (this.settings.autoSpeak && !this.voicePaused) {
                                await this.voiceManager.speak(response.voice_response, this);
                                
                                if (this.settings.continuousConversation && this.voiceInputManager && !this.voicePaused) {
                                    setTimeout(() => {
                                        this.voiceInputManager.startListening();
                                    }, 500);
                                }
                            }
                        } else {
                            this.animateTextResponse(response.assistant_response);
                        }
                    }
                } catch (error) {
                    console.error('Failed to send message:', error);
                    this.hideTypingIndicator();
                    this.addMessage('Sorry, I encountered an error. Please try again.', 'ai');
                }
            }

            animateTextResponse(text) {
                if (this.activeTextAnimation) {
                    cancelAnimationFrame(this.activeTextAnimation);
                    this.activeTextAnimation = null;
                }

                // Clear only the scrolling text meshes, not persistent ones
                this.textMeshes.forEach(mesh => {
                    if (mesh.geometry) mesh.geometry.dispose();
                    if (mesh.material) mesh.material.dispose();
                    this.textGroup.remove(mesh);
                });
                this.textMeshes = [];

                if (!this.font || !this.textGroup) return;

                const maxCharsPerLine = 40;
                const words = text.split(' ');
                const lines = [];
                let currentLine = '';

                words.forEach(word => {
                    if ((currentLine + word).length > maxCharsPerLine) {
                        if (currentLine) {
                            lines.push(currentLine.trim());
                            currentLine = '';
                        }
                    }
                    currentLine += word + ' ';
                });
                if (currentLine) {
                    lines.push(currentLine.trim());
                }

                const lineHeight = 0.8;
                const textMaterial = new THREE.MeshStandardMaterial({
                    color: 0xffffff,
                    emissive: 0x06ffa5,
                    emissiveIntensity: 0.5,
                    metalness: 0.5,
                    roughness: 0.3,
                    transparent: true,
                    opacity: 1
                });

                lines.forEach((line, index) => {
                    const textGeometry = new THREE.TextGeometry(line, {
                        font: this.font,
                        size: 0.4,
                        height: 0.05,
                        curveSegments: 12,
                        bevelEnabled: true,
                        bevelThickness: 0.01,
                        bevelSize: 0.01,
                        bevelSegments: 8
                    });

                    textGeometry.center();

                    const textMesh = new THREE.Mesh(textGeometry, textMaterial.clone());
                    textMesh.position.y = -index * lineHeight;
                    
                    this.textGroup.add(textMesh);
                    this.textMeshes.push(textMesh);
                });

                const totalHeight = lines.length * lineHeight;
                this.animateScrollingText(totalHeight, text);
            }

            animateScrollingText(totalHeight, fullText) {
                const scrollSpeed = 0.01;
                const startY = -3;
                const endY = totalHeight + 3;
                let currentY = startY;

                const animate = () => {
                    if (!this.textGroup || this.textMeshes.length === 0) return;

                    currentY += scrollSpeed;
                    this.textGroup.position.y = currentY;

                    if (currentY > endY) {
                        // When scrolling ends, keep the text visible
                        this.createPersistentText(fullText);
                        this.fadeOutText();
                        return;
                    }

                    this.textMeshes.forEach((mesh, index) => {
                        const meshWorldY = currentY - index * 0.8;
                        
                        if (meshWorldY < -1.5) {
                            mesh.material.opacity = Math.max(0, 1 + meshWorldY / 1.5);
                        }
                        else if (meshWorldY > 1.5) {
                            mesh.material.opacity = Math.max(0, 2 - meshWorldY / 1.5);
                        }
                        else {
                            mesh.material.opacity = 1;
                        }
                    });

                    this.activeTextAnimation = requestAnimationFrame(animate);
                };

                animate();
            }

            createPersistentText(text) {
                // Clear existing persistent text
                this.persistentTextGroup.children.forEach(child => {
                    if (child.geometry) child.geometry.dispose();
                    if (child.material) child.material.dispose();
                });
                this.persistentTextGroup.clear();

                if (!this.font) return;

                // Create a condensed version of the text for persistent display
                const maxLength = 100;
                const displayText = text.length > maxLength ? text.substring(0, maxLength) + '...' : text;
                
                const lines = [];
                const maxCharsPerLine = 35;
                const words = displayText.split(' ');
                let currentLine = '';

                words.forEach(word => {
                    if ((currentLine + word).length > maxCharsPerLine) {
                        if (currentLine) {
                            lines.push(currentLine.trim());
                            currentLine = '';
                        }
                    }
                    currentLine += word + ' ';
                });
                if (currentLine) {
                    lines.push(currentLine.trim());
                }

                // Limit to 3 lines
                const displayLines = lines.slice(0, 3);
                if (lines.length > 3) {
                    displayLines[2] = displayLines[2].substring(0, displayLines[2].length - 3) + '...';
                }

                const lineHeight = 0.6;
                const persistentMaterial = new THREE.MeshStandardMaterial({
                    color: 0xffffff,
                    emissive: 0x06ffa5,
                    emissiveIntensity: 0.2,
                    metalness: 0.3,
                    roughness: 0.5,
                    transparent: true,
                    opacity: 0.8
                });

                displayLines.forEach((line, index) => {
                    const textGeometry = new THREE.TextGeometry(line, {
                        font: this.font,
                        size: 0.3,
                        height: 0.03,
                        curveSegments: 8,
                        bevelEnabled: true,
                        bevelThickness: 0.01,
                        bevelSize: 0.01,
                        bevelSegments: 5
                    });

                    textGeometry.center();

                    const textMesh = new THREE.Mesh(textGeometry, persistentMaterial);
                    textMesh.position.y = -index * lineHeight;
                    
                    this.persistentTextGroup.add(textMesh);
                });

                // Center the persistent text group
                this.persistentTextGroup.position.y = 6.5 + (displayLines.length * lineHeight) / 2;
            }

            fadeOutText() {
                let opacity = 1;
                const fadeSpeed = 0.02;
                const fade = () => {
                    opacity -= fadeSpeed;
                    
                    if (opacity <= 0) {
                        this.textMeshes.forEach(mesh => {
                            if (mesh.geometry) mesh.geometry.dispose();
                            if (mesh.material) mesh.material.dispose();
                            this.textGroup.remove(mesh);
                        });
                        this.textMeshes = [];
                        this.textGroup.position.y = 0;
                        return;
                    }

                    this.textMeshes.forEach(mesh => {
                        mesh.material.opacity = opacity;
                    });

                    requestAnimationFrame(fade);
                };

                fade();
            }

            animateCompanionSpeaking() {
                if (!this.companion) return;

                const originalScale = this.companion.orb.scale.x;
                let progress = 0;
                const animate = () => {
                    progress += 0.1;
                    if (progress > 1) return;

                    const scale = originalScale + Math.sin(progress * Math.PI) * 0.3;
                    this.companion.orb.scale.setScalar(scale);

                    this.companion.light.intensity = 3 + Math.sin(progress * Math.PI * 2) * 1;
                    this.companion.orb.material.emissiveIntensity = 0.5 + Math.sin(progress * Math.PI) * 0.3;

                    requestAnimationFrame(animate);
                };
                animate();
            }

            showTypingIndicator() {
                const typingDiv = document.createElement('div');
                typingDiv.className = 'ai-typing';
                typingDiv.id = 'ai-typing-indicator';
                typingDiv.innerHTML = `
                    <div class="typing-dot"></div>
                    <div class="typing-dot"></div>
                    <div class="typing-dot"></div>
                `;
                this.chatMessages.appendChild(typingDiv);
                this.chatMessages.scrollTop = this.chatMessages.scrollHeight;
                
                // Broadcast typing indicator
                if (this.world.showModeManager && this.world.showModeManager.isHost) {
                    this.world.showModeManager.broadcastTypingIndicator(true);
                }
            }

            hideTypingIndicator() {
                const typingIndicator = document.getElementById('ai-typing-indicator');
                if (typingIndicator) {
                    typingIndicator.remove();
                }
                
                // Broadcast typing indicator off
                if (this.world.showModeManager && this.world.showModeManager.isHost) {
                    this.world.showModeManager.broadcastTypingIndicator(false);
                }
            }

            addMessage(text, sender, voiceResponse = null) {
                const messageDiv = document.createElement('div');
                messageDiv.className = `ai-message ${sender}`;
                
                if (sender === 'ai') {
                    // Parse markdown for AI messages
                    messageDiv.innerHTML = this.markdownParser.parse(text);
                } else {
                    messageDiv.textContent = text;
                }

                this.chatMessages.appendChild(messageDiv);
                this.chatMessages.scrollTop = this.chatMessages.scrollHeight;
                
                // Broadcast chat message in show mode (only if we're the host)
                if (this.world.showModeManager && this.world.showModeManager.isHost) {
                    this.world.showModeManager.broadcastChatMessage(sender, messageDiv.innerHTML, voiceResponse);
                }
            }

            showNotification(message) {
                const notification = document.createElement('div');
                notification.className = 'notification';
                notification.textContent = message;

                document.body.appendChild(notification);

                setTimeout(() => {
                    notification.style.animation = 'slideOut 0.3s ease';
                    setTimeout(() => notification.remove(), 300);
                }, 3000);
            }
        }

        // Add Font and TextGeometry support to THREE
        THREE.FontLoader = class FontLoader extends THREE.Loader {
            constructor(manager) {
                super(manager);
            }

            load(url, onLoad, onProgress, onError) {
                const scope = this;
                const loader = new THREE.FileLoader(this.manager);
                loader.setPath(this.path);
                loader.setRequestHeader(this.requestHeader);
                loader.setWithCredentials(this.withCredentials);
                loader.load(url, function(text) {
                    try {
                        const json = JSON.parse(text);
                        const font = scope.parse(json);
                        if (onLoad) onLoad(font);
                    } catch (e) {
                        if (onError) onError(e);
                    }
                }, onProgress, onError);
            }

            parse(json) {
                return new THREE.Font(json);
            }
        };

        THREE.Font = class Font {
            constructor(data) {
                this.type = 'Font';
                this.data = data;
            }

            generateShapes(text, size = 100) {
                const shapes = [];
                const paths = createPaths(text, size, this.data);

                for (let p = 0, pl = paths.length; p < pl; p++) {
                    Array.prototype.push.apply(shapes, paths[p].toShapes());
                }

                return shapes;
            }
        };

        THREE.TextGeometry = class TextGeometry extends THREE.ExtrudeGeometry {
            constructor(text, parameters = {}) {
                const font = parameters.font;

                if (!font || !font.data) {
                    console.error('THREE.TextGeometry: font parameter is not an instance of THREE.Font.');
                    super();
                    return;
                }

                const shapes = font.generateShapes(text, parameters.size);

                parameters.depth = parameters.height !== undefined ? parameters.height : 50;

                if (parameters.bevelThickness === undefined) parameters.bevelThickness = 10;
                if (parameters.bevelSize === undefined) parameters.bevelSize = 8;
                if (parameters.bevelEnabled === undefined) parameters.bevelEnabled = false;

                super(shapes, parameters);

                this.type = 'TextGeometry';
            }
        };

        function createPaths(text, size, data) {
            const chars = Array.from(text);
            const scale = size / data.resolution;
            const line_height = (data.boundingBox.yMax - data.boundingBox.yMin + data.underlineThickness) * scale;

            const paths = [];

            let offsetX = 0, offsetY = 0;

            for (let i = 0; i < chars.length; i++) {
                const char = chars[i];

                if (char === '\n') {
                    offsetX = 0;
                    offsetY -= line_height;
                } else {
                    const ret = createPath(char, scale, offsetX, offsetY, data);
                    if (ret) {
                        offsetX += ret.offsetX;
                        paths.push(ret.path);
                    }
                }
            }

            return paths;
        }

        function createPath(char, scale, offsetX, offsetY, data) {
            const glyph = data.glyphs[char] || data.glyphs['?'];

            if (!glyph) {
                console.error('THREE.Font: character "' + char + '" does not exists in font family ' + data.familyName + '.');
                return;
            }

            const path = new THREE.ShapePath();

            let x, y, cpx, cpy, cpx1, cpy1, cpx2, cpy2;

            if (glyph.o) {
                const outline = glyph._cachedOutline || (glyph._cachedOutline = glyph.o.split(' '));

                for (let i = 0, l = outline.length; i < l;) {
                    const action = outline[i++];

                    switch (action) {
                        case 'm':
                            x = outline[i++] * scale + offsetX;
                            y = outline[i++] * scale + offsetY;
                            path.moveTo(x, y);
                            break;

                        case 'l':
                            x = outline[i++] * scale + offsetX;
                            y = outline[i++] * scale + offsetY;
                            path.lineTo(x, y);
                            break;

                        case 'q':
                            cpx = outline[i++] * scale + offsetX;
                            cpy = outline[i++] * scale + offsetY;
                            cpx1 = outline[i++] * scale + offsetX;
                            cpy1 = outline[i++] * scale + offsetY;
                            path.quadraticCurveTo(cpx1, cpy1, cpx, cpy);
                            break;

                        case 'b':
                            cpx = outline[i++] * scale + offsetX;
                            cpy = outline[i++] * scale + offsetY;
                            cpx1 = outline[i++] * scale + offsetX;
                            cpy1 = outline[i++] * scale + offsetY;
                            cpx2 = outline[i++] * scale + offsetX;
                            cpy2 = outline[i++] * scale + offsetY;
                            path.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, cpx, cpy);
                            break;
                    }
                }
            }

            return { offsetX: glyph.ha * scale, path: path };
        }

        // World Navigator Class
        class WorldNavigator {
            constructor() {
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.raycaster = new THREE.Raycaster();
                this.mouse = new THREE.Vector2();
                this.clock = new THREE.Clock();

                this.isMobile = isMobile;
                this.isIOS = isIOS;

                this.aiManager = null;
                this.taskManager = null;
                this.settingsManager = null;
                this.perspectiveManager = null;
                this.showModeManager = null;
                this.wristInterface = null;

                this.tooltip = document.getElementById('companion-tooltip');

                if (this.isIOS) {
                    document.body.addEventListener('touchmove', (e) => {
                        if (e.target === document.body) {
                            e.preventDefault();
                        }
                    }, { passive: false });
                }
            }

            init() {
                setTimeout(() => {
                    document.getElementById('loading').style.display = 'none';
                }, 1000);

                this.setupScene();
                this.setupLighting();
                this.createEnvironment();
                this.setupEventListeners();

                // Initialize Settings Manager first
                this.settingsManager = new SettingsManager(this);

                // Initialize Perspective Manager
                this.perspectiveManager = new PerspectiveManager(this);

                // Initialize Show Mode Manager
                this.showModeManager = new ShowModeManager(this);

                // Initialize AI manager
                this.aiManager = new AIManager(this);

                // Initialize Task Manager
                this.taskManager = new TaskManager(this);

                // Initialize Wrist Interface
                this.wristInterface = new WristInterface(this);

                // Apply saved settings
                if (this.settingsManager.settings.perspective) {
                    this.perspectiveManager.applySettings(this.settingsManager.settings.perspective);
                }

                // Make WorldNavigator globally accessible
                window.worldNavigator = this;

                this.animate();
            }

            setupScene() {
                this.scene = new THREE.Scene();
                this.scene.fog = new THREE.Fog(WORLD_ATTRIBUTES.fogColor, WORLD_ATTRIBUTES.fogNear, WORLD_ATTRIBUTES.fogFar);

                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.camera.position.set(0, WORLD_ATTRIBUTES.cameraPositionY, WORLD_ATTRIBUTES.cameraPositionZ);
                this.camera.lookAt(0, 3, 0);

                this.renderer = new THREE.WebGLRenderer({ 
                    antialias: true, 
                    alpha: true,
                    powerPreference: "high-performance"
                });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                document.getElementById('three-container').appendChild(this.renderer.domElement);
            }

            setupLighting() {
                const ambientLight = new THREE.AmbientLight(WORLD_ATTRIBUTES.ambientColor, 0.6);
                this.scene.add(ambientLight);

                const dirLight = new THREE.DirectionalLight(0x8338ec, 0.8);
                dirLight.position.set(10, 20, 10);
                dirLight.castShadow = true;
                this.scene.add(dirLight);

                // Add spotlight focused on where companion will be
                const spotLight = new THREE.SpotLight(0x06ffa5, 1, 30, Math.PI / 6, 0.5, 2);
                spotLight.position.set(0, 10, -5);
                spotLight.target.position.set(0, 0, -WORLD_ATTRIBUTES.companionDistance);
                this.scene.add(spotLight);
                this.scene.add(spotLight.target);
            }

            createEnvironment() {
                // Ground with grid pattern
                const groundGeometry = new THREE.PlaneGeometry(100, 100, 50, 50);
                const groundMaterial = new THREE.MeshStandardMaterial({
                    color: WORLD_ATTRIBUTES.groundColor,
                    roughness: 0.8,
                    metalness: 0.2,
                    wireframe: true,
                    transparent: true,
                    opacity: 0.3
                });

                const ground = new THREE.Mesh(groundGeometry, groundMaterial);
                ground.rotation.x = -Math.PI / 2;
                ground.receiveShadow = true;
                this.scene.add(ground);

                // Solid ground beneath
                const solidGroundGeometry = new THREE.PlaneGeometry(100, 100);
                const solidGroundMaterial = new THREE.MeshStandardMaterial({
                    color: 0x0a0a0f,
                    roughness: 1,
                    metalness: 0
                });

                const solidGround = new THREE.Mesh(solidGroundGeometry, solidGroundMaterial);
                solidGround.rotation.x = -Math.PI / 2;
                solidGround.position.y = -0.1;
                this.scene.add(solidGround);

                // Sky sphere
                const skyGeometry = new THREE.SphereGeometry(200, 32, 32);
                const skyMaterial = new THREE.MeshBasicMaterial({
                    color: WORLD_ATTRIBUTES.skyColor,
                    side: THREE.BackSide
                });
                const sky = new THREE.Mesh(skyGeometry, skyMaterial);
                this.scene.add(sky);

                // Floating particles
                const particleGeometry = new THREE.BufferGeometry();
                const particleCount = WORLD_ATTRIBUTES.particleCount;
                const positions = new Float32Array(particleCount * 3);
                const colors = new Float32Array(particleCount * 3);

                for (let i = 0; i < particleCount * 3; i += 3) {
                    positions[i] = (Math.random() - 0.5) * 80;
                    positions[i + 1] = Math.random() * 30 + 5;
                    positions[i + 2] = (Math.random() - 0.5) * 80;

                    // Random colors in purple/cyan range
                    colors[i] = Math.random() * 0.5 + 0.5;
                    colors[i + 1] = Math.random() * 0.5;
                    colors[i + 2] = Math.random() * 0.5 + 0.5;
                }

                particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                particleGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

                const particleMaterial = new THREE.PointsMaterial({
                    size: 0.2,
                    transparent: true,
                    opacity: 0.8,
                    vertexColors: true,
                    blending: THREE.AdditiveBlending
                });

                const particles = new THREE.Points(particleGeometry, particleMaterial);
                this.scene.add(particles);
            }

            setupEventListeners() {
                window.addEventListener('resize', () => {
                    this.camera.aspect = window.innerWidth / window.innerHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                });

                // Mouse move for hover detection
                window.addEventListener('mousemove', (event) => {
                    this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                    this.mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
                    
                    this.checkHover();
                });

                // Click event
                this.renderer.domElement.addEventListener('click', (event) => {
                    this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                    this.mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
                    
                    this.checkClick();
                });

                // Touch events for mobile
                if (this.isMobile) {
                    this.renderer.domElement.addEventListener('touchstart', (event) => {
                        const touch = event.touches[0];
                        this.mouse.x = (touch.clientX / window.innerWidth) * 2 - 1;
                        this.mouse.y = -(touch.clientY / window.innerHeight) * 2 + 1;
                        
                        this.checkClick();
                    });
                }
            }

            checkHover() {
                // Don't show hover for viewers
                if (this.showModeManager && this.showModeManager.isFollowing) {
                    return;
                }
                
                this.raycaster.setFromCamera(this.mouse, this.camera);
                const intersects = this.raycaster.intersectObjects(this.scene.children, true);

                let foundCompanion = false;

                for (const intersect of intersects) {
                    if (intersect.object.userData.isCompanion) {
                        foundCompanion = true;
                        this.renderer.domElement.style.cursor = 'pointer';
                        
                        // Show tooltip
                        const vector = new THREE.Vector3();
                        intersect.object.getWorldPosition(vector);
                        vector.project(this.camera);
                        
                        const x = (vector.x * 0.5 + 0.5) * window.innerWidth;
                        const y = (-(vector.y * 0.5) + 0.5) * window.innerHeight;
                        
                        this.tooltip.style.left = x + 'px';
                        this.tooltip.style.top = (y - 40) + 'px';
                        this.tooltip.classList.add('visible');
                        
                        break;
                    }
                }

                if (!foundCompanion) {
                    this.renderer.domElement.style.cursor = 'default';
                    this.tooltip.classList.remove('visible');
                }
            }

            checkClick() {
                // Viewers can't click to interact with the 3D companion
                if (this.showModeManager && this.showModeManager.isFollowing) {
                    return;
                }
                
                this.raycaster.setFromCamera(this.mouse, this.camera);
                const intersects = this.raycaster.intersectObjects(this.scene.children, true);

                for (const intersect of intersects) {
                    if (intersect.object.userData.isCompanion) {
                        if (this.aiManager.isActive) {
                            // Open chat interface
                            document.getElementById('ai-chat-interface').classList.add('active');
                            
                            // Broadcast AI interaction in show mode
                            if (this.showModeManager && this.showModeManager.isHost) {
                                this.showModeManager.broadcastAIInteraction('chat_opened');
                            }
                        } else {
                            // Open API key modal
                            document.getElementById('ai-modal').classList.add('show');
                        }
                        break;
                    }
                }
            }

            showNotification(message) {
                const notification = document.createElement('div');
                notification.className = 'notification';
                notification.textContent = message;

                document.body.appendChild(notification);

                setTimeout(() => {
                    notification.style.animation = 'slideOut 0.3s ease';
                    setTimeout(() => notification.remove(), 300);
                }, 3000);
            }

            animate() {
                requestAnimationFrame(() => this.animate());

                const time = this.clock.getElapsedTime();

                // Animate particles
                const particles = this.scene.getObjectByProperty('type', 'Points');
                if (particles) {
                    particles.rotation.y = time * 0.05;
                    particles.position.y = Math.sin(time * 0.2) * 2;
                }

                // Update show mode
                if (this.showModeManager) {
                    this.showModeManager.update();
                }

                this.renderer.render(this.scene, this.camera);
            }
        }

        // Initialize on load
        window.addEventListener('DOMContentLoaded', () => {
            const navigator = new WorldNavigator();
            navigator.init();
        });

        // Force load voices for speech synthesis
        if ('speechSynthesis' in window) {
            speechSynthesis.getVoices();
            window.speechSynthesis.onvoiceschanged = () => {
                speechSynthesis.getVoices();
            };
        }

        // iOS specific handling
        let lastY = 0;
        window.addEventListener('touchstart', (e) => {
            lastY = e.touches[0].clientY;
        }, { passive: true });

        window.addEventListener('touchmove', (e) => {
            const y = e.touches[0].clientY;
            const scrollingUp = y > lastY;
            const atTop = window.pageYOffset === 0;

            if (scrollingUp && atTop) {
                e.preventDefault();
            }
            lastY = y;
        }, { passive: false });
    </script>
</body>
</html>