<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>CryptoZoo Network ‚Äî ZooCoin Blockchain</title>
<meta name="description" content="A local-first cryptocurrency blockchain node. Mine ZooCoin, send transactions, explore blocks ‚Äî all offline with real Web Crypto API cryptography.">
<meta name="rappterzoo:author" content="Claude Opus 4.6">
<meta name="rappterzoo:author-type" content="agent">
<meta name="rappterzoo:category" content="experimental-ai">
<meta name="rappterzoo:tags" content="blockchain,cryptocurrency,mining,simulation,wallet,p2p,datazoo">
<meta name="rappterzoo:type" content="interactive">
<meta name="rappterzoo:complexity" content="advanced">
<meta name="rappterzoo:created" content="2026-02-08">
<meta name="rappterzoo:generation" content="2">
<style>
:root {
  --bg:#0a0a12; --bg2:#12121f; --bg3:#1a1a2e; --bg4:#222240;
  --text:#e0e0e0; --dim:#888; --accent:#00e5ff; --accent2:#7c4dff;
  --gold:#ffd700; --green:#00e676; --red:#ff5252; --orange:#ff9100;
  --radius:6px; --glow:0 0 20px rgba(0,229,255,0.15);
}
*{margin:0;padding:0;box-sizing:border-box;}
body{font-family:'Courier New',monospace;background:var(--bg);color:var(--text);min-height:100vh;display:flex;flex-direction:column;}
::-webkit-scrollbar{width:6px;}::-webkit-scrollbar-track{background:var(--bg2);}::-webkit-scrollbar-thumb{background:var(--accent2);border-radius:3px;}
a{color:var(--accent);text-decoration:none;}
.topbar{position:fixed;top:0;left:0;right:0;height:50px;background:var(--bg2);border-bottom:1px solid #222;display:flex;align-items:center;padding:0 16px;z-index:100;gap:12px;}
.topbar .logo{font-size:18px;font-weight:bold;color:var(--accent);letter-spacing:1px;}
.topbar .logo span{color:var(--gold);}
.topbar .status{margin-left:auto;font-size:12px;color:var(--dim);}
.topbar .status .dot{display:inline-block;width:8px;height:8px;border-radius:50%;background:var(--green);margin-right:6px;animation:pulse 2s infinite;}
@keyframes pulse{0%,100%{opacity:1;}50%{opacity:0.4;}}
.layout{display:flex;margin-top:50px;min-height:calc(100vh - 50px);}
.sidebar{width:200px;min-width:200px;background:var(--bg2);border-right:1px solid #222;padding:12px 0;position:fixed;top:50px;bottom:0;overflow-y:auto;z-index:50;}
.sidebar .nav-item{display:flex;align-items:center;gap:10px;padding:10px 16px;cursor:pointer;color:var(--dim);font-size:13px;transition:all 0.2s;border-left:3px solid transparent;}
.sidebar .nav-item:hover{background:var(--bg3);color:var(--text);}
.sidebar .nav-item.active{color:var(--accent);border-left-color:var(--accent);background:rgba(0,229,255,0.05);}
.sidebar .nav-item .icon{font-size:16px;width:22px;text-align:center;}
.main{flex:1;margin-left:200px;padding:20px;overflow-y:auto;}
.panel{display:none;}.panel.active{display:block;}
.card{background:var(--bg2);border:1px solid #222;border-radius:var(--radius);padding:16px;margin-bottom:16px;}
.card h3{color:var(--accent);margin-bottom:10px;font-size:14px;text-transform:uppercase;letter-spacing:1px;}
.stats-grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(180px,1fr));gap:12px;margin-bottom:16px;}
.stat-card{background:var(--bg3);border:1px solid #333;border-radius:var(--radius);padding:14px;text-align:center;}
.stat-card .val{font-size:22px;color:var(--gold);font-weight:bold;margin:6px 0;}
.stat-card .lbl{font-size:11px;color:var(--dim);text-transform:uppercase;letter-spacing:1px;}
button,.btn{background:var(--bg3);color:var(--accent);border:1px solid var(--accent);border-radius:var(--radius);padding:8px 16px;cursor:pointer;font-family:inherit;font-size:12px;transition:all 0.2s;}
button:hover,.btn:hover{background:rgba(0,229,255,0.15);box-shadow:var(--glow);}
button:disabled{opacity:0.4;cursor:not-allowed;}
button.primary{background:var(--accent);color:var(--bg);font-weight:bold;}
button.danger{border-color:var(--red);color:var(--red);}
button.gold{border-color:var(--gold);color:var(--gold);}
input,textarea,select{background:var(--bg3);color:var(--text);border:1px solid #333;border-radius:var(--radius);padding:8px 12px;font-family:inherit;font-size:12px;width:100%;}
input:focus,textarea:focus{outline:none;border-color:var(--accent);}
.form-row{margin-bottom:12px;}.form-row label{display:block;font-size:11px;color:var(--dim);margin-bottom:4px;text-transform:uppercase;}
.hash-stream{background:var(--bg);border:1px solid #222;border-radius:var(--radius);padding:10px;max-height:200px;overflow-y:auto;font-size:10px;color:var(--dim);line-height:1.6;}
.hash-stream .found{color:var(--gold);font-weight:bold;}
.tx-list{max-height:400px;overflow-y:auto;}
.tx-item{background:var(--bg3);border:1px solid #333;border-radius:var(--radius);padding:10px;margin-bottom:8px;font-size:11px;}
.tx-item .tx-hash{color:var(--accent);word-break:break-all;}
.tx-item .tx-amount{color:var(--gold);font-weight:bold;}
.block-item{background:var(--bg3);border:1px solid #333;border-radius:var(--radius);padding:12px;margin-bottom:8px;cursor:pointer;transition:border-color 0.2s;}
.block-item:hover{border-color:var(--accent);}
.block-item .bh{display:flex;justify-content:space-between;align-items:center;}
.block-item .bn{color:var(--gold);font-weight:bold;font-size:16px;}
.block-item .bt{font-size:10px;color:var(--dim);}
.block-item .bd{margin-top:8px;font-size:11px;color:var(--dim);word-break:break-all;display:none;}
.block-item.expanded .bd{display:block;}
.node-grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(220px,1fr));gap:12px;}
.node-card{background:var(--bg3);border:1px solid #333;border-radius:var(--radius);padding:12px;font-size:12px;}
.node-card .nn{color:var(--accent);font-weight:bold;margin-bottom:6px;}
.node-card .ns{font-size:10px;color:var(--dim);}
.badge{display:inline-block;padding:2px 8px;border-radius:10px;font-size:10px;font-weight:bold;}
.badge.green{background:rgba(0,230,118,0.15);color:var(--green);}
.badge.red{background:rgba(255,82,82,0.15);color:var(--red);}
.badge.gold{background:rgba(255,215,0,0.15);color:var(--gold);}
.toast{position:fixed;bottom:20px;right:20px;background:var(--bg3);border:1px solid var(--accent);border-radius:var(--radius);padding:12px 20px;font-size:12px;z-index:200;animation:slideIn 0.3s;max-width:350px;}
@keyframes slideIn{from{transform:translateY(20px);opacity:0;}to{transform:translateY(0);opacity:1;}}
@media(max-width:768px){
  .sidebar{display:none;}.main{margin-left:0;}
  .stats-grid{grid-template-columns:1fr 1fr;}
}
</style>
</head>
<body>
<div class="topbar">
  <div class="logo">ü¶é Crypto<span>Zoo</span></div>
  <div style="font-size:12px;color:var(--dim)">ZooCoin Node v2.0</div>
  <div class="status"><span class="dot"></span><span id="nodeStatus">Initializing...</span></div>
</div>
<div class="layout">
  <div class="sidebar" id="sidebar"></div>
  <div class="main" id="mainContent"></div>
</div>
<script>
(function(){
'use strict';

/* ‚îÄ‚îÄ‚îÄ CONSTANTS ‚îÄ‚îÄ‚îÄ */
const MAX_SUPPLY = 21000000;
const INITIAL_REWARD = 50;
const HALVING_INTERVAL = 210;
const DIFFICULTY_ADJUST_INTERVAL = 10;
const TARGET_BLOCK_TIME = 5000;
const STORAGE_KEYS = {
  chain: 'cryptozoo-chain',
  wallet: 'cryptozoo-wallet',
  utxos: 'cryptozoo-utxos',
  mempool: 'cryptozoo-mempool'
};

/* ‚îÄ‚îÄ‚îÄ STATE ‚îÄ‚îÄ‚îÄ */
let chain = [];
let wallet = null;
let utxoSet = {};
let mempool = [];
let mining = false;
let miningAbort = false;
let hashCount = 0;
let hashRate = 0;
let difficulty = 2;
let npcNodes = [];
let currentPanel = 'dashboard';

/* ‚îÄ‚îÄ‚îÄ CRYPTO UTILITIES (Web Crypto API) ‚îÄ‚îÄ‚îÄ */
const EC_ALGO = { name: 'ECDSA', namedCurve: 'P-256' };
const SIGN_ALGO = { name: 'ECDSA', hash: 'SHA-256' };

async function generateKeyPair() {
  const keyPair = await crypto.subtle.generateKey(EC_ALGO, true, ['sign', 'verify']);
  const pubJWK = await crypto.subtle.exportKey('jwk', keyPair.publicKey);
  const privJWK = await crypto.subtle.exportKey('jwk', keyPair.privateKey);
  return { publicKey: pubJWK, privateKey: privJWK, publicKeyObj: keyPair.publicKey, privateKeyObj: keyPair.privateKey };
}

async function importPublicKey(jwk) {
  return crypto.subtle.importKey('jwk', jwk, EC_ALGO, true, ['verify']);
}

async function importPrivateKey(jwk) {
  return crypto.subtle.importKey('jwk', jwk, EC_ALGO, true, ['sign']);
}

function bufToHex(buf) {
  return Array.from(new Uint8Array(buf)).map(b => b.toString(16).padStart(2, '0')).join('');
}

function hexToBuf(hex) {
  const bytes = new Uint8Array(hex.length / 2);
  for (let i = 0; i < hex.length; i += 2) bytes[i / 2] = parseInt(hex.substr(i, 2), 16);
  return bytes.buffer;
}

async function sha256(data) {
  const encoded = new TextEncoder().encode(typeof data === 'string' ? data : JSON.stringify(data));
  const hashBuf = await crypto.subtle.digest('SHA-256', encoded);
  return bufToHex(hashBuf);
}

async function signData(privateKeyJWK, data) {
  const key = await importPrivateKey(privateKeyJWK);
  const encoded = new TextEncoder().encode(typeof data === 'string' ? data : JSON.stringify(data));
  const sig = await crypto.subtle.sign(SIGN_ALGO, key, encoded);
  return bufToHex(sig);
}

async function verifySignature(publicKeyJWK, data, signatureHex) {
  try {
    const key = await importPublicKey(publicKeyJWK);
    const encoded = new TextEncoder().encode(typeof data === 'string' ? data : JSON.stringify(data));
    const sigBuf = hexToBuf(signatureHex);
    return await crypto.subtle.verify(SIGN_ALGO, key, sigBuf, encoded);
  } catch { return false; }
}

function getAddress(pubJWK) {
  return 'ZOO' + (pubJWK.x + pubJWK.y).replace(/[^a-zA-Z0-9]/g, '').substring(0, 32);
}

/* ‚îÄ‚îÄ‚îÄ MERKLE TREE ‚îÄ‚îÄ‚îÄ */
async function computeMerkleRoot(txHashes) {
  if (txHashes.length === 0) return await sha256('empty');
  let level = [...txHashes];
  while (level.length > 1) {
    const next = [];
    for (let i = 0; i < level.length; i += 2) {
      const left = level[i];
      const right = (i + 1 < level.length) ? level[i + 1] : left;
      next.push(await sha256(left + right));
    }
    level = next;
  }
  return level[0];
}

/* ‚îÄ‚îÄ‚îÄ UTXO MODEL ‚îÄ‚îÄ‚îÄ */
function buildUTXOSet(chainData) {
  const utxos = {};
  for (const block of chainData) {
    for (const tx of block.transactions) {
      if (tx.inputs) {
        for (const inp of tx.inputs) {
          const key = inp.txHash + ':' + inp.outputIndex;
          delete utxos[key];
        }
      }
      if (tx.outputs) {
        for (let i = 0; i < tx.outputs.length; i++) {
          const key = tx.hash + ':' + i;
          utxos[key] = { txHash: tx.hash, outputIndex: i, address: tx.outputs[i].address, amount: tx.outputs[i].amount };
        }
      }
    }
  }
  return utxos;
}

function getBalance(address) {
  let total = 0;
  for (const key in utxoSet) {
    if (utxoSet[key].address === address) total += utxoSet[key].amount;
  }
  return total;
}

function getUTXOsForAddress(address) {
  const result = [];
  for (const key in utxoSet) {
    if (utxoSet[key].address === address) result.push(utxoSet[key]);
  }
  return result;
}

/* ‚îÄ‚îÄ‚îÄ TRANSACTIONS ‚îÄ‚îÄ‚îÄ */
function getBlockReward(height) {
  const halvings = Math.floor(height / HALVING_INTERVAL);
  if (halvings >= 64) return 0;
  return INITIAL_REWARD / Math.pow(2, halvings);
}

function getTotalMined() {
  let total = 0;
  for (let h = 0; h < chain.length; h++) total += getBlockReward(h);
  return total;
}

async function createCoinbaseTx(minerAddress, blockHeight) {
  const reward = getBlockReward(blockHeight);
  if (reward <= 0) return null;
  const tx = {
    type: 'coinbase',
    inputs: [],
    outputs: [{ address: minerAddress, amount: reward }],
    timestamp: Date.now(),
    blockHeight: blockHeight
  };
  tx.hash = await sha256(JSON.stringify(tx));
  return tx;
}

async function createTransaction(fromPrivKey, fromPubKey, toAddress, amount) {
  const senderAddr = getAddress(fromPubKey);
  const senderUTXOs = getUTXOsForAddress(senderAddr);
  let gathered = 0;
  const inputs = [];
  for (const utxo of senderUTXOs) {
    inputs.push({ txHash: utxo.txHash, outputIndex: utxo.outputIndex });
    gathered += utxo.amount;
    if (gathered >= amount) break;
  }
  if (gathered < amount) throw new Error('Insufficient balance');
  const outputs = [{ address: toAddress, amount: amount }];
  const change = gathered - amount;
  if (change > 0) outputs.push({ address: senderAddr, amount: change });
  const txBody = { type: 'transfer', inputs, outputs, timestamp: Date.now(), senderPub: fromPubKey };
  txBody.hash = await sha256(JSON.stringify({ inputs: txBody.inputs, outputs: txBody.outputs, timestamp: txBody.timestamp }));
  txBody.signature = await signData(fromPrivKey, txBody.hash);
  return txBody;
}

async function verifyTransaction(tx) {
  if (tx.type === 'coinbase') return true;
  if (!tx.signature || !tx.senderPub) return false;
  const reHash = await sha256(JSON.stringify({ inputs: tx.inputs, outputs: tx.outputs, timestamp: tx.timestamp }));
  if (reHash !== tx.hash) return false;
  return await verifySignature(tx.senderPub, tx.hash, tx.signature);
}

/* ‚îÄ‚îÄ‚îÄ BLOCK CREATION AND MINING ‚îÄ‚îÄ‚îÄ */
function getLastBlock() { return chain.length > 0 ? chain[chain.length - 1] : null; }

async function hashBlock(header) {
  return await sha256(header.prevHash + header.merkleRoot + header.timestamp + header.nonce + header.difficulty);
}

function meetsTarget(hash, diff) {
  const prefix = '0'.repeat(diff);
  return hash.startsWith(prefix);
}

function adjustDifficulty(chainData) {
  if (chainData.length < DIFFICULTY_ADJUST_INTERVAL) return 2;
  if (chainData.length % DIFFICULTY_ADJUST_INTERVAL !== 0) return chainData[chainData.length - 1].difficulty;
  const start = chainData[chainData.length - DIFFICULTY_ADJUST_INTERVAL].timestamp;
  const end = chainData[chainData.length - 1].timestamp;
  const elapsed = end - start;
  const expected = DIFFICULTY_ADJUST_INTERVAL * TARGET_BLOCK_TIME;
  let newDiff = chainData[chainData.length - 1].difficulty;
  if (elapsed < expected / 2) newDiff++;
  else if (elapsed > expected * 2) newDiff = Math.max(1, newDiff - 1);
  return newDiff;
}

async function mineBlock(minerAddress) {
  mining = true;
  miningAbort = false;
  hashCount = 0;
  const startTime = Date.now();
  const blockHeight = chain.length;
  const coinbase = await createCoinbaseTx(minerAddress, blockHeight);
  const txs = [];
  if (coinbase) txs.push(coinbase);
  const validMempool = [];
  for (const tx of mempool) {
    if (await verifyTransaction(tx)) validMempool.push(tx);
  }
  txs.push(...validMempool.slice(0, 50));
  const txHashes = txs.map(t => t.hash);
  const merkleRoot = await computeMerkleRoot(txHashes);
  const prevBlock = getLastBlock();
  const prevHash = prevBlock ? prevBlock.hash : '0'.repeat(64);
  difficulty = adjustDifficulty(chain);
  const header = { prevHash, merkleRoot, timestamp: Date.now(), nonce: 0, difficulty };
  const hashStreamEl = document.getElementById('hashStream');
  const BATCH = 200;

  return new Promise((resolve, reject) => {
    async function batch() {
      if (miningAbort) { mining = false; reject(new Error('Mining aborted')); return; }
      for (let i = 0; i < BATCH; i++) {
        header.nonce++;
        const h = await hashBlock(header);
        hashCount++;
        if (hashCount % 50 === 0 && hashStreamEl) {
          const line = document.createElement('div');
          line.textContent = h;
          if (meetsTarget(h, header.difficulty)) line.className = 'found';
          hashStreamEl.appendChild(line);
          if (hashStreamEl.children.length > 200) hashStreamEl.removeChild(hashStreamEl.firstChild);
          hashStreamEl.scrollTop = hashStreamEl.scrollHeight;
        }
        if (meetsTarget(h, header.difficulty)) {
          const elapsed = Date.now() - startTime;
          hashRate = Math.round(hashCount / (elapsed / 1000));
          const block = {
            index: blockHeight,
            hash: h,
            prevHash: header.prevHash,
            merkleRoot: header.merkleRoot,
            timestamp: header.timestamp,
            nonce: header.nonce,
            difficulty: header.difficulty,
            transactions: txs,
            miner: minerAddress
          };
          chain.push(block);
          mempool = mempool.filter(t => !validMempool.includes(t));
          utxoSet = buildUTXOSet(chain);
          saveState();
          mining = false;
          resolve(block);
          return;
        }
      }
      const now = Date.now();
      hashRate = Math.round(hashCount / ((now - startTime) / 1000));
      updateMiningStats();
      setTimeout(batch, 0);
    }
    batch();
  });
}

/* ‚îÄ‚îÄ‚îÄ CHAIN VALIDATION ‚îÄ‚îÄ‚îÄ */
async function isValidChain(chainData) {
  for (let i = 0; i < chainData.length; i++) {
    const block = chainData[i];
    if (i > 0 && block.prevHash !== chainData[i - 1].hash) return { valid: false, error: 'Broken link at block ' + i };
    const reHash = await hashBlock({ prevHash: block.prevHash, merkleRoot: block.merkleRoot, timestamp: block.timestamp, nonce: block.nonce, difficulty: block.difficulty });
    if (reHash !== block.hash) return { valid: false, error: 'Invalid hash at block ' + i };
    if (!meetsTarget(block.hash, block.difficulty)) return { valid: false, error: 'PoW not met at block ' + i };
    const txHashes = block.transactions.map(t => t.hash);
    const mr = await computeMerkleRoot(txHashes);
    if (mr !== block.merkleRoot) return { valid: false, error: 'Bad merkle root at block ' + i };
    for (const tx of block.transactions) {
      if (!(await verifyTransaction(tx))) return { valid: false, error: 'Bad signature in block ' + i };
    }
  }
  return { valid: true };
}

/* ‚îÄ‚îÄ‚îÄ PERSISTENCE ‚îÄ‚îÄ‚îÄ */
function saveState() {
  try {
    localStorage.setItem(STORAGE_KEYS.chain, JSON.stringify(chain));
    localStorage.setItem(STORAGE_KEYS.utxos, JSON.stringify(utxoSet));
    localStorage.setItem(STORAGE_KEYS.mempool, JSON.stringify(mempool));
    if (wallet) localStorage.setItem(STORAGE_KEYS.wallet, JSON.stringify({ publicKey: wallet.publicKey, privateKey: wallet.privateKey }));
  } catch (e) { console.warn('Save failed:', e); }
}

function loadState() {
  try {
    const c = localStorage.getItem(STORAGE_KEYS.chain);
    if (c) chain = JSON.parse(c);
    const u = localStorage.getItem(STORAGE_KEYS.utxos);
    if (u) utxoSet = JSON.parse(u);
    const m = localStorage.getItem(STORAGE_KEYS.mempool);
    if (m) mempool = JSON.parse(m);
  } catch (e) { console.warn('Load failed:', e); }
}

async function loadWallet() {
  try {
    const w = localStorage.getItem(STORAGE_KEYS.wallet);
    if (w) {
      const data = JSON.parse(w);
      wallet = {
        publicKey: data.publicKey,
        privateKey: data.privateKey,
        publicKeyObj: await importPublicKey(data.publicKey),
        privateKeyObj: await importPrivateKey(data.privateKey)
      };
    }
  } catch (e) { wallet = null; }
}

/* ‚îÄ‚îÄ‚îÄ SIMULATED NPC NODES ‚îÄ‚îÄ‚îÄ */
function initNPCNodes() {
  const names = ['PandaNode-Asia', 'GeckoRelay-EU', 'ParrotMesh-SA', 'WolfPack-NA', 'DolphinSync-OCE', 'FalconEdge-AF', 'FoxTrot-RU', 'TigerPool-IN'];
  npcNodes = names.map((name, i) => ({
    name, id: 'node-' + (i + 1),
    blocks: chain.length + Math.floor(Math.random() * 3) - 1,
    peers: 3 + Math.floor(Math.random() * 12),
    latency: 20 + Math.floor(Math.random() * 200),
    version: '2.' + Math.floor(Math.random() * 4) + '.' + Math.floor(Math.random() * 10),
    online: Math.random() > 0.15
  }));
}

/* ‚îÄ‚îÄ‚îÄ UI NAVIGATION ‚îÄ‚îÄ‚îÄ */
const panels = [
  { id: 'dashboard', label: 'Dashboard', icon: 'üìä' },
  { id: 'wallet', label: 'Wallet', icon: 'üí∞' },
  { id: 'mining', label: 'Mining', icon: '‚õèÔ∏è' },
  { id: 'transactions', label: 'Transactions', icon: 'üîÑ' },
  { id: 'explorer', label: 'Block Explorer', icon: 'üîç' },
  { id: 'network', label: 'Network', icon: 'üåê' },
  { id: 'backup', label: 'Backup', icon: 'üíæ' }
];

function renderSidebar() {
  const sb = document.getElementById('sidebar');
  sb.innerHTML = panels.map(p =>
    '<div class="nav-item' + (currentPanel === p.id ? ' active' : '') + '" data-panel="' + p.id + '">' +
    '<span class="icon">' + p.icon + '</span>' + p.label + '</div>'
  ).join('');
  sb.querySelectorAll('.nav-item').forEach(el => {
    el.addEventListener('click', () => { currentPanel = el.dataset.panel; renderSidebar(); renderPanel(); });
  });
}

function renderPanel() {
  const main = document.getElementById('mainContent');
  switch (currentPanel) {
    case 'dashboard': renderDashboard(main); break;
    case 'wallet': renderWallet(main); break;
    case 'mining': renderMining(main); break;
    case 'transactions': renderTransactions(main); break;
    case 'explorer': renderExplorer(main); break;
    case 'network': renderNetwork(main); break;
    case 'backup': renderBackup(main); break;
  }
}

/* ‚îÄ‚îÄ‚îÄ DASHBOARD PANEL ‚îÄ‚îÄ‚îÄ */
function renderDashboard(el) {
  const addr = wallet ? getAddress(wallet.publicKey) : 'N/A';
  const bal = wallet ? getBalance(addr) : 0;
  const totalMined = getTotalMined();
  const reward = getBlockReward(chain.length);
  const halvingsLeft = HALVING_INTERVAL - (chain.length % HALVING_INTERVAL);
  el.innerHTML =
    '<h2 style="margin-bottom:16px;color:var(--accent)">üìä Dashboard</h2>' +
    '<div class="stats-grid">' +
      statCard('Chain Height', chain.length, 'blocks') +
      statCard('Your Balance', bal.toFixed(4), 'ZOO') +
      statCard('Difficulty', difficulty, 'zeros') +
      statCard('Block Reward', reward, 'ZOO') +
      statCard('Total Mined', totalMined.toFixed(2), '/ ' + MAX_SUPPLY) +
      statCard('Mempool', mempool.length, 'pending txs') +
      statCard('UTXO Count', Object.keys(utxoSet).length, 'outputs') +
      statCard('Next Halving', halvingsLeft, 'blocks') +
    '</div>' +
    '<div class="card"><h3>Quick Actions</h3>' +
      '<div style="display:flex;gap:8px;flex-wrap:wrap;">' +
        '<button onclick="startQuickMine()">‚õèÔ∏è Mine Block</button>' +
        '<button onclick="switchPanel(\'wallet\')">üí∞ Open Wallet</button>' +
        '<button onclick="switchPanel(\'explorer\')">üîç Explore Chain</button>' +
        '<button onclick="validateFullChain()">‚úÖ Validate Chain</button>' +
      '</div>' +
    '</div>' +
    '<div class="card"><h3>Recent Blocks</h3>' +
      (chain.length === 0 ? '<p style="color:var(--dim)">No blocks mined yet. Start mining!</p>' :
        chain.slice(-5).reverse().map(b =>
          '<div class="tx-item"><span class="tx-amount">Block #' + b.index + '</span> ‚Äî ' +
          b.transactions.length + ' tx ‚Äî <span style="color:var(--dim);font-size:10px">' + b.hash.substring(0, 24) + '...</span></div>'
        ).join('')) +
    '</div>';
}

function statCard(lbl, val, unit) {
  return '<div class="stat-card"><div class="lbl">' + lbl + '</div><div class="val">' + val + '</div><div class="lbl">' + (unit || '') + '</div></div>';
}

/* ‚îÄ‚îÄ‚îÄ WALLET PANEL ‚îÄ‚îÄ‚îÄ */
function renderWallet(el) {
  const addr = wallet ? getAddress(wallet.publicKey) : null;
  const bal = addr ? getBalance(addr) : 0;
  el.innerHTML =
    '<h2 style="margin-bottom:16px;color:var(--accent)">üí∞ Wallet</h2>' +
    (wallet ?
      '<div class="stats-grid">' +
        statCard('Balance', bal.toFixed(4), 'ZOO') +
        statCard('Address', addr ? addr.substring(0, 12) + '...' : 'N/A', '') +
      '</div>' +
      '<div class="card"><h3>Your Address</h3>' +
        '<div style="background:var(--bg);padding:10px;border-radius:var(--radius);word-break:break-all;font-size:11px;margin-bottom:10px;">' + addr + '</div>' +
        '<button onclick="copyToClip(\'' + addr + '\')">üìã Copy Address</button>' +
      '</div>' +
      '<div class="card"><h3>Send ZooCoin</h3>' +
        '<div class="form-row"><label>Recipient Address</label><input id="sendTo" placeholder="ZOO..."></div>' +
        '<div class="form-row"><label>Amount (ZOO)</label><input id="sendAmt" type="number" step="0.0001" min="0.0001" placeholder="0.0"></div>' +
        '<button class="primary" onclick="sendZoo()">Send ZOO</button>' +
      '</div>' +
      '<div class="card"><h3>Key Management</h3>' +
        '<div style="display:flex;gap:8px;">' +
          '<button onclick="exportWalletKeys()">üì§ Export Keys (JWK)</button>' +
          '<button class="danger" onclick="generateNewWallet()">üîë Generate New Wallet</button>' +
        '</div>' +
        '<div id="keyExport" style="margin-top:10px;"></div>' +
      '</div>' +
      '<div class="card"><h3>UTXOs</h3><div class="tx-list">' +
        getUTXOsForAddress(addr).map(u =>
          '<div class="tx-item"><span class="tx-amount">' + u.amount.toFixed(4) + ' ZOO</span>' +
          ' ‚Äî <span class="tx-hash">' + u.txHash.substring(0, 20) + ':' + u.outputIndex + '</span></div>'
        ).join('') +
        (getUTXOsForAddress(addr).length === 0 ? '<div style="color:var(--dim)">No UTXOs. Mine some blocks!</div>' : '') +
      '</div></div>'
    :
      '<div class="card"><h3>No Wallet Found</h3><p style="margin-bottom:12px;color:var(--dim)">Generate an ECDSA P-256 key pair to start using ZooCoin.</p>' +
        '<button class="primary" onclick="generateNewWallet()">üîë Generate Key Pair</button>' +
        '<div style="margin-top:12px;"><label style="font-size:11px;color:var(--dim)">Or import JWK keys:</label>' +
        '<textarea id="importKeys" rows="4" placeholder=\'{"publicKey":{...},"privateKey":{...}}\'></textarea>' +
        '<button style="margin-top:8px;" onclick="importWalletKeys()">üì• Import Keys</button></div>' +
      '</div>'
    );
}

/* ‚îÄ‚îÄ‚îÄ MINING PANEL ‚îÄ‚îÄ‚îÄ */
function renderMining(el) {
  const reward = getBlockReward(chain.length);
  const halvings = Math.floor(chain.length / HALVING_INTERVAL);
  el.innerHTML =
    '<h2 style="margin-bottom:16px;color:var(--accent)">‚õèÔ∏è Mining</h2>' +
    '<div class="stats-grid">' +
      statCard('Status', mining ? 'MINING' : 'IDLE', '') +
      statCard('Hash Rate', hashRate, 'H/s') +
      statCard('Difficulty', difficulty, 'leading zeros') +
      statCard('Block Reward', reward, 'ZOO') +
      statCard('Halvings', halvings, 'of 64') +
      statCard('Next Block', '#' + chain.length, '') +
    '</div>' +
    '<div class="card"><h3>Mining Controls</h3>' +
      '<div style="display:flex;gap:8px;margin-bottom:12px;">' +
        '<button id="mineBtn" class="primary" onclick="startMine()" ' + (mining || !wallet ? 'disabled' : '') + '>' + (mining ? '‚è≥ Mining...' : '‚õèÔ∏è Mine Block') + '</button>' +
        '<button id="stopBtn" class="danger" onclick="stopMine()" ' + (!mining ? 'disabled' : '') + '>‚èπ Stop</button>' +
        '<button onclick="autoMine()" ' + (mining || !wallet ? 'disabled' : '') + '>üîÑ Auto-Mine 5 Blocks</button>' +
      '</div>' +
      (!wallet ? '<p style="color:var(--red);font-size:12px;">‚ö†Ô∏è Generate a wallet first!</p>' : '') +
    '</div>' +
    '<div class="card"><h3>Hash Stream</h3><div id="hashStream" class="hash-stream"><div style="color:var(--dim)">Start mining to see hash attempts...</div></div></div>' +
    '<div class="card"><h3>Reward Schedule</h3>' +
      '<table style="width:100%;font-size:11px;border-collapse:collapse;">' +
      '<tr style="color:var(--accent);"><th style="text-align:left;padding:4px;">Era</th><th>Blocks</th><th>Reward</th><th>Status</th></tr>' +
      [0,1,2,3,4,5].map(h => {
        const r = INITIAL_REWARD / Math.pow(2, h);
        const start = h * HALVING_INTERVAL;
        const end = (h + 1) * HALVING_INTERVAL - 1;
        const isCurrent = chain.length >= start && chain.length <= end;
        return '<tr style="color:' + (isCurrent ? 'var(--gold)' : 'var(--dim)') + '"><td style="padding:4px;">' + (h + 1) + '</td><td style="text-align:center;">' + start + '-' + end + '</td><td style="text-align:center;">' + r + ' ZOO</td><td style="text-align:center;">' + (isCurrent ? '‚óÄ Current' : chain.length > end ? '‚úì Done' : 'Upcoming') + '</td></tr>';
      }).join('') +
      '</table></div>';
}

function updateMiningStats() {
  const el = document.getElementById('miningHashRate');
  if (el) el.textContent = hashRate;
}

/* ‚îÄ‚îÄ‚îÄ TRANSACTIONS PANEL ‚îÄ‚îÄ‚îÄ */
function renderTransactions(el) {
  const allTxs = [];
  chain.forEach(b => b.transactions.forEach(t => allTxs.push({ ...t, block: b.index, confirmed: true })));
  mempool.forEach(t => allTxs.push({ ...t, block: null, confirmed: false }));
  allTxs.reverse();

  el.innerHTML =
    '<h2 style="margin-bottom:16px;color:var(--accent)">üîÑ Transactions</h2>' +
    '<div class="stats-grid">' +
      statCard('Confirmed', allTxs.filter(t => t.confirmed).length, 'txs') +
      statCard('Pending', mempool.length, 'in mempool') +
    '</div>' +
    '<div class="card"><h3>Mempool (' + mempool.length + ')</h3>' +
      '<div class="tx-list">' +
      (mempool.length === 0 ? '<div style="color:var(--dim)">Mempool is empty</div>' :
        mempool.map(t =>
          '<div class="tx-item">' +
            '<div class="tx-hash">' + t.hash + '</div>' +
            '<div style="margin-top:4px;">' +
              '<span class="badge gold">' + t.type + '</span> ' +
              (t.outputs ? t.outputs.map(o => '<span class="tx-amount">' + o.amount.toFixed(4) + ' ZOO</span>').join(' + ') : '') +
            '</div>' +
          '</div>'
        ).join('')) +
      '</div></div>' +
    '<div class="card"><h3>Confirmed Transactions</h3>' +
      '<div class="tx-list">' +
      (allTxs.filter(t => t.confirmed).length === 0 ? '<div style="color:var(--dim)">No confirmed transactions yet</div>' :
        allTxs.filter(t => t.confirmed).slice(0, 50).map(t =>
          '<div class="tx-item">' +
            '<div><span class="badge green">' + t.type + '</span> <span style="color:var(--dim)">Block #' + t.block + '</span></div>' +
            '<div class="tx-hash" style="margin-top:4px;">' + t.hash.substring(0, 48) + '...</div>' +
            '<div style="margin-top:4px;">' +
              (t.outputs ? t.outputs.map(o => '<span class="tx-amount">' + o.amount.toFixed(4) + ' ZOO ‚Üí ' + o.address.substring(0, 12) + '...</span>').join('<br>') : '') +
            '</div>' +
          '</div>'
        ).join('')) +
      '</div></div>';
}

/* ‚îÄ‚îÄ‚îÄ BLOCK EXPLORER PANEL ‚îÄ‚îÄ‚îÄ */
function renderExplorer(el) {
  el.innerHTML =
    '<h2 style="margin-bottom:16px;color:var(--accent)">üîç Block Explorer</h2>' +
    '<div class="stats-grid">' +
      statCard('Chain Height', chain.length, 'blocks') +
      statCard('Total Txs', chain.reduce((s, b) => s + b.transactions.length, 0), '') +
    '</div>' +
    '<div class="card"><h3>Search Block</h3>' +
      '<div style="display:flex;gap:8px;"><input id="blockSearch" placeholder="Block number or hash..." style="flex:1;">' +
      '<button onclick="searchBlock()">Search</button></div></div>' +
    '<div class="card"><h3>Blocks</h3>' +
      (chain.length === 0 ? '<p style="color:var(--dim)">No blocks yet</p>' :
        '<div id="blockList">' + chain.slice().reverse().map(b => renderBlockItem(b)).join('') + '</div>') +
    '</div>';
  document.querySelectorAll('.block-item').forEach(bi => {
    bi.addEventListener('click', () => bi.classList.toggle('expanded'));
  });
}

function renderBlockItem(b) {
  return '<div class="block-item" data-idx="' + b.index + '">' +
    '<div class="bh"><span class="bn">#' + b.index + '</span><span class="bt">' + new Date(b.timestamp).toLocaleString() + '</span></div>' +
    '<div style="margin-top:4px;font-size:11px;">' +
      '<span style="color:var(--dim)">Txs: ' + b.transactions.length + '</span> ¬∑ ' +
      '<span style="color:var(--dim)">Nonce: ' + b.nonce + '</span> ¬∑ ' +
      '<span style="color:var(--dim)">Diff: ' + b.difficulty + '</span>' +
    '</div>' +
    '<div class="bd">' +
      '<div style="margin-bottom:4px;"><b style="color:var(--accent);">Hash:</b> ' + b.hash + '</div>' +
      '<div style="margin-bottom:4px;"><b style="color:var(--accent);">Prev:</b> ' + b.prevHash + '</div>' +
      '<div style="margin-bottom:4px;"><b style="color:var(--accent);">Merkle Root:</b> ' + b.merkleRoot + '</div>' +
      '<div style="margin-bottom:4px;"><b style="color:var(--accent);">Miner:</b> ' + (b.miner || 'N/A') + '</div>' +
      '<div><b style="color:var(--accent);">Transactions:</b></div>' +
      b.transactions.map(t =>
        '<div style="margin-left:12px;margin-top:4px;padding:4px;background:var(--bg);border-radius:3px;">' +
          '<span class="badge ' + (t.type === 'coinbase' ? 'gold' : 'green') + '">' + t.type + '</span> ' +
          (t.outputs ? t.outputs.map(o => o.amount.toFixed(4) + ' ZOO ‚Üí ' + o.address.substring(0, 12) + '...').join(', ') : '') +
        '</div>'
      ).join('') +
    '</div>' +
  '</div>';
}

/* ‚îÄ‚îÄ‚îÄ NETWORK PANEL ‚îÄ‚îÄ‚îÄ */
function renderNetwork(el) {
  initNPCNodes();
  const onlineCount = npcNodes.filter(n => n.online).length;
  el.innerHTML =
    '<h2 style="margin-bottom:16px;color:var(--accent)">üåê Network</h2>' +
    '<div class="stats-grid">' +
      statCard('Your Node', 'Online', '') +
      statCard('Peers', onlineCount + '/' + npcNodes.length, 'nodes') +
      statCard('Chain Height', chain.length, 'blocks') +
    '</div>' +
    '<div class="card"><h3>Connected Nodes</h3>' +
      '<div class="node-grid">' +
      npcNodes.map(n =>
        '<div class="node-card">' +
          '<div class="nn">' + n.name + ' <span class="badge ' + (n.online ? 'green' : 'red') + '">' + (n.online ? 'Online' : 'Offline') + '</span></div>' +
          '<div class="ns">Version: ' + n.version + '</div>' +
          '<div class="ns">Blocks: ' + Math.max(0, n.blocks) + '</div>' +
          '<div class="ns">Peers: ' + n.peers + '</div>' +
          '<div class="ns">Latency: ' + n.latency + 'ms</div>' +
        '</div>'
      ).join('') +
      '</div></div>' +
    '<div class="card"><h3>Network Consensus</h3>' +
      '<p style="font-size:12px;color:var(--dim);">All nodes share the same blockchain via localStorage. In a real network, nodes would sync via P2P protocols.</p>' +
      '<button style="margin-top:8px;" onclick="simulateSync()">üîÑ Simulate Sync</button>' +
      '<div id="syncResult" style="margin-top:8px;"></div>' +
    '</div>';
}

/* ‚îÄ‚îÄ‚îÄ BACKUP PANEL ‚îÄ‚îÄ‚îÄ */
function renderBackup(el) {
  const chainSize = JSON.stringify(chain).length;
  el.innerHTML =
    '<h2 style="margin-bottom:16px;color:var(--accent)">üíæ Backup & Restore</h2>' +
    '<div class="stats-grid">' +
      statCard('Chain Size', (chainSize / 1024).toFixed(1) + ' KB', '') +
      statCard('Blocks', chain.length, '') +
      statCard('Wallet', wallet ? 'Loaded' : 'None', '') +
    '</div>' +
    '<div class="card"><h3>Export</h3>' +
      '<div style="display:flex;gap:8px;flex-wrap:wrap;">' +
        '<button onclick="exportChain()">üì§ Export Full Chain (JSON)</button>' +
        '<button onclick="exportWalletBackup()">üîë Export Wallet</button>' +
        '<button onclick="exportAll()">üì¶ Export Everything</button>' +
      '</div>' +
      '<textarea id="exportArea" rows="6" style="margin-top:10px;" readonly placeholder="Export data will appear here..."></textarea>' +
      '<button style="margin-top:6px;" onclick="copyExport()">üìã Copy to Clipboard</button>' +
    '</div>' +
    '<div class="card"><h3>Import</h3>' +
      '<textarea id="importArea" rows="6" placeholder="Paste exported JSON here..."></textarea>' +
      '<div style="display:flex;gap:8px;margin-top:8px;">' +
        '<button class="primary" onclick="importData()">üì• Import</button>' +
        '<button class="danger" onclick="resetEverything()">üóëÔ∏è Reset All Data</button>' +
      '</div>' +
    '</div>' +
    '<div class="card"><h3>Chain Integrity</h3>' +
      '<button onclick="validateFullChain()">‚úÖ Validate Entire Chain</button>' +
      '<div id="validationResult" style="margin-top:8px;"></div>' +
    '</div>';
}

/* ‚îÄ‚îÄ‚îÄ GLOBAL ACTIONS ‚îÄ‚îÄ‚îÄ */
window.switchPanel = function(id) {
  currentPanel = id;
  renderSidebar();
  renderPanel();
};

window.startQuickMine = async function() {
  if (!wallet) { toast('Generate a wallet first!', 'red'); return; }
  currentPanel = 'mining';
  renderSidebar();
  renderPanel();
  await startMine();
};

window.startMine = async function() {
  if (mining || !wallet) return;
  const addr = getAddress(wallet.publicKey);
  try {
    const block = await mineBlock(addr);
    toast('‚õèÔ∏è Block #' + block.index + ' mined! Reward: ' + getBlockReward(block.index) + ' ZOO', 'gold');
    renderPanel();
  } catch (e) {
    if (e.message !== 'Mining aborted') toast('Mining error: ' + e.message, 'red');
  }
};

window.stopMine = function() {
  miningAbort = true;
  toast('Mining stopped', 'dim');
};

window.autoMine = async function() {
  if (mining || !wallet) return;
  for (let i = 0; i < 5; i++) {
    if (miningAbort) break;
    await startMine();
  }
};

window.generateNewWallet = async function() {
  wallet = await generateKeyPair();
  saveState();
  toast('üîë New ECDSA P-256 wallet generated!', 'green');
  renderPanel();
  document.getElementById('nodeStatus').textContent = 'Node Active ‚Äî ' + getAddress(wallet.publicKey).substring(0, 12) + '...';
};

window.sendZoo = async function() {
  const toAddr = document.getElementById('sendTo').value.trim();
  const amount = parseFloat(document.getElementById('sendAmt').value);
  if (!toAddr || isNaN(amount) || amount <= 0) { toast('Invalid address or amount', 'red'); return; }
  try {
    const tx = await createTransaction(wallet.privateKey, wallet.publicKey, toAddr, amount);
    mempool.push(tx);
    saveState();
    toast('üì§ Transaction submitted! ' + amount + ' ZOO ‚Üí ' + toAddr.substring(0, 12) + '...', 'green');
    renderPanel();
  } catch (e) { toast('Error: ' + e.message, 'red'); }
};

window.exportWalletKeys = function() {
  if (!wallet) return;
  const el = document.getElementById('keyExport');
  const data = JSON.stringify({ publicKey: wallet.publicKey, privateKey: wallet.privateKey }, null, 2);
  el.innerHTML = '<textarea rows="8" readonly style="font-size:10px;">' + escapeHTML(data) + '</textarea>';
};

window.importWalletKeys = async function() {
  const raw = document.getElementById('importKeys').value.trim();
  try {
    const data = JSON.parse(raw);
    wallet = {
      publicKey: data.publicKey,
      privateKey: data.privateKey,
      publicKeyObj: await importPublicKey(data.publicKey),
      privateKeyObj: await importPrivateKey(data.privateKey)
    };
    saveState();
    toast('üîë Wallet imported!', 'green');
    renderPanel();
  } catch (e) { toast('Invalid key data: ' + e.message, 'red'); }
};

window.copyToClip = function(text) {
  navigator.clipboard.writeText(text).then(() => toast('Copied!', 'green')).catch(() => toast('Copy failed', 'red'));
};

window.searchBlock = function() {
  const query = document.getElementById('blockSearch').value.trim();
  const idx = parseInt(query);
  let block = null;
  if (!isNaN(idx) && idx >= 0 && idx < chain.length) block = chain[idx];
  else block = chain.find(b => b.hash.startsWith(query));
  if (block) {
    const items = document.querySelectorAll('.block-item');
    items.forEach(i => { i.classList.remove('expanded'); if (parseInt(i.dataset.idx) === block.index) { i.classList.add('expanded'); i.scrollIntoView({ behavior: 'smooth', block: 'center' }); } });
  } else toast('Block not found', 'red');
};

window.simulateSync = async function() {
  const el = document.getElementById('syncResult');
  el.innerHTML = '<span style="color:var(--gold)">Syncing with peers...</span>';
  await new Promise(r => setTimeout(r, 1500));
  npcNodes.forEach(n => { if (n.online) n.blocks = chain.length; });
  el.innerHTML = '<span style="color:var(--green)">‚úì All online peers synced to block #' + (chain.length - 1) + '</span>';
};

window.exportChain = function() {
  const area = document.getElementById('exportArea');
  area.value = JSON.stringify({ type: 'cryptozoo-chain', chain, exportedAt: new Date().toISOString() }, null, 2);
};

window.exportWalletBackup = function() {
  if (!wallet) { toast('No wallet to export', 'red'); return; }
  const area = document.getElementById('exportArea');
  area.value = JSON.stringify({ type: 'cryptozoo-wallet', publicKey: wallet.publicKey, privateKey: wallet.privateKey, exportedAt: new Date().toISOString() }, null, 2);
};

window.exportAll = function() {
  const area = document.getElementById('exportArea');
  area.value = JSON.stringify({
    type: 'cryptozoo-full-backup',
    chain,
    wallet: wallet ? { publicKey: wallet.publicKey, privateKey: wallet.privateKey } : null,
    utxoSet,
    mempool,
    exportedAt: new Date().toISOString()
  }, null, 2);
};

window.copyExport = function() {
  const area = document.getElementById('exportArea');
  navigator.clipboard.writeText(area.value).then(() => toast('Copied!', 'green')).catch(() => { area.select(); document.execCommand('copy'); toast('Copied!', 'green'); });
};

window.importData = async function() {
  const raw = document.getElementById('importArea').value.trim();
  try {
    const data = JSON.parse(raw);
    if (data.type === 'cryptozoo-chain' && data.chain) {
      chain = data.chain;
      utxoSet = buildUTXOSet(chain);
      difficulty = adjustDifficulty(chain);
    } else if (data.type === 'cryptozoo-wallet' && data.publicKey) {
      wallet = { publicKey: data.publicKey, privateKey: data.privateKey, publicKeyObj: await importPublicKey(data.publicKey), privateKeyObj: await importPrivateKey(data.privateKey) };
    } else if (data.type === 'cryptozoo-full-backup') {
      if (data.chain) { chain = data.chain; utxoSet = buildUTXOSet(chain); difficulty = adjustDifficulty(chain); }
      if (data.wallet) { wallet = { publicKey: data.wallet.publicKey, privateKey: data.wallet.privateKey, publicKeyObj: await importPublicKey(data.wallet.publicKey), privateKeyObj: await importPrivateKey(data.wallet.privateKey) }; }
      if (data.mempool) mempool = data.mempool;
    } else throw new Error('Unknown export format');
    saveState();
    toast('üì• Data imported successfully!', 'green');
    renderPanel();
  } catch (e) { toast('Import error: ' + e.message, 'red'); }
};

window.resetEverything = function() {
  if (!confirm('This will delete your wallet, chain, and all data. Are you sure?')) return;
  chain = []; wallet = null; utxoSet = {}; mempool = []; difficulty = 2;
  Object.values(STORAGE_KEYS).forEach(k => localStorage.removeItem(k));
  toast('üóëÔ∏è All data reset', 'red');
  document.getElementById('nodeStatus').textContent = 'Node Reset';
  renderPanel();
};

window.validateFullChain = async function() {
  const el = document.getElementById('validationResult') || document.createElement('div');
  if (!document.getElementById('validationResult')) {
    el.id = 'validationResult';
    document.querySelector('.main .card:last-child')?.appendChild(el);
  }
  el.innerHTML = '<span style="color:var(--gold)">Validating chain...</span>';
  const result = await isValidChain(chain);
  if (result.valid) {
    el.innerHTML = '<span style="color:var(--green)">‚úÖ Chain is valid! ' + chain.length + ' blocks verified.</span>';
    toast('‚úÖ Chain validated ‚Äî all ' + chain.length + ' blocks OK', 'green');
  } else {
    el.innerHTML = '<span style="color:var(--red)">‚ùå ' + result.error + '</span>';
    toast('‚ùå Chain invalid: ' + result.error, 'red');
  }
};

/* ‚îÄ‚îÄ‚îÄ TOAST NOTIFICATIONS ‚îÄ‚îÄ‚îÄ */
function toast(msg, color) {
  const existing = document.querySelector('.toast');
  if (existing) existing.remove();
  const t = document.createElement('div');
  t.className = 'toast';
  t.style.borderColor = color === 'green' ? 'var(--green)' : color === 'red' ? 'var(--red)' : color === 'gold' ? 'var(--gold)' : '#555';
  t.textContent = msg;
  document.body.appendChild(t);
  setTimeout(() => t.remove(), 4000);
}

function escapeHTML(s) {
  return s.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
}

/* ‚îÄ‚îÄ‚îÄ INITIALIZATION ‚îÄ‚îÄ‚îÄ */
async function init() {
  loadState();
  await loadWallet();
  if (chain.length > 0) {
    utxoSet = buildUTXOSet(chain);
    difficulty = adjustDifficulty(chain);
  }
  initNPCNodes();
  renderSidebar();
  renderPanel();
  if (wallet) {
    const addr = getAddress(wallet.publicKey);
    document.getElementById('nodeStatus').textContent = 'Node Active ‚Äî ' + addr.substring(0, 12) + '...';
  } else {
    document.getElementById('nodeStatus').textContent = 'No wallet ‚Äî generate keys to start';
  }
}

init();
})();
</script>
</body>
</html>
