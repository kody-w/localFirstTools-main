<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Prism Refract</title>
    <meta name="description" content="Place prisms and light sources to bend rays into rainbow spectrums, exploring how light separates through crystalline geometry">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background: #0a0a12; min-height: 100vh; font-family: 'Georgia', serif; color: #9090b0; overflow: hidden; }
        #canvas { position: fixed; top: 0; left: 0; cursor: crosshair; }
        #controls {
            position: fixed; top: 20px; left: 20px; background: rgba(10,10,18,0.95);
            padding: 20px; border-radius: 10px; border: 1px solid rgba(120,100,180,0.3);
            z-index: 100;
        }
        h3 { margin-bottom: 15px; color: #b0a0d0; font-weight: normal; }
        .control-row { margin: 10px 0; }
        label { display: block; font-size: 11px; margin-bottom: 5px; opacity: 0.8; }
        input[type="range"] { width: 140px; }
        .value { float: right; color: #c0b0e0; font-size: 12px; }
        .mode-btn { display: inline-block; padding: 8px 12px; margin: 2px; border-radius: 4px; cursor: pointer; border: 1px solid rgba(120,100,180,0.4); }
        .mode-btn.light { background: rgba(255,255,200,0.3); color: #ffffaa; }
        .mode-btn.prism { background: rgba(100,150,255,0.3); color: #aaccff; }
        .mode-btn.active { border-color: white; }
        button {
            display: block; width: 100%; padding: 10px; margin: 6px 0;
            background: rgba(80,60,120,0.4); border: 1px solid rgba(120,100,180,0.4);
            color: #a090c0; cursor: pointer; border-radius: 6px; font-family: inherit;
        }
        #stats { position: fixed; top: 20px; right: 20px; font-size: 12px; color: #706090; z-index: 100; }
        #info { position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); font-size: 12px; opacity: 0.5; z-index: 100; }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div id="controls">
        <h3>Prism Refract</h3>
        <div class="control-row">
            <label>Placement Mode</label>
            <div class="mode-btn light active" id="light-mode">Light Source</div>
            <div class="mode-btn prism" id="prism-mode">Prism</div>
        </div>
        <div class="control-row">
            <label>Light Intensity <span class="value" id="intensity-val">70</span></label>
            <input type="range" id="intensity" min="30" max="100" value="70">
        </div>
        <div class="control-row">
            <label>Dispersion <span class="value" id="dispersion-val">50</span></label>
            <input type="range" id="dispersion" min="20" max="100" value="50">
        </div>
        <button id="rotate-btn">Rotate All Prisms</button>
        <button id="clear-btn">Clear All</button>
    </div>
    <div id="stats">Lights: <span id="light-count">0</span> | Prisms: <span id="prism-count">0</span></div>
    <div id="info">Click to place light sources or prisms | Watch light bend into rainbows</div>
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        let W, H;
        function resize() { W = canvas.width = innerWidth; H = canvas.height = innerHeight; }
        resize(); window.onresize = resize;
        
        let placingLight = true;
        let lightIntensity = 0.7;
        let dispersion = 0.5;
        let time = 0;
        
        const lights = [];
        const prisms = [];
        const rays = [];
        
        const SPECTRUM = [
            { wavelength: 380, color: '#9400D3', name: 'violet' },
            { wavelength: 450, color: '#4B0082', name: 'indigo' },
            { wavelength: 495, color: '#0000FF', name: 'blue' },
            { wavelength: 570, color: '#00FF00', name: 'green' },
            { wavelength: 590, color: '#FFFF00', name: 'yellow' },
            { wavelength: 620, color: '#FF7F00', name: 'orange' },
            { wavelength: 750, color: '#FF0000', name: 'red' }
        ];
        
        class LightSource {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.angle = 0;
                this.radius = 15;
                this.pulse = 0;
            }
            
            update() {
                this.pulse = Math.sin(time * 3) * 0.2 + 1;
            }
            
            draw() {
                const gradient = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, this.radius * 3);
                gradient.addColorStop(0, "rgba(255, 255, 220, " + (lightIntensity * 0.8) + ")");
                gradient.addColorStop(0.5, "rgba(255, 255, 200, " + (lightIntensity * 0.3) + ")");
                gradient.addColorStop(1, 'transparent');
                ctx.fillStyle = gradient;
                ctx.fillRect(this.x - this.radius * 3, this.y - this.radius * 3, this.radius * 6, this.radius * 6);
                
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius * this.pulse, 0, Math.PI * 2);
                ctx.fillStyle = "rgba(255, 255, 240, " + lightIntensity + ")";
                ctx.fill();
            }
            
            emitRays() {
                const rayCount = 12;
                const emittedRays = [];
                
                for (let i = 0; i < rayCount; i++) {
                    const angle = (i / rayCount) * Math.PI * 2 + time * 0.1;
                    emittedRays.push({
                        x: this.x,
                        y: this.y,
                        angle: angle,
                        color: '#FFFFFF',
                        intensity: lightIntensity,
                        wavelength: 0,
                        bounces: 0
                    });
                }
                
                return emittedRays;
            }
        }
        
        class Prism {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.size = 50;
                this.rotation = Math.random() * Math.PI * 2;
                this.vertices = this.calculateVertices();
            }
            
            calculateVertices() {
                const verts = [];
                for (let i = 0; i < 3; i++) {
                    const angle = this.rotation + (i / 3) * Math.PI * 2 - Math.PI / 2;
                    verts.push({
                        x: this.x + Math.cos(angle) * this.size,
                        y: this.y + Math.sin(angle) * this.size
                    });
                }
                return verts;
            }
            
            rotate(amount) {
                this.rotation += amount;
                this.vertices = this.calculateVertices();
            }
            
            draw() {
                ctx.save();
                
                const gradient = ctx.createLinearGradient(
                    this.x - this.size, this.y - this.size,
                    this.x + this.size, this.y + this.size
                );
                gradient.addColorStop(0, 'rgba(150, 180, 255, 0.3)');
                gradient.addColorStop(0.5, 'rgba(200, 220, 255, 0.4)');
                gradient.addColorStop(1, 'rgba(150, 180, 255, 0.3)');
                
                ctx.beginPath();
                ctx.moveTo(this.vertices[0].x, this.vertices[0].y);
                for (let i = 1; i < this.vertices.length; i++) {
                    ctx.lineTo(this.vertices[i].x, this.vertices[i].y);
                }
                ctx.closePath();
                
                ctx.fillStyle = gradient;
                ctx.fill();
                
                ctx.strokeStyle = 'rgba(200, 220, 255, 0.6)';
                ctx.lineWidth = 2;
                ctx.stroke();
                
                ctx.restore();
            }
            
            refract(ray) {
                const refractedRays = [];
                
                for (let i = 0; i < 3; i++) {
                    const v1 = this.vertices[i];
                    const v2 = this.vertices[(i + 1) % 3];
                    
                    const intersection = this.lineIntersection(
                        ray.x, ray.y,
                        ray.x + Math.cos(ray.angle) * 1000,
                        ray.y + Math.sin(ray.angle) * 1000,
                        v1.x, v1.y, v2.x, v2.y
                    );
                    
                    if (intersection && ray.bounces < 3) {
                        const edgeAngle = Math.atan2(v2.y - v1.y, v2.x - v1.x);
                        const normal = edgeAngle + Math.PI / 2;
                        
                        if (ray.wavelength === 0) {
                            SPECTRUM.forEach((spec, idx) => {
                                const offset = (idx - SPECTRUM.length / 2) * dispersion * 0.02;
                                const newAngle = ray.angle + offset;
                                
                                refractedRays.push({
                                    x: intersection.x,
                                    y: intersection.y,
                                    angle: newAngle,
                                    color: spec.color,
                                    intensity: ray.intensity * 0.8,
                                    wavelength: spec.wavelength,
                                    bounces: ray.bounces + 1
                                });
                            });
                        } else {
                            const offset = ((ray.wavelength - 500) / 370) * dispersion * 0.02;
                            refractedRays.push({
                                x: intersection.x,
                                y: intersection.y,
                                angle: ray.angle + offset,
                                color: ray.color,
                                intensity: ray.intensity * 0.9,
                                wavelength: ray.wavelength,
                                bounces: ray.bounces + 1
                            });
                        }
                        break;
                    }
                }
                
                return refractedRays;
            }
            
            lineIntersection(x1, y1, x2, y2, x3, y3, x4, y4) {
                const denom = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
                if (Math.abs(denom) < 0.0001) return null;
                
                const t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / denom;
                const u = -((x1 - x2) * (y1 - y3) - (y1 - y2) * (x1 - x3)) / denom;
                
                if (t > 0.01 && t < 1 && u > 0 && u < 1) {
                    return {
                        x: x1 + t * (x2 - x1),
                        y: y1 + t * (y2 - y1)
                    };
                }
                return null;
            }
        }
        
        function drawBackground() {
            ctx.fillStyle = '#0a0a12';
            ctx.fillRect(0, 0, W, H);
        }
        
        function traceRays() {
            rays.length = 0;
            
            lights.forEach(light => {
                const emitted = light.emitRays();
                let queue = [...emitted];
                
                while (queue.length > 0) {
                    const ray = queue.shift();
                    rays.push(ray);
                    
                    prisms.forEach(prism => {
                        const refracted = prism.refract(ray);
                        refracted.forEach(r => {
                            if (r.bounces < 3) {
                                queue.push(r);
                            }
                            rays.push(r);
                        });
                    });
                }
            });
        }
        
        function drawRays() {
            rays.forEach(ray => {
                const length = 800;
                const endX = ray.x + Math.cos(ray.angle) * length;
                const endY = ray.y + Math.sin(ray.angle) * length;
                
                const gradient = ctx.createLinearGradient(ray.x, ray.y, endX, endY);
                gradient.addColorStop(0, ray.color);
                gradient.addColorStop(1, 'transparent');
                
                ctx.beginPath();
                ctx.moveTo(ray.x, ray.y);
                ctx.lineTo(endX, endY);
                ctx.strokeStyle = gradient;
                ctx.lineWidth = 2 * ray.intensity;
                ctx.globalAlpha = ray.intensity * 0.5;
                ctx.stroke();
                ctx.globalAlpha = 1;
            });
        }
        
        function updateStats() {
            document.getElementById('light-count').textContent = lights.length;
            document.getElementById('prism-count').textContent = prisms.length;
        }
        
        function animate() {
            time += 0.016;
            
            drawBackground();
            
            lights.forEach(l => l.update());
            traceRays();
            
            drawRays();
            prisms.forEach(p => p.draw());
            lights.forEach(l => l.draw());
            
            updateStats();
            
            requestAnimationFrame(animate);
        }
        
        canvas.onclick = e => {
            if (e.clientX < 200 && e.clientY < 280) return;
            
            if (placingLight) {
                lights.push(new LightSource(e.clientX, e.clientY));
            } else {
                prisms.push(new Prism(e.clientX, e.clientY));
            }
        };
        
        document.getElementById('light-mode').onclick = () => {
            placingLight = true;
            document.getElementById('light-mode').classList.add('active');
            document.getElementById('prism-mode').classList.remove('active');
        };
        
        document.getElementById('prism-mode').onclick = () => {
            placingLight = false;
            document.getElementById('prism-mode').classList.add('active');
            document.getElementById('light-mode').classList.remove('active');
        };
        
        document.getElementById('intensity').oninput = e => {
            lightIntensity = e.target.value / 100;
            document.getElementById('intensity-val').textContent = e.target.value;
        };
        
        document.getElementById('dispersion').oninput = e => {
            dispersion = e.target.value / 100;
            document.getElementById('dispersion-val').textContent = e.target.value;
        };
        
        document.getElementById('rotate-btn').onclick = () => {
            prisms.forEach(p => p.rotate(Math.PI / 6));
        };
        
        document.getElementById('clear-btn').onclick = () => {
            lights.length = 0;
            prisms.length = 0;
            rays.length = 0;
        };
        
        animate();
    </script>
</body>
</html>