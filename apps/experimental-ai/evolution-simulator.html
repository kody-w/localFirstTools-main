<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Evolution Simulator</title>
    <meta name="description" content="Watch natural selection in action. Creatures evolve speed, size, and senses to survive in a competitive environment.">
    <style>
        body { margin: 0; overflow: hidden; background: #222; font-family: sans-serif; color: #eee; }
        canvas { display: block; }
        
        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0,0,0,0.7);
            padding: 10px;
            border-radius: 8px;
            pointer-events: none;
        }
        
        #stats {
            font-size: 12px;
            line-height: 1.5;
        }
        
        #controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
        }
        
        button {
            background: #444;
            color: #fff;
            border: 1px solid #666;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
        }
        
        button:hover { background: #555; }
        
        #graph-container {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 200px;
            height: 100px;
            background: rgba(0,0,0,0.5);
            border: 1px solid #444;
        }
    </style>
</head>
<body>

    <div id="ui">
        <div style="font-weight: bold; margin-bottom: 5px;">Evolution Stats</div>
        <div id="stats">
            Population: 0<br>
            Avg Speed: 0<br>
            Avg Size: 0<br>
            Avg Sense: 0<br>
            Generation: 0
        </div>
    </div>

    <div id="graph-container">
        <canvas id="graph" width="200" height="100"></canvas>
    </div>

    <div id="controls">
        <button onclick="resetSim()">Reset</button>
        <button onclick="togglePause()">Pause/Play</button>
        <button onclick="toggleFast()">Fast Forward (x5)</button>
    </div>

    <canvas id="world"></canvas>

    <script>
        const canvas = document.getElementById('world');
        const ctx = canvas.getContext('2d');
        const graphCanvas = document.getElementById('graph');
        const graphCtx = graphCanvas.getContext('2d');
        
        let width, height;
        
        function resize() {
            width = window.innerWidth;
            height = window.innerHeight;
            canvas.width = width;
            canvas.height = height;
        }
        window.addEventListener('resize', resize);
        resize();

        // --- Config ---
        const FOOD_VALUE = 20;
        const START_POP = 50;
        const MUTATION_RATE = 0.1;
        const FOOD_SPAWN_RATE = 2; // Food per frame (probabilistic)

        // --- Classes ---
        class Vector {
            constructor(x, y) { this.x = x; this.y = y; }
            add(v) { this.x += v.x; this.y += v.y; return this; }
            sub(v) { this.x -= v.x; this.y -= v.y; return this; }
            mult(n) { this.x *= n; this.y *= n; return this; }
            mag() { return Math.sqrt(this.x*this.x + this.y*this.y); }
            normalize() {
                const m = this.mag();
                if (m > 0) this.mult(1/m);
                return this;
            }
            limit(max) {
                if (this.mag() > max) {
                    this.normalize();
                    this.mult(max);
                }
                return this;
            }
            copy() { return new Vector(this.x, this.y); }
            dist(v) { return Math.hypot(this.x - v.x, this.y - v.y); }
        }

        class Creature {
            constructor(x, y, dna) {
                this.pos = new Vector(x, y);
                this.vel = new Vector(Math.random()-0.5, Math.random()-0.5);
                this.acc = new Vector(0, 0);
                
                // DNA
                this.dna = dna || {
                    speed: 2 + Math.random(),
                    size: 5 + Math.random() * 5,
                    sense: 50 + Math.random() * 50
                };
                
                this.energy = 100;
                this.maxEnergy = 200;
                this.age = 0;
                this.dead = false;
                
                // Color based on DNA
                // Red = Speed, Green = Size, Blue = Sense
                const r = Math.min(255, this.dna.speed * 50);
                const g = Math.min(255, this.dna.size * 20);
                const b = Math.min(255, this.dna.sense * 2);
                this.color = `rgb(${r},${g},${b})`;
            }
            
            update() {
                this.age++;
                
                // Energy Cost
                // Speed costs energy^2
                // Size costs energy^3 (cube law)
                // Sense costs linear
                const cost = (this.dna.speed * this.dna.speed * 0.005) + 
                             (this.dna.size * this.dna.size * this.dna.size * 0.0001) +
                             (this.dna.sense * 0.001);
                
                this.energy -= cost;
                
                if (this.energy <= 0) this.dead = true;
                
                // Movement
                this.vel.add(this.acc);
                this.vel.limit(this.dna.speed);
                this.pos.add(this.vel);
                this.acc.mult(0);
                
                // Boundaries
                if (this.pos.x < 0) this.pos.x = width;
                if (this.pos.x > width) this.pos.x = 0;
                if (this.pos.y < 0) this.pos.y = height;
                if (this.pos.y > height) this.pos.y = 0;
            }
            
            seek(target) {
                const desired = target.copy().sub(this.pos);
                desired.normalize();
                desired.mult(this.dna.speed);
                const steer = desired.sub(this.vel);
                steer.limit(0.5); // Turn speed
                this.acc.add(steer);
            }
            
            behavior(food) {
                let closest = null;
                let record = Infinity;
                
                // Find closest food
                for (let i = 0; i < food.length; i++) {
                    const d = this.pos.dist(food[i]);
                    if (d < this.dna.sense && d < record) {
                        record = d;
                        closest = food[i];
                    }
                }
                
                if (closest) {
                    this.seek(closest);
                } else {
                    // Wander
                    const wander = new Vector(Math.random()-0.5, Math.random()-0.5);
                    wander.mult(0.5);
                    this.acc.add(wander);
                }
            }
            
            eat(food) {
                for (let i = food.length - 1; i >= 0; i--) {
                    const d = this.pos.dist(food[i]);
                    if (d < this.dna.size) {
                        this.energy += FOOD_VALUE;
                        if (this.energy > this.maxEnergy) this.energy = this.maxEnergy;
                        food.splice(i, 1);
                    }
                }
            }
            
            reproduce() {
                if (this.energy > this.maxEnergy * 0.8 && Math.random() < 0.005) {
                    this.energy *= 0.5;
                    
                    // Mutate
                    const newDna = {
                        speed: this.dna.speed + (Math.random()-0.5) * MUTATION_RATE,
                        size: this.dna.size + (Math.random()-0.5) * MUTATION_RATE,
                        sense: this.dna.sense + (Math.random()-0.5) * MUTATION_RATE * 10
                    };
                    
                    // Clamp
                    newDna.speed = Math.max(0.5, newDna.speed);
                    newDna.size = Math.max(2, newDna.size);
                    newDna.sense = Math.max(10, newDna.sense);
                    
                    return new Creature(this.pos.x, this.pos.y, newDna);
                }
                return null;
            }
            
            draw() {
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.pos.x, this.pos.y, this.dna.size, 0, Math.PI*2);
                ctx.fill();
                
                // Draw sense radius (faint)
                if (selectedCreature === this) {
                    ctx.strokeStyle = 'rgba(255,255,255,0.2)';
                    ctx.beginPath();
                    ctx.arc(this.pos.x, this.pos.y, this.dna.sense, 0, Math.PI*2);
                    ctx.stroke();
                }
            }
        }

        // --- State ---
        let creatures = [];
        let food = [];
        let paused = false;
        let speedMult = 1;
        let selectedCreature = null;
        let history = []; // For graph

        function init() {
            creatures = [];
            food = [];
            for (let i = 0; i < START_POP; i++) {
                creatures.push(new Creature(Math.random()*width, Math.random()*height));
            }
            for (let i = 0; i < 100; i++) {
                food.push(new Vector(Math.random()*width, Math.random()*height));
            }
        }

        function update() {
            if (paused) return;
            
            for (let s = 0; s < speedMult; s++) {
                // Spawn Food
                if (Math.random() < 0.1 * food.length < 200) { // Limit food
                    food.push(new Vector(Math.random()*width, Math.random()*height));
                }
                if (food.length < 50) {
                     food.push(new Vector(Math.random()*width, Math.random()*height));
                }

                // Update Creatures
                for (let i = creatures.length - 1; i >= 0; i--) {
                    const c = creatures[i];
                    c.behavior(food);
                    c.update();
                    c.eat(food);
                    
                    if (c.dead) {
                        creatures.splice(i, 1);
                        // Spawn food where it died (circle of life)
                        food.push(c.pos.copy());
                    } else {
                        const child = c.reproduce();
                        if (child) creatures.push(child);
                    }
                }
                
                // Extinction check
                if (creatures.length === 0) {
                    init(); // Restart
                }
            }
            
            updateStats();
        }

        function draw() {
            ctx.fillStyle = '#222';
            ctx.fillRect(0, 0, width, height);
            
            // Draw Food
            ctx.fillStyle = '#0f0';
            for (let f of food) {
                ctx.beginPath();
                ctx.arc(f.x, f.y, 2, 0, Math.PI*2);
                ctx.fill();
            }
            
            // Draw Creatures
            for (let c of creatures) {
                c.draw();
            }
            
            update();
            requestAnimationFrame(draw);
        }
        
        function updateStats() {
            if (creatures.length === 0) return;
            
            let avgSpeed = 0;
            let avgSize = 0;
            let avgSense = 0;
            
            for (let c of creatures) {
                avgSpeed += c.dna.speed;
                avgSize += c.dna.size;
                avgSense += c.dna.sense;
            }
            
            avgSpeed /= creatures.length;
            avgSize /= creatures.length;
            avgSense /= creatures.length;
            
            document.getElementById('stats').innerHTML = `
                Population: ${creatures.length}<br>
                Avg Speed: ${avgSpeed.toFixed(2)}<br>
                Avg Size: ${avgSize.toFixed(2)}<br>
                Avg Sense: ${avgSense.toFixed(2)}
            `;
            
            // Graph
            if (Math.random() < 0.05) { // Sample occasionally
                history.push({s: avgSpeed, z: avgSize, n: creatures.length});
                if (history.length > 100) history.shift();
                drawGraph();
            }
        }
        
        function drawGraph() {
            graphCtx.clearRect(0, 0, 200, 100);
            
            // Draw Speed (Red)
            graphCtx.strokeStyle = '#f00';
            graphCtx.beginPath();
            for (let i = 0; i < history.length; i++) {
                const x = i * 2;
                const y = 100 - (history[i].s * 10);
                if (i===0) graphCtx.moveTo(x, y); else graphCtx.lineTo(x, y);
            }
            graphCtx.stroke();
            
            // Draw Size (Green)
            graphCtx.strokeStyle = '#0f0';
            graphCtx.beginPath();
            for (let i = 0; i < history.length; i++) {
                const x = i * 2;
                const y = 100 - (history[i].z * 5);
                if (i===0) graphCtx.moveTo(x, y); else graphCtx.lineTo(x, y);
            }
            graphCtx.stroke();
        }

        function resetSim() { init(); }
        function togglePause() { paused = !paused; }
        function toggleFast() { speedMult = speedMult === 1 ? 5 : 1; }
        
        canvas.addEventListener('click', e => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            const mouse = new Vector(x, y);
            
            let closest = null;
            let record = 50;
            for (let c of creatures) {
                const d = c.pos.dist(mouse);
                if (d < record) {
                    record = d;
                    closest = c;
                }
            }
            selectedCreature = closest;
        });

        init();
        draw();

    </script>
</body>
</html>