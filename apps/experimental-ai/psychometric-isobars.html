<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Psychometric Isobars</title>
    <meta name="description" content="Plant emotional weather stations that generate pressure systems, isobar lines, and atmospheric fronts based on mood">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background: #0a0a15; min-height: 100vh; font-family: 'Georgia', serif; color: #8090a0; overflow: hidden; }
        #canvas { position: fixed; top: 0; left: 0; cursor: crosshair; }
        #controls {
            position: fixed; top: 20px; left: 20px; background: rgba(15,15,30,0.95);
            padding: 20px; border-radius: 10px; border: 1px solid rgba(100,120,160,0.3);
            z-index: 100;
        }
        h3 { margin-bottom: 15px; color: #a0b0d0; font-weight: normal; }
        .control-row { margin: 10px 0; }
        label { display: block; font-size: 11px; margin-bottom: 5px; opacity: 0.8; }
        input[type="range"] { width: 140px; }
        .value { float: right; color: #b0c0e0; font-size: 12px; }
        .emotion-btn {
            display: inline-block; padding: 8px 12px; margin: 3px;
            background: rgba(60,70,100,0.4); border: 1px solid rgba(100,120,160,0.4);
            color: #90a0c0; cursor: pointer; border-radius: 6px; font-family: inherit;
            font-size: 11px;
        }
        .emotion-btn.selected { background: rgba(100,120,180,0.6); border-color: rgba(150,170,220,0.6); }
        button {
            display: block; width: 100%; padding: 10px; margin: 6px 0;
            background: rgba(60,70,100,0.4); border: 1px solid rgba(100,120,160,0.4);
            color: #90a0c0; cursor: pointer; border-radius: 6px; font-family: inherit;
        }
        #info { position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); font-size: 12px; opacity: 0.5; z-index: 100; }
        #legend { position: fixed; right: 20px; top: 20px; background: rgba(15,15,30,0.9); padding: 15px; border-radius: 8px; font-size: 10px; z-index: 100; }
        .legend-item { margin: 5px 0; display: flex; align-items: center; gap: 8px; }
        .legend-color { width: 20px; height: 20px; border-radius: 50%; }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div id="controls">
        <h3>Psychometric Isobars</h3>
        <div class="control-row">
            <label>Select Emotion</label>
            <div id="emotion-palette"></div>
        </div>
        <div class="control-row">
            <label>Pressure Intensity <span class="value" id="pressure-val">50</span></label>
            <input type="range" id="pressure" min="20" max="100" value="50">
        </div>
        <div class="control-row">
            <label>Wind Speed <span class="value" id="wind-val">30</span></label>
            <input type="range" id="wind" min="0" max="100" value="30">
        </div>
        <button id="storm-btn">Trigger Storm</button>
        <button id="clear-btn">Clear Atmosphere</button>
    </div>
    <div id="legend">
        <div style="color: #a0b0d0; margin-bottom: 8px;">Emotional Pressures</div>
        <div class="legend-item"><div class="legend-color" style="background: #ff6040;"></div> Anger (High)</div>
        <div class="legend-item"><div class="legend-color" style="background: #4080ff;"></div> Grief (Low)</div>
        <div class="legend-item"><div class="legend-color" style="background: #ffdd40;"></div> Joy (High)</div>
        <div class="legend-item"><div class="legend-color" style="background: #40ffa0;"></div> Calm (Stable)</div>
        <div class="legend-item"><div class="legend-color" style="background: #a040ff;"></div> Fear (Chaotic)</div>
        <div class="legend-item"><div class="legend-color" style="background: #ff80c0;"></div> Love (Warm)</div>
    </div>
    <div id="info">Click to place emotional weather stations | Watch pressure systems form</div>
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        let W, H;
        function resize() { W = canvas.width = innerWidth; H = canvas.height = innerHeight; }
        resize(); window.onresize = resize;
        
        const EMOTIONS = {
            anger: { hue: 10, pressure: 1.5, temp: 'hot', chaos: 0.3, name: 'Anger' },
            grief: { hue: 220, pressure: -1.2, temp: 'cold', chaos: 0.1, name: 'Grief' },
            joy: { hue: 50, pressure: 1.2, temp: 'warm', chaos: 0.2, name: 'Joy' },
            calm: { hue: 150, pressure: 0, temp: 'neutral', chaos: 0, name: 'Calm' },
            fear: { hue: 280, pressure: 0.8, temp: 'cold', chaos: 0.6, name: 'Fear' },
            love: { hue: 340, pressure: 0.5, temp: 'warm', chaos: 0.15, name: 'Love' }
        };
        
        let selectedEmotion = 'anger';
        let pressureIntensity = 0.5;
        let windSpeed = 0.3;
        let time = 0;
        
        const stations = [];
        const particles = [];
        const fronts = [];
        
        function createPalette() {
            const palette = document.getElementById('emotion-palette');
            Object.entries(EMOTIONS).forEach(([key, emotion]) => {
                const btn = document.createElement('div');
                btn.className = 'emotion-btn' + (key === selectedEmotion ? ' selected' : '');
                btn.textContent = emotion.name;
                btn.style.borderColor = "hsl(" + emotion.hue + ", 60%, 50%)";
                btn.onclick = () => {
                    document.querySelectorAll('.emotion-btn').forEach(b => b.classList.remove('selected'));
                    btn.classList.add('selected');
                    selectedEmotion = key;
                };
                palette.appendChild(btn);
            });
        }
        createPalette();
        
        class WeatherStation {
            constructor(x, y, emotionKey) {
                this.x = x;
                this.y = y;
                this.emotion = EMOTIONS[emotionKey];
                this.emotionKey = emotionKey;
                this.radius = 150 * pressureIntensity;
                this.age = 0;
                this.pulse = Math.random() * Math.PI * 2;
            }
            
            update() {
                this.age += 0.016;
                this.pulse += 0.03;
                
                if (Math.random() < 0.1 * Math.abs(this.emotion.pressure)) {
                    particles.push({
                        x: this.x + (Math.random() - 0.5) * 50,
                        y: this.y + (Math.random() - 0.5) * 50,
                        vx: (Math.random() - 0.5) * windSpeed * 3,
                        vy: (Math.random() - 0.5) * windSpeed * 3 - this.emotion.pressure * 0.5,
                        size: 2 + Math.random() * 3,
                        life: 1,
                        hue: this.emotion.hue
                    });
                }
            }
            
            getPressureAt(x, y) {
                const dist = Math.hypot(x - this.x, y - this.y);
                if (dist > this.radius * 2) return 0;
                const falloff = 1 - dist / (this.radius * 2);
                return this.emotion.pressure * pressureIntensity * falloff * falloff;
            }
            
            draw() {
                const pulse = 1 + Math.sin(this.pulse) * 0.1;
                
                ctx.beginPath();
                ctx.arc(this.x, this.y, 15 * pulse, 0, Math.PI * 2);
                ctx.fillStyle = "hsla(" + this.emotion.hue + ", 70%, 50%, 0.9)";
                ctx.fill();
                
                const gradient = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, this.radius);
                gradient.addColorStop(0, "hsla(" + this.emotion.hue + ", 60%, 50%, 0.2)");
                gradient.addColorStop(0.5, "hsla(" + this.emotion.hue + ", 50%, 40%, 0.1)");
                gradient.addColorStop(1, "transparent");
                ctx.fillStyle = gradient;
                ctx.fillRect(this.x - this.radius, this.y - this.radius, this.radius * 2, this.radius * 2);
                
                ctx.font = '10px Georgia';
                ctx.fillStyle = "hsla(" + this.emotion.hue + ", 60%, 70%, 0.8)";
                ctx.textAlign = 'center';
                ctx.fillText(this.emotion.name, this.x, this.y + 30);
                
                const pressureLabel = this.emotion.pressure > 0 ? 'H' : (this.emotion.pressure < 0 ? 'L' : '~');
                ctx.font = 'bold 14px Georgia';
                ctx.fillText(pressureLabel, this.x, this.y + 5);
            }
        }
        
        function calculatePressureField() {
            const field = [];
            const resolution = 30;
            
            for (let y = 0; y < H; y += resolution) {
                for (let x = 0; x < W; x += resolution) {
                    let totalPressure = 0;
                    let dominantHue = 200;
                    let maxInfluence = 0;
                    
                    stations.forEach(station => {
                        const pressure = station.getPressureAt(x, y);
                        totalPressure += pressure;
                        
                        const dist = Math.hypot(x - station.x, y - station.y);
                        const influence = Math.max(0, 1 - dist / (station.radius * 2));
                        if (influence > maxInfluence) {
                            maxInfluence = influence;
                            dominantHue = station.emotion.hue;
                        }
                    });
                    
                    field.push({ x, y, pressure: totalPressure, hue: dominantHue, influence: maxInfluence });
                }
            }
            return field;
        }
        
        function drawIsobars() {
            if (stations.length === 0) return;
            
            const levels = [-1.5, -1, -0.5, 0, 0.5, 1, 1.5];
            const resolution = 15;
            
            levels.forEach(level => {
                ctx.beginPath();
                let started = false;
                
                for (let y = 0; y < H; y += resolution) {
                    for (let x = 0; x < W; x += resolution) {
                        let totalPressure = 0;
                        let dominantHue = 200;
                        let maxInfluence = 0;
                        
                        stations.forEach(station => {
                            const pressure = station.getPressureAt(x, y);
                            totalPressure += pressure;
                            
                            const dist = Math.hypot(x - station.x, y - station.y);
                            const influence = Math.max(0, 1 - dist / (station.radius * 2));
                            if (influence > maxInfluence) {
                                maxInfluence = influence;
                                dominantHue = station.emotion.hue;
                            }
                        });
                        
                        if (Math.abs(totalPressure - level) < 0.15) {
                            if (!started) {
                                ctx.moveTo(x, y);
                                started = true;
                            } else {
                                ctx.lineTo(x, y);
                            }
                        }
                    }
                }
                
                const alpha = 0.3 + Math.abs(level) * 0.2;
                ctx.strokeStyle = level > 0 ? 
                    "rgba(255, 100, 80, " + alpha + ")" : 
                    (level < 0 ? "rgba(80, 150, 255, " + alpha + ")" : "rgba(150, 150, 150, " + alpha + ")");
                ctx.lineWidth = 1 + Math.abs(level) * 0.5;
                ctx.stroke();
            });
        }
        
        function drawFronts() {
            if (stations.length < 2) return;
            
            for (let i = 0; i < stations.length; i++) {
                for (let j = i + 1; j < stations.length; j++) {
                    const s1 = stations[i];
                    const s2 = stations[j];
                    
                    const dist = Math.hypot(s1.x - s2.x, s1.y - s2.y);
                    if (dist > 300) continue;
                    
                    const pressureDiff = Math.abs(s1.emotion.pressure - s2.emotion.pressure);
                    if (pressureDiff < 0.5) continue;
                    
                    const midX = (s1.x + s2.x) / 2;
                    const midY = (s1.y + s2.y) / 2;
                    const perpX = -(s2.y - s1.y) / dist;
                    const perpY = (s2.x - s1.x) / dist;
                    
                    ctx.beginPath();
                    ctx.moveTo(s1.x, s1.y);
                    
                    const waveAmplitude = 20 + pressureDiff * 15;
                    const segments = 20;
                    for (let t = 0; t <= segments; t++) {
                        const ratio = t / segments;
                        const x = s1.x + (s2.x - s1.x) * ratio;
                        const y = s1.y + (s2.y - s1.y) * ratio;
                        const wave = Math.sin(ratio * Math.PI * 4 + time * 2) * waveAmplitude * (1 - Math.abs(ratio - 0.5) * 2);
                        ctx.lineTo(x + perpX * wave, y + perpY * wave);
                    }
                    
                    const warmer = s1.emotion.temp === 'hot' || s1.emotion.temp === 'warm' ? s1 : s2;
                    const frontHue = warmer.emotion.hue;
                    
                    ctx.strokeStyle = "hsla(" + frontHue + ", 70%, 60%, 0.6)";
                    ctx.lineWidth = 3;
                    ctx.stroke();
                    
                    for (let t = 0; t < 1; t += 0.15) {
                        const x = s1.x + (s2.x - s1.x) * t;
                        const y = s1.y + (s2.y - s1.y) * t;
                        
                        ctx.beginPath();
                        if (warmer === s1) {
                            ctx.arc(x, y, 5, 0, Math.PI);
                        } else {
                            ctx.moveTo(x - 5, y);
                            ctx.lineTo(x, y - 8);
                            ctx.lineTo(x + 5, y);
                        }
                        ctx.fillStyle = "hsla(" + frontHue + ", 70%, 60%, 0.8)";
                        ctx.fill();
                    }
                }
            }
        }
        
        function drawWindField() {
            if (stations.length === 0 || windSpeed < 0.1) return;
            
            const resolution = 60;
            
            for (let y = resolution; y < H; y += resolution) {
                for (let x = resolution; x < W; x += resolution) {
                    let totalVX = 0;
                    let totalVY = 0;
                    let totalInfluence = 0;
                    
                    stations.forEach(station => {
                        const dx = x - station.x;
                        const dy = y - station.y;
                        const dist = Math.hypot(dx, dy);
                        
                        if (dist < station.radius * 2 && dist > 20) {
                            const influence = 1 - dist / (station.radius * 2);
                            const perpX = -dy / dist;
                            const perpY = dx / dist;
                            const dir = station.emotion.pressure > 0 ? 1 : -1;
                            
                            totalVX += perpX * dir * influence * station.emotion.pressure;
                            totalVY += perpY * dir * influence * station.emotion.pressure;
                            totalInfluence += influence;
                        }
                    });
                    
                    if (totalInfluence > 0.1) {
                        const length = Math.hypot(totalVX, totalVY) * 20 * windSpeed;
                        if (length > 5) {
                            const angle = Math.atan2(totalVY, totalVX);
                            
                            ctx.beginPath();
                            ctx.moveTo(x, y);
                            ctx.lineTo(x + Math.cos(angle) * length, y + Math.sin(angle) * length);
                            ctx.strokeStyle = "rgba(150, 170, 200, " + (0.2 + totalInfluence * 0.3) + ")";
                            ctx.lineWidth = 1;
                            ctx.stroke();
                            
                            ctx.beginPath();
                            ctx.moveTo(x + Math.cos(angle) * length, y + Math.sin(angle) * length);
                            ctx.lineTo(
                                x + Math.cos(angle) * length - Math.cos(angle - 0.5) * 5,
                                y + Math.sin(angle) * length - Math.sin(angle - 0.5) * 5
                            );
                            ctx.lineTo(
                                x + Math.cos(angle) * length - Math.cos(angle + 0.5) * 5,
                                y + Math.sin(angle) * length - Math.sin(angle + 0.5) * 5
                            );
                            ctx.closePath();
                            ctx.fill();
                        }
                    }
                }
            }
        }
        
        function drawParticles() {
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                
                stations.forEach(station => {
                    const dx = station.x - p.x;
                    const dy = station.y - p.y;
                    const dist = Math.hypot(dx, dy);
                    
                    if (dist < station.radius * 2 && dist > 20) {
                        const force = station.emotion.pressure * 0.01 / (dist * 0.1);
                        const perpX = -dy / dist;
                        const perpY = dx / dist;
                        const dir = station.emotion.pressure > 0 ? 1 : -1;
                        
                        p.vx += perpX * dir * force * windSpeed;
                        p.vy += perpY * dir * force * windSpeed;
                        
                        p.vx += (Math.random() - 0.5) * station.emotion.chaos * 0.5;
                        p.vy += (Math.random() - 0.5) * station.emotion.chaos * 0.5;
                    }
                });
                
                p.x += p.vx;
                p.y += p.vy;
                p.vx *= 0.99;
                p.vy *= 0.99;
                p.life -= 0.008;
                
                if (p.life <= 0 || p.x < -50 || p.x > W + 50 || p.y < -50 || p.y > H + 50) {
                    particles.splice(i, 1);
                    continue;
                }
                
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size * p.life, 0, Math.PI * 2);
                ctx.fillStyle = "hsla(" + p.hue + ", 60%, 60%, " + (p.life * 0.5) + ")";
                ctx.fill();
            }
        }
        
        function drawBackground() {
            const gradient = ctx.createRadialGradient(W/2, H/2, 0, W/2, H/2, Math.max(W, H) * 0.7);
            gradient.addColorStop(0, '#101525');
            gradient.addColorStop(1, '#0a0a15');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, W, H);
            
            for (let i = 0; i < 50; i++) {
                const x = (i * 137) % W;
                const y = (i * 89) % H;
                ctx.beginPath();
                ctx.arc(x, y, 0.5, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(150, 170, 200, 0.2)';
                ctx.fill();
            }
        }
        
        function triggerStorm() {
            stations.forEach(station => {
                for (let i = 0; i < 30; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const dist = Math.random() * 100;
                    particles.push({
                        x: station.x + Math.cos(angle) * dist,
                        y: station.y + Math.sin(angle) * dist,
                        vx: (Math.random() - 0.5) * 10,
                        vy: (Math.random() - 0.5) * 10,
                        size: 3 + Math.random() * 4,
                        life: 1,
                        hue: station.emotion.hue
                    });
                }
            });
        }
        
        function animate() {
            time += 0.016;
            
            drawBackground();
            drawIsobars();
            drawWindField();
            drawFronts();
            
            stations.forEach(s => s.update());
            stations.forEach(s => s.draw());
            
            drawParticles();
            
            requestAnimationFrame(animate);
        }
        
        canvas.onclick = e => {
            stations.push(new WeatherStation(e.clientX, e.clientY, selectedEmotion));
        };
        
        document.getElementById('pressure').oninput = e => {
            pressureIntensity = e.target.value / 100;
            document.getElementById('pressure-val').textContent = e.target.value;
            stations.forEach(s => s.radius = 150 * pressureIntensity);
        };
        
        document.getElementById('wind').oninput = e => {
            windSpeed = e.target.value / 100;
            document.getElementById('wind-val').textContent = e.target.value;
        };
        
        document.getElementById('storm-btn').onclick = triggerStorm;
        
        document.getElementById('clear-btn').onclick = () => {
            stations.length = 0;
            particles.length = 0;
        };
        
        animate();
    </script>
</body>
</html>