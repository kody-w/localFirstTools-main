<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <title>LEVIATHAN: OMNIVERSE v11.0</title>
  <style>
    /* ===== DESIGN TOKENS ===== */
    :root {
      /* Colors */
      --color-bg: #0a0f14;
      --color-bg-light: #111922;
      --color-panel: rgba(10, 15, 20, 0.85);
      --color-panel-solid: #0d1319;
      --color-border: rgba(255, 255, 255, 0.08);
      --color-border-light: rgba(255, 255, 255, 0.15);
      --color-text-primary: #e8e8e8;
      --color-text-secondary: #8899aa;
      --color-text-muted: #556677;
      --color-accent-gold: #fb0;
      --color-accent-cyan: #0ff;
      --color-accent-purple: #bf00ff;
      --color-accent-blue: #4488ff;
      --color-accent-green: #00ff88;
      --color-accent-red: #ff4444;
      --color-accent-orange: #ff8800;

      /* Spacing (4px grid) */
      --space-1: 4px;
      --space-2: 8px;
      --space-3: 12px;
      --space-4: 16px;
      --space-5: 20px;
      --space-6: 24px;
      --space-7: 28px;
      --space-8: 32px;
      --space-9: 36px;
      --space-10: 40px;
      --space-11: 44px;
      --space-12: 48px;

      /* Typography */
      --font-xs: 10px;
      --font-sm: 12px;
      --font-md: 14px;
      --font-lg: 18px;
      --font-xl: 24px;
      --font-2xl: 36px;
      --font-3xl: 48px;

      /* Z-index layers */
      --z-base: 1;
      --z-ui: 10;
      --z-panels: 100;
      --z-overlays: 500;
      --z-modals: 1000;
      --z-critical: 9999;

      /* Touch */
      --touch-target: 44px;

      /* Border radii */
      --radius-sm: 4px;
      --radius-md: 8px;
      --radius-lg: 12px;
      --radius-xl: 16px;
      --radius-full: 9999px;

      /* Transitions */
      --transition-fast: 150ms ease;
      --transition-normal: 250ms ease;
      --transition-slow: 400ms ease;

      /* Shadows */
      --shadow-sm: 0 1px 3px rgba(0,0,0,0.4);
      --shadow-md: 0 4px 12px rgba(0,0,0,0.5);
      --shadow-lg: 0 8px 32px rgba(0,0,0,0.6);
      --shadow-glow-cyan: 0 0 20px rgba(0,255,255,0.15);
      --shadow-glow-gold: 0 0 20px rgba(255,187,0,0.15);

      /* iOS safe areas */
      --safe-top: env(safe-area-inset-top, 0px);
      --safe-bottom: env(safe-area-inset-bottom, 0px);
      --safe-left: env(safe-area-inset-left, 0px);
      --safe-right: env(safe-area-inset-right, 0px);
    }

    /* ===== RESET & BASE ===== */
    *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

    body {
      background: var(--color-bg);
      color: var(--color-text-primary);
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
      overflow: hidden;
      width: 100vw;
      height: 100vh;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
      touch-action: none;
      -webkit-user-select: none;
      user-select: none;
    }

    /* ===== ACCESSIBILITY ===== */
    .skip-links a {
      position: absolute;
      left: -9999px;
      top: var(--space-2);
      z-index: var(--z-critical);
      background: var(--color-accent-gold);
      color: var(--color-bg);
      padding: var(--space-2) var(--space-4);
      border-radius: var(--radius-sm);
      font-weight: 700;
      text-decoration: none;
    }
    .skip-links a:focus {
      left: var(--space-4);
    }

    .sr-only {
      position: absolute;
      width: 1px;
      height: 1px;
      padding: 0;
      margin: -1px;
      overflow: hidden;
      clip: rect(0,0,0,0);
      white-space: nowrap;
      border: 0;
    }

    /* ===== CANVAS ===== */
    #gameCanvas {
      display: block;
      width: 100vw;
      height: 100vh;
      position: fixed;
      top: 0;
      left: 0;
      z-index: var(--z-base);
    }

    /* ===== LOADING SCREEN ===== */
    #loading-screen {
      position: fixed;
      inset: 0;
      z-index: var(--z-critical);
      background: var(--color-bg);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: var(--space-6);
      transition: opacity var(--transition-slow);
    }
    #loading-screen.fade-out {
      opacity: 0;
      pointer-events: none;
    }
    .loading-title {
      font-size: var(--font-2xl);
      font-weight: 700;
      letter-spacing: 6px;
      text-transform: uppercase;
      color: var(--color-accent-gold);
      text-shadow: 0 0 30px rgba(255,187,0,0.3);
    }
    .loading-subtitle {
      font-size: var(--font-md);
      color: var(--color-text-secondary);
      letter-spacing: 3px;
      text-transform: uppercase;
    }
    .loading-spinner {
      width: 40px;
      height: 40px;
      border: 3px solid var(--color-border);
      border-top-color: var(--color-accent-cyan);
      border-radius: 50%;
      animation: spin 0.8s linear infinite;
    }
    .loading-status {
      font-size: var(--font-sm);
      color: var(--color-text-muted);
    }
    @keyframes spin { to { transform: rotate(360deg); } }

    /* ===== HUD OVERLAY ===== */
    #hud {
      position: fixed;
      inset: 0;
      z-index: var(--z-ui);
      pointer-events: none;
      padding: var(--safe-top) var(--safe-right) var(--safe-bottom) var(--safe-left);
    }
    #hud > * { pointer-events: auto; }

    /* Top Bar */
    .hud-top {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: var(--space-3) var(--space-4);
      background: linear-gradient(180deg, rgba(10,15,20,0.7) 0%, transparent 100%);
    }
    .hud-title {
      font-size: var(--font-sm);
      font-weight: 700;
      letter-spacing: 3px;
      text-transform: uppercase;
      color: var(--color-accent-gold);
      text-shadow: 0 0 10px rgba(255,187,0,0.2);
    }
    .hud-mode {
      font-size: var(--font-xs);
      letter-spacing: 2px;
      text-transform: uppercase;
      color: var(--color-accent-cyan);
      background: rgba(0,255,255,0.08);
      padding: var(--space-1) var(--space-3);
      border-radius: var(--radius-full);
      border: 1px solid rgba(0,255,255,0.2);
    }
    #fps-counter {
      font-size: var(--font-xs);
      font-family: 'Courier New', monospace;
      color: var(--color-text-muted);
      min-width: 60px;
      text-align: right;
    }

    /* Bottom Bar */
    .hud-bottom {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      padding: var(--space-4);
      padding-bottom: calc(var(--space-4) + var(--safe-bottom));
      background: linear-gradient(0deg, rgba(10,15,20,0.7) 0%, transparent 100%);
      display: flex;
      gap: var(--space-4);
      align-items: flex-end;
    }
    .stat-bar {
      flex: 1;
      max-width: 280px;
    }
    .stat-bar-label {
      font-size: var(--font-xs);
      letter-spacing: 2px;
      text-transform: uppercase;
      color: var(--color-text-secondary);
      margin-bottom: var(--space-1);
      display: flex;
      justify-content: space-between;
    }
    .stat-bar-track {
      height: 6px;
      background: rgba(255,255,255,0.06);
      border-radius: var(--radius-full);
      overflow: hidden;
      border: 1px solid var(--color-border);
    }
    .stat-bar-fill {
      height: 100%;
      border-radius: var(--radius-full);
      transition: width var(--transition-normal);
    }
    .health-fill {
      background: linear-gradient(90deg, var(--color-accent-green), var(--color-accent-cyan));
      box-shadow: 0 0 8px rgba(0,255,136,0.3);
    }
    .health-fill.warning { background: linear-gradient(90deg, var(--color-accent-orange), var(--color-accent-gold)); }
    .health-fill.critical { background: linear-gradient(90deg, var(--color-accent-red), var(--color-accent-orange)); }
    .energy-fill {
      background: linear-gradient(90deg, var(--color-accent-blue), var(--color-accent-cyan));
      box-shadow: 0 0 8px rgba(68,136,255,0.3);
    }

    /* Notifications */
    #notification-area {
      position: absolute;
      top: 60px;
      right: var(--space-4);
      display: flex;
      flex-direction: column;
      gap: var(--space-2);
      max-width: 320px;
      z-index: var(--z-overlays);
    }
    .notification {
      padding: var(--space-3) var(--space-4);
      border-radius: var(--radius-md);
      font-size: var(--font-sm);
      color: var(--color-text-primary);
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      border: 1px solid var(--color-border-light);
      animation: notifSlideIn var(--transition-normal) forwards;
      cursor: pointer;
      position: relative;
      overflow: hidden;
    }
    .notification::before {
      content: '';
      position: absolute;
      left: 0;
      top: 0;
      bottom: 0;
      width: 3px;
    }
    .notification.info { background: rgba(68,136,255,0.15); }
    .notification.info::before { background: var(--color-accent-blue); }
    .notification.success { background: rgba(0,255,136,0.12); }
    .notification.success::before { background: var(--color-accent-green); }
    .notification.warning { background: rgba(255,136,0,0.12); }
    .notification.warning::before { background: var(--color-accent-orange); }
    .notification.error { background: rgba(255,68,68,0.15); }
    .notification.error::before { background: var(--color-accent-red); }
    .notification.fade-out {
      animation: notifSlideOut var(--transition-fast) forwards;
    }
    @keyframes notifSlideIn {
      from { opacity: 0; transform: translateX(40px); }
      to { opacity: 1; transform: translateX(0); }
    }
    @keyframes notifSlideOut {
      from { opacity: 1; transform: translateX(0); }
      to { opacity: 0; transform: translateX(40px); }
    }

    /* Scrollbar hiding for panels */
    .hide-scrollbar { scrollbar-width: none; -ms-overflow-style: none; }
    .hide-scrollbar::-webkit-scrollbar { display: none; }

    /* ===== PHASE 2: STAR INFO PANEL ===== */
    .star-info-panel {
      position: fixed; top: 50%; right: var(--space-5);
      transform: translateY(-50%);
      background: var(--color-panel);
      border: 1px solid var(--color-accent-cyan);
      border-radius: var(--radius-lg);
      padding: var(--space-4) var(--space-5);
      min-width: 200px; max-width: 260px;
      backdrop-filter: blur(12px);
      z-index: var(--z-ui-floating);
      box-shadow: 0 0 20px rgba(0,255,255,0.15);
      pointer-events: auto;
    }
    .star-info-name {
      font-size: var(--font-lg); font-weight: 700;
      color: var(--color-accent-gold); margin-bottom: var(--space-2);
    }
    .star-info-detail {
      font-size: var(--font-sm); color: var(--color-text-secondary);
      line-height: 1.6;
    }
    .star-info-hint {
      margin-top: var(--space-3); font-size: var(--font-xs);
      color: var(--color-text-muted); text-align: center;
      border-top: 1px solid var(--color-border); padding-top: var(--space-2);
    }

    /* ===== PHASE 2: WEATHER / TIME HUD ===== */
    .hud-env {
      position: fixed; top: 50px; left: var(--space-4);
      display: flex; gap: var(--space-3);
      font-size: var(--font-sm); color: var(--color-text-secondary);
      z-index: var(--z-ui-controls);
      pointer-events: none;
    }

    /* ===== PHASE 2: MINIMAP ===== */
    #minimap {
      position: fixed; bottom: var(--space-4); right: var(--space-4);
      width: 160px; height: 160px;
      border: 1px solid var(--color-accent-cyan);
      border-radius: var(--radius-md);
      background: rgba(0,0,0,0.6);
      z-index: var(--z-ui-controls);
      pointer-events: auto;
      display: none;
    }

    /* ===== PHASE 3: ABILITY BAR ===== */
    .ability-bar {
      position: fixed;
      bottom: 60px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: var(--space-2);
      z-index: var(--z-ui);
      pointer-events: auto;
      padding: var(--space-2);
      background: rgba(10, 15, 20, 0.6);
      border-radius: var(--radius-lg);
      border: 1px solid var(--color-border);
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
    }
    .ability-slot {
      width: 44px;
      height: 44px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: rgba(20, 30, 40, 0.8);
      border: 1px solid var(--color-border-light);
      border-radius: var(--radius-md);
      position: relative;
      cursor: pointer;
      transition: border-color var(--transition-fast), box-shadow var(--transition-fast);
      flex-shrink: 0;
    }
    .ability-slot.ready {
      border-color: rgba(0, 255, 255, 0.3);
      box-shadow: 0 0 6px rgba(0, 255, 255, 0.1);
    }
    .ability-slot.on-cooldown {
      opacity: 0.5;
    }
    .ability-slot.no-energy {
      border-color: rgba(255, 68, 68, 0.3);
    }
    .ability-slot .ability-icon {
      font-size: var(--font-md);
      font-weight: 700;
      color: var(--color-text-primary);
      text-transform: uppercase;
      z-index: 2;
      line-height: 1;
    }
    .ability-slot .cd-overlay {
      position: absolute;
      inset: 0;
      background: rgba(0, 0, 0, 0.6);
      border-radius: var(--radius-md);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: var(--font-xs);
      font-weight: 700;
      color: var(--color-text-secondary);
      z-index: 3;
    }
    .ability-slot .key-hint {
      position: absolute;
      bottom: 1px;
      right: 3px;
      font-size: 9px;
      color: var(--color-text-muted);
      text-transform: uppercase;
      z-index: 2;
      line-height: 1;
    }
    .ability-slot .ability-name-tip {
      display: none;
      position: absolute;
      bottom: 110%;
      left: 50%;
      transform: translateX(-50%);
      white-space: nowrap;
      font-size: var(--font-xs);
      background: var(--color-panel-solid);
      color: var(--color-text-primary);
      padding: var(--space-1) var(--space-2);
      border-radius: var(--radius-sm);
      border: 1px solid var(--color-border-light);
      z-index: 10;
    }
    .ability-slot:hover .ability-name-tip {
      display: block;
    }

    /* Damage Floaters (HTML overlay) */
    .damage-floater {
      position: fixed;
      font-weight: 700;
      font-size: var(--font-lg);
      pointer-events: none;
      z-index: var(--z-overlays);
      text-shadow: 0 1px 4px rgba(0,0,0,0.7);
      animation: floaterRise 1.2s ease-out forwards;
    }
    @keyframes floaterRise {
      0%   { opacity: 1; transform: translateY(0) scale(1); }
      60%  { opacity: 0.8; transform: translateY(-40px) scale(1.15); }
      100% { opacity: 0; transform: translateY(-70px) scale(0.8); }
    }

    /* Screen shake */
    @keyframes screenShake {
      0%, 100% { transform: translate(0, 0); }
      10% { transform: translate(-3px, 2px); }
      20% { transform: translate(3px, -2px); }
      30% { transform: translate(-2px, 3px); }
      40% { transform: translate(2px, -1px); }
      50% { transform: translate(-1px, 2px); }
      60% { transform: translate(1px, -1px); }
      70% { transform: translate(-1px, 1px); }
      80% { transform: translate(1px, -1px); }
      90% { transform: translate(-1px, 0); }
    }
    .screen-shake {
      animation: screenShake 0.3s ease-out;
    }

    /* Buff indicator */
    .buff-indicators {
      position: fixed;
      top: 80px;
      left: var(--space-4);
      display: flex;
      gap: var(--space-2);
      z-index: var(--z-ui);
      pointer-events: none;
    }
    .buff-icon {
      width: 28px;
      height: 28px;
      border-radius: var(--radius-sm);
      border: 1px solid var(--color-accent-gold);
      background: rgba(255, 187, 0, 0.15);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: var(--font-xs);
      color: var(--color-accent-gold);
      font-weight: 700;
    }

    /* ===== PHASE 4: ENEMY & BOSS HUD ===== */
    #enemy-count {
      font-size: var(--font-xs);
      font-family: 'Courier New', monospace;
      color: var(--color-accent-red);
      letter-spacing: 1px;
    }
    #boss-health-bar {
      display: none;
      position: fixed;
      top: 48px;
      left: 50%;
      transform: translateX(-50%);
      width: min(400px, 80vw);
      z-index: var(--z-overlays);
      text-align: center;
      pointer-events: none;
    }
    #boss-health-bar .boss-name {
      font-size: var(--font-sm);
      letter-spacing: 2px;
      text-transform: uppercase;
      color: var(--color-accent-red);
      text-shadow: 0 0 10px rgba(255,0,0,0.4);
      margin-bottom: var(--space-1);
    }
    #boss-health-bar .boss-bar-track {
      height: 10px;
      background: rgba(255,255,255,0.08);
      border-radius: var(--radius-full);
      overflow: hidden;
      border: 1px solid rgba(255,68,68,0.3);
    }
    #boss-health-bar .boss-bar-fill {
      height: 100%;
      border-radius: var(--radius-full);
      background: linear-gradient(90deg, #cc0000, #ff4444, #ff0000);
      box-shadow: 0 0 12px rgba(255,0,0,0.5);
      transition: width 200ms ease;
    }

    /* ===== PHASE 5: XP BAR & GOLD ===== */
    .xp-fill {
      background: linear-gradient(90deg, #cc9900, #ffbb00, #ffdd44) !important;
      box-shadow: 0 0 8px rgba(255,187,0,0.5);
    }
    #gold-counter {
      font-size: var(--font-xs);
      font-family: 'Courier New', monospace;
      color: #ffbb00;
      letter-spacing: 1px;
    }

    /* ===== PHASE 6: AGENT PANEL ===== */
    .agent-panel {
      position: fixed;
      top: 90px;
      left: var(--space-3);
      background: rgba(10,15,30,0.85);
      border: 1px solid rgba(100,200,255,0.15);
      border-radius: 6px;
      padding: 6px 12px;
      font-size: var(--font-xs);
      color: #aaccee;
      z-index: 40;
      pointer-events: none;
    }
    .agent-panel-header { font-weight: bold; letter-spacing: 1px; }

    /* ===== MOBILE ===== */
    @media (max-width: 600px) {
      .hud-title { font-size: var(--font-xs); letter-spacing: 2px; }
      .hud-top { padding: var(--space-2) var(--space-3); }
      .hud-bottom { padding: var(--space-3); flex-direction: column; }
      .stat-bar { max-width: 100%; }
      #notification-area { max-width: 240px; right: var(--space-2); }
      #minimap { width: 100px; height: 100px; bottom: var(--space-2); right: var(--space-2); }
      .star-info-panel { right: var(--space-2); min-width: 160px; }
    }

    /* ===== PHASE 8: SHOW MODE & SPECTATOR ===== */
    .modal-overlay {
      position: fixed; inset: 0; background: rgba(0,0,0,0.7);
      display: flex; align-items: center; justify-content: center;
      z-index: 9000; backdrop-filter: blur(8px);
    }
    .modal-content {
      background: var(--color-panel-solid, #0d1319); border: 1px solid var(--color-border-light, rgba(255,255,255,0.15));
      border-radius: 12px; padding: 24px; max-width: 400px; width: 90%; text-align: center; position: relative;
    }
    .modal-close {
      position: absolute; top: 8px; right: 12px; background: none; border: none;
      color: #aaa; font-size: 24px; cursor: pointer;
    }
    .modal-close:hover { color: #fff; transform: rotate(90deg); }
    .show-mode-title { font-size: 22px; background: linear-gradient(90deg, #0ff, #48f, #0f8); -webkit-background-clip: text; -webkit-text-fill-color: transparent; }
    .show-mode-url { font-family: monospace; font-size: 11px; color: #888; word-break: break-all; margin: 12px 0; padding: 8px; background: rgba(0,0,0,0.3); border-radius: 6px; }
    .btn-primary { background: linear-gradient(135deg, #0ff, #48f); border: none; color: #000; font-weight: 700; padding: 10px 24px; border-radius: 8px; cursor: pointer; font-size: 14px; }
    .btn-primary:hover { filter: brightness(1.15); }
    .spectator-banner { position:fixed;top:0;left:0;right:0;background:#cc2222;color:#fff;text-align:center;padding:6px;z-index:9500;font-weight:700;font-size:12px; }

    /* ===== PHASE 9: UI, ACCESSIBILITY & POLISH ===== */
    .biophone-boot {
      position:fixed;inset:0;background:#060810;display:flex;flex-direction:column;
      align-items:center;justify-content:center;z-index:10001;color:#8af;
      font-family:monospace;transition:opacity 0.5s;
    }
    .biophone-logo { font-size:60px;margin-bottom:16px;animation:pulse 2s infinite; }
    .biophone-title { font-size:28px;letter-spacing:8px;color:#0ff;margin-bottom:4px; }
    .biophone-model { font-size:11px;color:#556;margin-bottom:32px; }
    .biophone-text { font-size:16px;color:#aad;min-height:24px;text-align:center;max-width:400px;margin-bottom:16px; }
    .biophone-status { font-size:10px;color:#556;letter-spacing:2px;margin-bottom:12px; }
    .biophone-progress-track { width:200px;height:3px;background:#222;border-radius:2px;overflow:hidden; }
    .biophone-progress-bar { height:100%;background:linear-gradient(90deg,#0ff,#48f);width:0;transition:width 0.3s; }
    .biophone-transfer-btn {
      margin-top:24px;padding:12px 32px;background:transparent;border:2px solid #0ff;
      color:#0ff;font-family:monospace;font-size:14px;letter-spacing:2px;cursor:pointer;
      border-radius:4px;transition:all 0.3s;
    }
    .biophone-transfer-btn:hover { background:#0ff;color:#000;box-shadow:0 0 20px rgba(0,255,255,0.4); }
    .biophone-skip-btn {
      position:absolute;bottom:24px;right:24px;background:none;border:1px solid #334;
      color:#556;padding:6px 12px;font-family:monospace;font-size:11px;cursor:pointer;border-radius:4px;
    }
    .biophone-skip-btn:hover { color:#aaa;border-color:#556; }
    .biophone-footer { position:absolute;bottom:24px;left:24px;font-size:10px;color:#334;letter-spacing:2px; }
    @keyframes pulse { 0%,100%{opacity:1;transform:scale(1)}50%{opacity:0.7;transform:scale(1.05)} }

    .reality-glitch-overlay { position:fixed;inset:0;pointer-events:none;z-index:10000; }
    .glitch-scan { background: repeating-linear-gradient(0deg, transparent, transparent 2px, rgba(0,255,255,0.03) 2px, rgba(0,255,255,0.03) 4px); animation:glitch-scan 0.3s linear; }
    .glitch-chromatic { box-shadow: inset 3px 0 rgba(255,0,0,0.15), inset -3px 0 rgba(0,0,255,0.15); }
    .glitch-static { background:url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="4" height="4"><rect x="0" y="0" width="1" height="1" fill="rgba(255,255,255,0.1)"/></svg>'); animation:glitch-static 0.1s steps(3) infinite; }
    .glitch-flash { background:rgba(255,255,255,0.8); animation:glitch-flash 0.3s ease-out; }
    @keyframes glitch-scan { from{transform:translateY(-100%)}to{transform:translateY(100%)} }
    @keyframes glitch-static { 0%{opacity:0.5}50%{opacity:0.2}100%{opacity:0.4} }
    @keyframes glitch-flash { from{opacity:1}to{opacity:0} }

    .setting-row { display:flex;align-items:center;gap:8px;padding:8px 0;font-size:13px;color:#ccc;cursor:pointer; }
    .btn-secondary { background:transparent;border:1px solid #456;color:#aaa;padding:8px 16px;border-radius:8px;cursor:pointer;font-size:13px; }
    .btn-secondary:hover { border-color:#0ff;color:#0ff; }

    .stat-line { display:flex;justify-content:space-between;padding:6px 0;border-bottom:1px solid rgba(255,255,255,0.05);font-size:13px;color:#aaa; }
    .stat-line span:last-child { color:#fff;font-weight:600; }

    .inv-slot { display:flex;justify-content:space-between;padding:6px 0;border-bottom:1px solid rgba(255,255,255,0.05);font-size:13px; }
    .inv-slot-name { color:#888;text-transform:capitalize; }
    .inv-item { padding:4px 0;font-size:12px;color:#ccc; }

    .help-grid { display:grid;grid-template-columns:auto 1fr;gap:4px 12px;font-size:12px; }
    .help-key { color:#0ff;font-family:monospace;font-weight:700;padding:2px 6px;background:rgba(0,255,255,0.1);border-radius:3px;text-align:right; }

    body.high-contrast .hud-top, body.high-contrast .hud-bottom { background:rgba(0,0,0,0.9); border:1px solid #fff; }
    body.high-contrast { --color-text-primary: #fff; --color-text-secondary: #ddd; }

    body.low-power .reality-glitch-overlay { display:none !important; }
    body.low-power canvas#gameCanvas { image-rendering: pixelated; }
  </style>
</head>
<body>
  <!-- Accessibility: skip links -->
  <nav class="skip-links" aria-label="Skip links">
    <a href="#gameCanvas">Skip to game</a>
    <a href="#hud">Skip to HUD</a>
  </nav>

  <!-- Screen reader announcements -->
  <div id="sr-announcements" class="sr-only" aria-live="polite" aria-atomic="true"></div>

  <!-- Phase 9: Biophone Boot Sequence -->
  <div id="biophone-boot" class="biophone-boot" style="display:none">
    <div class="biophone-logo">üß†</div>
    <div class="biophone-title">BIOPHONE</div>
    <div class="biophone-model">Mk.VII ‚Ä¢ SOMA INDUSTRIES</div>
    <div class="biophone-text" id="biophone-narrative"></div>
    <div class="biophone-status" id="biophone-status">INITIALIZING NEURAL BRIDGE</div>
    <div class="biophone-progress-track"><div class="biophone-progress-bar" id="biophone-progress"></div></div>
    <button id="transfer-btn" class="biophone-transfer-btn" style="display:none" onclick="Biophone.finish()">TRANSFER INTO ROBOT</button>
    <button class="biophone-skip-btn" onclick="Biophone.skip()">SKIP [SPACE]</button>
    <div class="biophone-footer">SOMA INDUSTRIES ‚Ä¢ EST. 2847</div>
  </div>

  <!-- Loading Screen -->
  <div id="loading-screen" role="alert" aria-label="Loading game">
    <div class="loading-title">LEVIATHAN</div>
    <div class="loading-subtitle">OMNIVERSE</div>
    <div class="loading-spinner" aria-hidden="true"></div>
    <div class="loading-status">Initializing systems‚Ä¶</div>
  </div>

  <!-- Three.js Canvas -->
  <canvas id="gameCanvas" tabindex="0" aria-label="Game viewport"></canvas>

  <!-- HUD Overlay -->
  <div id="hud" aria-label="Heads-up display">
    <!-- Top Bar -->
    <div class="hud-top">
      <div class="hud-title">LEVIATHAN: OMNIVERSE</div>
      <div class="hud-mode" id="mode-indicator">GALAXY</div>
      <div id="fps-counter" aria-label="Frames per second">-- FPS</div>
      <span id="enemy-count" style="display:none">‚öî 0</span>
      <span id="gold-counter">üí∞ 0</span>
    </div>

    <!-- Notification Area -->
    <div id="notification-area" role="log" aria-label="Notifications"></div>

    <!-- Star Info Panel (Galaxy mode) -->
    <div id="star-info" class="star-info-panel" style="display:none">
      <div class="star-info-name" id="star-info-name">‚Äî</div>
      <div class="star-info-detail" id="star-info-detail"></div>
      <div class="star-info-hint">Double-click or ENTER to visit</div>
    </div>

    <!-- Weather + Time indicators -->
    <div class="hud-env" id="hud-env" style="display:none">
      <span id="weather-indicator">‚òÄÔ∏è Clear</span>
      <span id="time-indicator">‚òÄÔ∏è Day</span>
    </div>

    <!-- Phase 3: Ability Bar -->
    <div class="ability-bar" id="ability-bar" style="display:none" aria-label="Combat abilities">
      <!-- Generated by Combat.init() -->
    </div>

    <!-- Phase 3: Buff Indicators -->
    <div class="buff-indicators" id="buff-indicators"></div>

    <!-- Phase 4: Boss Health Bar -->
    <div id="boss-health-bar">
      <div class="boss-name" id="boss-name">BOSS</div>
      <div class="boss-bar-track">
        <div class="boss-bar-fill" id="boss-bar-fill" style="width:100%"></div>
      </div>
    </div>

    <!-- Bottom Bar -->
    <div class="hud-bottom">
      <div class="stat-bar xp-bar" role="meter" aria-label="Experience" aria-valuemin="0" aria-valuemax="100" aria-valuenow="0">
        <div class="stat-bar-label">
          <span>LVL <span id="player-level">1</span></span>
          <span id="xp-text">0 / 100 XP</span>
        </div>
        <div class="stat-bar-track">
          <div class="stat-bar-fill xp-fill" id="xp-bar" style="width:0%"></div>
        </div>
      </div>
      <div class="stat-bar" role="meter" aria-label="Probe integrity" aria-valuemin="0" aria-valuemax="100" aria-valuenow="100">
        <div class="stat-bar-label">
          <span>PROBE INTEGRITY</span>
          <span id="health-text">100 / 100</span>
        </div>
        <div class="stat-bar-track">
          <div class="stat-bar-fill health-fill" id="health-bar" style="width:100%"></div>
        </div>
      </div>
      <div class="stat-bar" role="meter" aria-label="Energy" aria-valuemin="0" aria-valuemax="100" aria-valuenow="100">
        <div class="stat-bar-label">
          <span>ENERGY</span>
          <span id="energy-text">100 / 100</span>
        </div>
        <div class="stat-bar-track">
          <div class="stat-bar-fill energy-fill" id="energy-bar" style="width:100%"></div>
        </div>
      </div>
    </div>
  </div>

  <!-- Minimap -->
  <canvas id="minimap" width="160" height="160" aria-label="Minimap"></canvas>

  <!-- Phase 6: Agent Panel -->
  <div id="agent-panel" class="agent-panel" style="display:none">
    <div class="agent-panel-header">ü§ñ Agents: <span id="agent-count-display">0</span>/10</div>
  </div>

  <!-- External Dependencies -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>

  <script>
  /* ==========================================================================
     LEVIATHAN: OMNIVERSE v11.0 ‚Äî Phase 1: Foundation
     ========================================================================== */

  // ===== 1. CONSTANTS & CONFIG =====
  const APP_NAME = 'leviathan-omniverse';
  const VERSION = '11.0';
  const VALID_MODES = ['galaxy', 'world', 'landing', 'genesis', 'tesseract', 'nexus'];
  const DEBUG_LOGGING = false;

  // ===== 2. LOGGER SYSTEM =====
  const Logger = {
    enabled: true,
    verbose: false,
    debug(category, ...args) {
      if (this.enabled && DEBUG_LOGGING) console.log(`[${category}]`, ...args);
    },
    warn(category, ...args) {
      if (this.enabled) console.warn(`[${category}]`, ...args);
    },
    error(category, ...args) {
      console.error(`[${category}]`, ...args);
    },
    perf(label) {
      const start = performance.now();
      return () => {
        if (this.verbose) console.log(`[PERF] ${label}: ${(performance.now() - start).toFixed(1)}ms`);
      };
    }
  };

  // ===== 3. SAFE ACCESSORS =====
  function safeGet(obj, path, defaultValue) {
    if (!obj || typeof path !== 'string') return defaultValue;
    const keys = path.split('.');
    let current = obj;
    for (const key of keys) {
      if (current == null || typeof current !== 'object') return defaultValue;
      current = current[key];
    }
    return current !== undefined ? current : defaultValue;
  }

  function safeNumber(value, defaultValue, min, max) {
    const num = Number(value);
    if (isNaN(num)) return defaultValue;
    if (min !== undefined && num < min) return min;
    if (max !== undefined && num > max) return max;
    return num;
  }

  function sanitizeUserInput(input, opts = {}) {
    if (typeof input !== 'string') return '';
    const maxLen = opts.maxLength || 200;
    let clean = input.slice(0, maxLen);
    clean = clean.replace(/<[^>]*>/g, '');
    clean = clean.replace(/[<>"'&]/g, '');
    if (opts.alphanumericOnly) clean = clean.replace(/[^a-zA-Z0-9 _-]/g, '');
    return clean.trim();
  }

  function escapeHtml(text) {
    const map = { '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#039;' };
    return String(text).replace(/[&<>"']/g, m => map[m]);
  }

  // ===== 4. ERROR RECOVERY =====
  const ErrorRecovery = {
    maxRetries: 3,
    retryDelay: 500,

    async withRetry(fn, options = {}) {
      const max = options.maxRetries || this.maxRetries;
      const baseDelay = options.retryDelay || this.retryDelay;
      const label = options.label || 'operation';
      let lastError;
      for (let attempt = 0; attempt < max; attempt++) {
        try {
          return await fn(attempt);
        } catch (err) {
          lastError = err;
          Logger.warn('RETRY', `${label} attempt ${attempt + 1}/${max} failed:`, err.message);
          if (attempt < max - 1) {
            await new Promise(r => setTimeout(r, baseDelay * Math.pow(2, attempt)));
          }
        }
      }
      Logger.error('RETRY', `${label} failed after ${max} attempts`);
      throw lastError;
    },

    safeDOM(selector) {
      try {
        return document.querySelector(selector);
      } catch (e) {
        Logger.warn('DOM', `Invalid selector: ${selector}`);
        return null;
      }
    }
  };

  // ===== 5. STORAGE MANAGER =====
  // Detect if localStorage is available (blocked by Tracking Prevention in some browsers)
  const _storageAvailable = (() => {
    try {
      const t = '__storage_test__';
      localStorage.setItem(t, t);
      localStorage.removeItem(t);
      return true;
    } catch (e) {
      return false;
    }
  })();

  // In-memory fallback when localStorage is blocked by Tracking Prevention
  const _memoryStore = {};

  const StorageManager = {
    prefix: 'leviathan-',

    save(key, value, options = {}) {
      const fullKey = this.prefix + key;
      const payload = JSON.stringify({
        data: value,
        timestamp: Date.now(),
        version: VERSION,
        temp: !!options.temp
      });
      if (!_storageAvailable) {
        _memoryStore[fullKey] = payload;
        return true;
      }
      try {
        localStorage.setItem(fullKey, payload);
        Logger.debug('STORAGE', `Saved ${fullKey} (${payload.length} bytes)`);
        return true;
      } catch (e) {
        if (e.name === 'QuotaExceededError') {
          Logger.warn('STORAGE', 'Quota exceeded, attempting cleanup‚Ä¶');
          this.performSmartCleanup(1024 * 100);
          try {
            localStorage.setItem(this.prefix + key, JSON.stringify({ data: value, timestamp: Date.now(), version: VERSION }));
            return true;
          } catch (e2) {
            Logger.error('STORAGE', 'Save failed even after cleanup');
          }
        }
        // Fallback to memory on any storage error
        _memoryStore[fullKey] = payload;
        return true;
      }
    },

    load(key, defaultValue) {
      const fullKey = this.prefix + key;
      if (!_storageAvailable) {
        const raw = _memoryStore[fullKey];
        if (!raw) return defaultValue;
        try { const p = JSON.parse(raw); return p.data !== undefined ? p.data : defaultValue; }
        catch (e) { return defaultValue; }
      }
      try {
        const raw = localStorage.getItem(fullKey);
        if (!raw) return defaultValue;
        const parsed = JSON.parse(raw);
        return parsed.data !== undefined ? parsed.data : defaultValue;
      } catch (e) {
        Logger.warn('STORAGE', `Load error for ${key}:`, e.message);
        return defaultValue;
      }
    },

    remove(key) {
      const fullKey = this.prefix + key;
      if (!_storageAvailable) { delete _memoryStore[fullKey]; return; }
      try {
        localStorage.removeItem(fullKey);
      } catch (e) {
        Logger.warn('STORAGE', `Remove error for ${key}`);
      }
    },

    exportAll() {
      const data = {};
      if (!_storageAvailable) {
        for (const [key, val] of Object.entries(_memoryStore)) {
          if (key.startsWith(this.prefix)) {
            try { data[key] = JSON.parse(val); } catch (e) { data[key] = val; }
          }
        }
      } else {
      for (let i = 0; i < localStorage.length; i++) {
        const key = localStorage.key(i);
        if (key.startsWith(this.prefix)) {
          try { data[key] = JSON.parse(localStorage.getItem(key)); }
          catch (e) { data[key] = localStorage.getItem(key); }
        }
      }
      }
      const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `leviathan-save-${new Date().toISOString().slice(0, 10)}.json`;
      a.click();
      URL.revokeObjectURL(url);
      Logger.debug('STORAGE', 'Exported all data');
    },

    importAll(file) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = (e) => {
          try {
            const data = JSON.parse(e.target.result);
            for (const [key, value] of Object.entries(data)) {
              if (key.startsWith(this.prefix)) {
                const serialized = typeof value === 'string' ? value : JSON.stringify(value);
                if (!_storageAvailable) { _memoryStore[key] = serialized; }
                else { localStorage.setItem(key, serialized); }
              }
            }
            Logger.debug('STORAGE', 'Imported all data');
            resolve(true);
          } catch (err) {
            Logger.error('STORAGE', 'Import failed:', err.message);
            reject(err);
          }
        };
        reader.onerror = () => reject(new Error('File read failed'));
        reader.readAsText(file);
      });
    },

    getUsageBytes() {
      if (!_storageAvailable) {
        let total = 0;
        for (const [key, val] of Object.entries(_memoryStore)) {
          if (key.startsWith(this.prefix)) total += key.length + val.length;
        }
        return total * 2;
      }
      let total = 0;
      for (let i = 0; i < localStorage.length; i++) {
        const key = localStorage.key(i);
        if (key.startsWith(this.prefix)) {
          total += key.length + (localStorage.getItem(key) || '').length;
        }
      }
      return total * 2; // UTF-16
    },

    performSmartCleanup(neededBytes) {
      if (!_storageAvailable) {
        // Memory store doesn't need cleanup but honor the interface
        return 0;
      }
      const entries = [];
      for (let i = 0; i < localStorage.length; i++) {
        const key = localStorage.key(i);
        if (!key.startsWith(this.prefix)) continue;
        try {
          const parsed = JSON.parse(localStorage.getItem(key));
          entries.push({ key, timestamp: parsed.timestamp || 0, temp: parsed.temp || false, size: (localStorage.getItem(key) || '').length * 2 });
        } catch (e) {
          entries.push({ key, timestamp: 0, temp: true, size: (localStorage.getItem(key) || '').length * 2 });
        }
      }
      // Remove temp data first, then oldest
      entries.sort((a, b) => (b.temp - a.temp) || (a.timestamp - b.timestamp));
      let freed = 0;
      for (const entry of entries) {
        if (freed >= neededBytes) break;
        if (entry.key === this.prefix + 'gameData') continue; // never delete primary save
        localStorage.removeItem(entry.key);
        freed += entry.size;
        Logger.debug('STORAGE', `Cleaned ${entry.key} (${entry.size} bytes)`);
      }
      return freed;
    }
  };

  // ===== 6. GAME STATE =====
  let mode = 'galaxy';

  function setMode(newMode) {
    if (!VALID_MODES.includes(newMode)) {
      Logger.warn('MODE', `Invalid mode: ${newMode}`);
      return false;
    }
    const oldMode = mode;
    mode = newMode;
    const indicator = document.getElementById('mode-indicator');
    if (indicator) indicator.textContent = newMode.toUpperCase();
    EventBus.emit('modeChange', { from: oldMode, to: newMode });
    // Phase 3: Show/hide ability bar based on mode
    const abilityBar = document.getElementById('ability-bar');
    if (abilityBar) abilityBar.style.display = newMode === 'world' ? 'flex' : 'none';
    A11y.announce(`Mode changed to ${newMode}`);
    Logger.debug('MODE', `${oldMode} ‚Üí ${newMode}`);
    return true;
  }

  const gameData = {
    player: {
      name: 'Explorer',
      hp: 100, maxHp: 100,
      energy: 100, maxEnergy: 100,
      level: 1, xp: 0, xpToNext: 100,
      position: { x: 0, y: 0, z: 0 },
      rotation: 0,
      stats: { strength: 10, defense: 5, speed: 8, luck: 3 },
      gold: 0,
      inventory: [],
      equipment: { weapon: null, armor: null, accessory: null, rune: null },
      skills: {},
      talents: {},
      achievements: [],
      quests: { active: [], completed: [] }
    },
    world: {
      seed: Math.floor(Math.random() * 999999),
      entities: [],
      structures: [],
      terraformedAreas: [],
      discoveredPOIs: [],
      weather: 'clear',
      time: 0,
      dayNightCycle: 0
    },
    agents: [],
    companion: null,
    settings: {
      sfxVolume: 0.7,
      musicVolume: 0.5,
      particleQuality: 'high',
      showFPS: true,
      lowPowerMode: false,
      screenReaderMode: false,
      highContrast: false
    },
    session: {
      startTime: Date.now(),
      deaths: 0,
      killCount: 0,
      bossKills: 0,
      totalPlayTime: 0
    },
    meta: {
      version: VERSION,
      lastSave: null,
      generation: 0
    }
  };

  // ===== 7. EVENT BUS =====
  const EventBus = {
    listeners: {},

    on(event, callback) {
      if (!this.listeners[event]) this.listeners[event] = [];
      this.listeners[event].push(callback);
      return () => this.off(event, callback);
    },

    off(event, callback) {
      if (!this.listeners[event]) return;
      this.listeners[event] = this.listeners[event].filter(cb => cb !== callback);
    },

    emit(event, data) {
      Logger.debug('EVENT', event, data);
      if (!this.listeners[event]) return;
      for (const cb of this.listeners[event]) {
        try { cb(data); }
        catch (e) { Logger.error('EVENT', `Error in ${event} handler:`, e); }
      }
    }
  };

  // ===== 8. THREE.JS SCENE SETUP =====
  let scene, camera, renderer, clock;

  function initThreeJS() {
    const end = Logger.perf('initThreeJS');

    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x050510);
    scene.fog = new THREE.FogExp2(0x050510, 0.002);

    camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 10000);
    camera.position.set(0, 200, 400);

    renderer = new THREE.WebGLRenderer({
      canvas: document.getElementById('gameCanvas'),
      antialias: true,
      alpha: false
    });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;

    clock = new THREE.Clock();

    // Ambient light
    const ambient = new THREE.AmbientLight(0x334466, 0.5);
    scene.add(ambient);

    // Directional light
    const directional = new THREE.DirectionalLight(0xffffff, 0.8);
    directional.position.set(100, 200, 100);
    directional.castShadow = true;
    directional.shadow.mapSize.width = 1024;
    directional.shadow.mapSize.height = 1024;
    directional.shadow.camera.near = 0.5;
    directional.shadow.camera.far = 1000;
    scene.add(directional);

    // Background stars (distant points)
    const starGeo = new THREE.BufferGeometry();
    const starCount = 2000;
    const positions = new Float32Array(starCount * 3);
    for (let i = 0; i < starCount * 3; i += 3) {
      positions[i]     = (Math.random() - 0.5) * 4000;
      positions[i + 1] = (Math.random() - 0.5) * 4000;
      positions[i + 2] = (Math.random() - 0.5) * 4000;
    }
    starGeo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    const starMat = new THREE.PointsMaterial({ color: 0xaabbdd, size: 1.5, sizeAttenuation: true });
    scene.add(new THREE.Points(starGeo, starMat));

    window.addEventListener('resize', onResize);
    end();
  }

  // ===== 9. INPUT SYSTEM =====
  const Input = {
    keys: {},
    mouse: null, // initialized after THREE loads
    raycaster: null,
    isTouchDevice: 'ontouchstart' in window,
    gamepadConnected: false,
    touches: [],

    init() {
      this.mouse = new THREE.Vector2();
      this.raycaster = new THREE.Raycaster();

      document.addEventListener('keydown', e => {
        this.keys[e.key.toLowerCase()] = true;
        EventBus.emit('keydown', e);
      });
      document.addEventListener('keyup', e => {
        this.keys[e.key.toLowerCase()] = false;
        EventBus.emit('keyup', e);
      });
      document.addEventListener('mousemove', e => {
        this.mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
        this.mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
      });
      document.addEventListener('click', e => EventBus.emit('click', e));
      document.addEventListener('contextmenu', e => {
        e.preventDefault();
        EventBus.emit('rightclick', e);
      });

      if (this.isTouchDevice) this.initTouch();

      window.addEventListener('gamepadconnected', () => {
        this.gamepadConnected = true;
        Logger.debug('INPUT', 'Gamepad connected');
      });
      window.addEventListener('gamepaddisconnected', () => {
        this.gamepadConnected = false;
        Logger.debug('INPUT', 'Gamepad disconnected');
      });

      Logger.debug('INPUT', 'Initialized', { touch: this.isTouchDevice });
    },

    initTouch() {
      const canvas = document.getElementById('gameCanvas');
      canvas.addEventListener('touchstart', e => {
        e.preventDefault();
        this.touches = Array.from(e.touches);
        EventBus.emit('touchstart', e);
      }, { passive: false });
      canvas.addEventListener('touchmove', e => {
        e.preventDefault();
        this.touches = Array.from(e.touches);
        if (e.touches.length > 0) {
          this.mouse.x = (e.touches[0].clientX / window.innerWidth) * 2 - 1;
          this.mouse.y = -(e.touches[0].clientY / window.innerHeight) * 2 + 1;
        }
        EventBus.emit('touchmove', e);
      }, { passive: false });
      canvas.addEventListener('touchend', e => {
        this.touches = Array.from(e.touches);
        EventBus.emit('touchend', e);
      });
    },

    isKeyDown(key) { return !!this.keys[key]; },

    pollGamepad() {
      if (!this.gamepadConnected) return null;
      const gamepads = navigator.getGamepads ? navigator.getGamepads() : [];
      const gp = gamepads[0];
      if (!gp) return null;
      return {
        leftStick: { x: gp.axes[0] || 0, y: gp.axes[1] || 0 },
        rightStick: { x: gp.axes[2] || 0, y: gp.axes[3] || 0 },
        buttons: gp.buttons.map(b => b.pressed)
      };
    }
  };

  // ===== 10. NOTIFICATION SYSTEM =====
  const Notifications = {
    queue: [],
    activeCount: 0,
    maxVisible: 5,
    nextId: 1,

    show(message, type = 'info', duration = 3000) {
      const id = this.nextId++;
      const area = document.getElementById('notification-area');
      if (!area) return id;

      if (this.activeCount >= this.maxVisible) {
        this.queue.push({ message, type, duration });
        return id;
      }

      this.activeCount++;
      const el = document.createElement('div');
      el.className = `notification ${type}`;
      el.textContent = message;
      el.setAttribute('role', 'status');
      el.dataset.notifId = id;

      el.addEventListener('click', () => this.dismiss(id));
      area.appendChild(el);

      if (duration > 0) {
        setTimeout(() => this.dismiss(id), duration);
      }

      A11y.announce(message);
      return id;
    },

    dismiss(id) {
      const area = document.getElementById('notification-area');
      if (!area) return;
      const el = area.querySelector(`[data-notif-id="${id}"]`);
      if (!el) return;

      el.classList.add('fade-out');
      setTimeout(() => {
        if (el.parentNode) el.parentNode.removeChild(el);
        this.activeCount = Math.max(0, this.activeCount - 1);
        if (this.queue.length > 0) {
          const next = this.queue.shift();
          this.show(next.message, next.type, next.duration);
        }
      }, 150);
    },

    clear() {
      const area = document.getElementById('notification-area');
      if (area) area.innerHTML = '';
      this.activeCount = 0;
      this.queue = [];
    }
  };

  // ===== 11. ACCESSIBILITY =====
  const A11y = {
    screenReaderMode: false,
    trapElement: null,
    trapHandler: null,

    announce(text) {
      const el = document.getElementById('sr-announcements');
      if (el) {
        el.textContent = '';
        requestAnimationFrame(() => { el.textContent = text; });
      }
    },

    focusTrap(element) {
      if (!element) return;
      this.trapElement = element;
      const focusable = element.querySelectorAll('button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])');
      const first = focusable[0];
      const last = focusable[focusable.length - 1];

      this.trapHandler = (e) => {
        if (e.key !== 'Tab') return;
        if (e.shiftKey) {
          if (document.activeElement === first) { e.preventDefault(); last.focus(); }
        } else {
          if (document.activeElement === last) { e.preventDefault(); first.focus(); }
        }
      };
      element.addEventListener('keydown', this.trapHandler);
      if (first) first.focus();
    },

    releaseTrap() {
      if (this.trapElement && this.trapHandler) {
        this.trapElement.removeEventListener('keydown', this.trapHandler);
      }
      this.trapElement = null;
      this.trapHandler = null;
    }
  };

  // ===== 12. NOISE FUNCTIONS =====
  function hashNoise(x, z) {
    let n = (Math.sin(x * 127.1 + z * 311.7) * 43758.5453123);
    return n - Math.floor(n);
  }

  function smoothstep(a, b, t) {
    t = Math.max(0, Math.min(1, (t - a) / (b - a)));
    return t * t * (3 - 2 * t);
  }

  function valueNoise(x, z) {
    const ix = Math.floor(x);
    const iz = Math.floor(z);
    const fx = x - ix;
    const fz = z - iz;
    const sx = smoothstep(0, 1, fx);
    const sz = smoothstep(0, 1, fz);
    const n00 = hashNoise(ix, iz);
    const n10 = hashNoise(ix + 1, iz);
    const n01 = hashNoise(ix, iz + 1);
    const n11 = hashNoise(ix + 1, iz + 1);
    const nx0 = n00 * (1 - sx) + n10 * sx;
    const nx1 = n01 * (1 - sx) + n11 * sx;
    return nx0 * (1 - sz) + nx1 * sz;
  }

  function noise(x, z, octaves = 4) {
    let value = 0;
    let amplitude = 1;
    let frequency = 1;
    let maxValue = 0;
    for (let i = 0; i < octaves; i++) {
      value += valueNoise(x * frequency, z * frequency) * amplitude;
      maxValue += amplitude;
      amplitude *= 0.5;
      frequency *= 2;
    }
    return value / maxValue;
  }

  // ===== 13. HUD UPDATES =====
  function updateHUD() {
    const p = gameData.player;

    // Health bar
    const healthPct = (p.hp / p.maxHp) * 100;
    const healthBar = document.getElementById('health-bar');
    const healthText = document.getElementById('health-text');
    if (healthBar) {
      healthBar.style.width = healthPct + '%';
      healthBar.className = 'stat-bar-fill health-fill' +
        (healthPct <= 25 ? ' critical' : healthPct <= 50 ? ' warning' : '');
    }
    if (healthText) healthText.textContent = `${Math.round(p.hp)} / ${p.maxHp}`;

    // Energy bar
    const energyPct = (p.energy / p.maxEnergy) * 100;
    const energyBar = document.getElementById('energy-bar');
    const energyText = document.getElementById('energy-text');
    if (energyBar) energyBar.style.width = energyPct + '%';
    if (energyText) energyText.textContent = `${Math.round(p.energy)} / ${p.maxEnergy}`;

    // ARIA
    const healthMeter = healthBar ? healthBar.closest('[role="meter"]') : null;
    if (healthMeter) healthMeter.setAttribute('aria-valuenow', Math.round(p.hp));
    const energyMeter = energyBar ? energyBar.closest('[role="meter"]') : null;
    if (energyMeter) energyMeter.setAttribute('aria-valuenow', Math.round(p.energy));

    // Phase 5: XP bar and gold counter
    Leveling.updateUI();
    const goldEl = document.getElementById('gold-counter');
    if (goldEl) goldEl.textContent = `üí∞ ${p.gold}`;
  }

  function updateFPSDisplay(value) {
    if (!gameData.settings.showFPS) return;
    const el = document.getElementById('fps-counter');
    if (el) el.textContent = value + ' FPS';
  }

  // ===== PHASE 2: GALAXY VIEW =====
  const STAR_NAMES_PREFIX = ['Alpha','Beta','Gamma','Delta','Epsilon','Zeta','Eta','Theta','Iota','Kappa','Lambda','Sigma','Tau','Omega','Nova','Vega','Rigel','Altair','Deneb','Sirius','Mira','Astra','Nyx','Sol','Lux','Lyra','Cygnus','Orion','Draco','Hydra'];
  const STAR_NAMES_SUFFIX = ['Prime','Major','Minor','Centauri','Proxima','Regio','Nexus','Core','Deep','Far','Ultra','Void','Flux','Rift','Drift','Echo','Zenith','Nadir'];
  const STAR_COLORS = [0xffddaa, 0xaaddff, 0xffffcc, 0xffaaaa, 0xccccff, 0xaaffcc, 0xffffff];

  const Galaxy = {
    stars: [],
    group: null,
    selectedStar: null,
    starMeshes: [],

    generate() {
      this.group = new THREE.Group();
      const count = 60 + Math.floor(Math.random() * 20);
      for (let i = 0; i < count; i++) {
        const angle = (i / count) * Math.PI * 6 + Math.random() * 0.5;
        const radius = 30 + (i / count) * 350 + Math.random() * 40;
        const y = (Math.random() - 0.5) * 40;
        const color = STAR_COLORS[Math.floor(Math.random() * STAR_COLORS.length)];
        const size = 1.5 + Math.random() * 3;
        const pCount = 1 + Math.floor(Math.random() * 5);
        const name = STAR_NAMES_PREFIX[Math.floor(Math.random() * STAR_NAMES_PREFIX.length)] + ' ' +
                     STAR_NAMES_SUFFIX[Math.floor(Math.random() * STAR_NAMES_SUFFIX.length)];

        const star = {
          name, color, size, planetCount: pCount,
          position: new THREE.Vector3(Math.cos(angle) * radius, y, Math.sin(angle) * radius),
          seed: Math.floor(Math.random() * 999999)
        };
        this.stars.push(star);

        // Sphere mesh
        const geo = new THREE.SphereGeometry(size, 12, 12);
        const mat = new THREE.MeshBasicMaterial({ color });
        const mesh = new THREE.Mesh(geo, mat);
        mesh.position.copy(star.position);
        mesh.userData = { starIndex: i };
        this.group.add(mesh);
        this.starMeshes.push(mesh);

        // Glow sprite
        const spriteMat = new THREE.SpriteMaterial({
          color, transparent: true, opacity: 0.35,
          blending: THREE.AdditiveBlending
        });
        const sprite = new THREE.Sprite(spriteMat);
        sprite.scale.set(size * 6, size * 6, 1);
        sprite.position.copy(star.position);
        this.group.add(sprite);
      }
      scene.add(this.group);
    },

    update(delta) {
      const t = clock.getElapsedTime();
      // Twinkle stars
      this.starMeshes.forEach((m, i) => {
        const s = 1 + Math.sin(t * 2 + i * 1.7) * 0.15;
        m.scale.set(s, s, s);
      });
    },

    select(index) {
      this.selectedStar = index >= 0 && index < this.stars.length ? this.stars[index] : null;
      const panel = document.getElementById('star-info');
      if (!this.selectedStar) { if (panel) panel.style.display = 'none'; return; }
      const s = this.selectedStar;
      if (panel) {
        panel.style.display = 'block';
        document.getElementById('star-info-name').textContent = s.name;
        document.getElementById('star-info-detail').innerHTML =
          `Planets: <b>${s.planetCount}</b><br>Class: ${s.size > 3 ? 'Giant' : s.size > 2 ? 'Main Sequence' : 'Dwarf'}<br>Seed: ${s.seed}`;
      }
    },

    visit() {
      if (!this.selectedStar) return;
      gameData.world.seed = this.selectedStar.seed;
      gameData.world.starName = this.selectedStar.name;
      // Clean galaxy objects
      if (this.group) scene.remove(this.group);
      document.getElementById('star-info').style.display = 'none';
      setMode('world');
      World.generate();
      Notifications.show('Arriving at ' + this.selectedStar.name, 'info', 3000);
    },

    cleanup() {
      if (this.group) scene.remove(this.group);
      this.starMeshes = [];
      this.stars = [];
      this.group = null;
      this.selectedStar = null;
    }
  };

  // ===== PHASE 2: CAMERA CONTROLLER =====
  const CameraController = {
    orbitAngle: 0,
    orbitPitch: 0.35,
    orbitDist: 500,
    followOffset: new THREE.Vector3(0, 25, 40),
    targetPos: new THREE.Vector3(),
    dragging: false,
    lastMouse: { x: 0, y: 0 },

    updateOrbit(delta) {
      this.orbitAngle += delta * 0.08;
      const x = Math.sin(this.orbitAngle) * this.orbitDist;
      const z = Math.cos(this.orbitAngle) * this.orbitDist;
      const y = Math.sin(this.orbitPitch) * this.orbitDist * 0.5;
      camera.position.set(x, y + 50, z);
      camera.lookAt(0, 0, 0);
    },

    updateFollow(delta, playerPos) {
      this.targetPos.copy(playerPos).add(this.followOffset);
      camera.position.lerp(this.targetPos, Math.min(1, delta * 5));
      camera.lookAt(playerPos.x, playerPos.y + 5, playerPos.z);
    },

    zoom(amount) {
      this.orbitDist = Math.max(100, Math.min(1500, this.orbitDist - amount * 30));
      this.followOffset.z = Math.max(15, Math.min(80, this.followOffset.z - amount * 3));
      this.followOffset.y = Math.max(10, Math.min(50, this.followOffset.y - amount * 1.5));
    },

    handleDrag(dx, dy) {
      if (mode === 'galaxy') {
        this.orbitAngle -= dx * 0.005;
        this.orbitPitch = Math.max(-0.8, Math.min(0.8, this.orbitPitch + dy * 0.005));
      }
    }
  };

  // Scroll to zoom
  window.addEventListener('wheel', e => { CameraController.zoom(e.deltaY > 0 ? -1 : 1); }, { passive: true });
  // Drag to rotate
  window.addEventListener('mousedown', e => { CameraController.dragging = true; CameraController.lastMouse = { x: e.clientX, y: e.clientY }; });
  window.addEventListener('mouseup', () => { CameraController.dragging = false; });
  window.addEventListener('mousemove', e => {
    if (!CameraController.dragging) return;
    CameraController.handleDrag(e.clientX - CameraController.lastMouse.x, e.clientY - CameraController.lastMouse.y);
    CameraController.lastMouse = { x: e.clientX, y: e.clientY };
  });

  // ===== PHASE 2: WORLD TERRAIN =====
  const World = {
    terrainMesh: null,
    waterMesh: null,
    trees: [],
    rocks: [],
    group: null,
    playerMesh: null,
    playerPos: new THREE.Vector3(0, 5, 0),
    playerRot: 0,
    moveSpeed: 30,
    terrainSize: 200,
    terrainRes: 80,

    generate() {
      this.cleanup();
      this.group = new THREE.Group();

      // Terrain
      const geo = new THREE.PlaneGeometry(this.terrainSize, this.terrainSize, this.terrainRes, this.terrainRes);
      geo.rotateX(-Math.PI / 2);
      const verts = geo.attributes.position;
      const colors = new Float32Array(verts.count * 3);
      for (let i = 0; i < verts.count; i++) {
        const x = verts.getX(i), z = verts.getZ(i);
        const h = noise(x * 0.02 + gameData.world.seed * 0.001, z * 0.02, 5) * 18;
        verts.setY(i, h);
        // Coloring: water < 0, grass 0-8, rock 8-14, snow >14
        if (h < -1) { colors[i*3]=0.1; colors[i*3+1]=0.25; colors[i*3+2]=0.55; }
        else if (h < 6) { const g=0.2+h*0.05; colors[i*3]=0.15; colors[i*3+1]=g; colors[i*3+2]=0.1; }
        else if (h < 12) { colors[i*3]=0.35; colors[i*3+1]=0.3; colors[i*3+2]=0.25; }
        else { colors[i*3]=0.85; colors[i*3+1]=0.85; colors[i*3+2]=0.9; }
      }
      geo.setAttribute('color', new THREE.BufferAttribute(colors, 3));
      geo.computeVertexNormals();
      const mat = new THREE.MeshLambertMaterial({ vertexColors: true });
      this.terrainMesh = new THREE.Mesh(geo, mat);
      this.terrainMesh.receiveShadow = true;
      this.group.add(this.terrainMesh);

      // Water plane
      const waterGeo = new THREE.PlaneGeometry(this.terrainSize * 1.5, this.terrainSize * 1.5);
      waterGeo.rotateX(-Math.PI / 2);
      const waterMat = new THREE.MeshPhongMaterial({ color: 0x1155aa, transparent: true, opacity: 0.55, shininess: 80 });
      this.waterMesh = new THREE.Mesh(waterGeo, waterMat);
      this.waterMesh.position.y = -1;
      this.group.add(this.waterMesh);

      // Trees
      const treeSeed = gameData.world.seed;
      for (let i = 0; i < 80; i++) {
        const tx = (hashNoise(i * 7.3, treeSeed) - 0.5) * this.terrainSize * 0.85;
        const tz = (hashNoise(treeSeed, i * 13.7) - 0.5) * this.terrainSize * 0.85;
        const th = this.getTerrainHeight(tx, tz);
        if (th < 1 || th > 10) continue;
        const tree = this.createTree(hashNoise(i, i) * 2 + 1.5);
        tree.position.set(tx, th, tz);
        this.group.add(tree);
        this.trees.push(tree);
      }

      // Rocks
      for (let i = 0; i < 30; i++) {
        const rx = (hashNoise(i * 17.1, treeSeed + 99) - 0.5) * this.terrainSize * 0.8;
        const rz = (hashNoise(treeSeed + 99, i * 11.3) - 0.5) * this.terrainSize * 0.8;
        const rh = this.getTerrainHeight(rx, rz);
        if (rh < 0) continue;
        const size = 0.5 + hashNoise(i * 3.3, i * 7.7) * 1.5;
        const rockGeo = new THREE.DodecahedronGeometry(size, 0);
        const rockMat = new THREE.MeshLambertMaterial({ color: 0x667766 });
        const rock = new THREE.Mesh(rockGeo, rockMat);
        rock.position.set(rx, rh + size * 0.3, rz);
        rock.rotation.set(Math.random()*2, Math.random()*2, Math.random()*2);
        rock.castShadow = true;
        this.group.add(rock);
        this.rocks.push(rock);
      }

      // Player avatar (simple robot)
      this.playerMesh = this.createPlayerMesh();
      this.playerMesh.position.copy(this.playerPos);
      this.group.add(this.playerMesh);

      // Adjust scene for world
      scene.fog = new THREE.FogExp2(0x889aad, 0.006);
      scene.background = new THREE.Color(0x88aacc);

      scene.add(this.group);
      document.getElementById('minimap').style.display = 'block';
      document.getElementById('hud-env').style.display = 'flex';
      this.playerPos.set(0, this.getTerrainHeight(0, 0) + 1, 0);
      CameraController.followOffset.set(0, 25, 40);
      Minimap.draw();

      // Phase 4: Initialize enemy & defense systems
      Enemies.init();
      ShipDefense.init(World.playerPos.clone());

      // Phase 6: Auto-summon companion if saved
      if (gameData.companion) {
        Companion.summon(gameData.companion.type);
      }

      // Phase 7: Generate POIs
      POISystem.generate();
    },

    createTree(scale) {
      const g = new THREE.Group();
      const trunkGeo = new THREE.CylinderGeometry(0.15 * scale, 0.25 * scale, 2 * scale, 6);
      const trunkMat = new THREE.MeshLambertMaterial({ color: 0x664422 });
      const trunk = new THREE.Mesh(trunkGeo, trunkMat);
      trunk.position.y = scale;
      trunk.castShadow = true;
      g.add(trunk);
      const leafGeo = new THREE.ConeGeometry(1.2 * scale, 2.5 * scale, 7);
      const leafMat = new THREE.MeshLambertMaterial({ color: 0x228833 });
      const leaf = new THREE.Mesh(leafGeo, leafMat);
      leaf.position.y = scale * 2.8;
      leaf.castShadow = true;
      g.add(leaf);
      return g;
    },

    createPlayerMesh() {
      const g = new THREE.Group();
      // Body
      const bodyGeo = new THREE.BoxGeometry(1.2, 1.6, 0.8);
      const bodyMat = new THREE.MeshPhongMaterial({ color: 0x3388cc, emissive: 0x112244 });
      const body = new THREE.Mesh(bodyGeo, bodyMat);
      body.position.y = 2.2;
      body.castShadow = true;
      g.add(body);
      // Head
      const headGeo = new THREE.BoxGeometry(0.9, 0.9, 0.9);
      const headMat = new THREE.MeshPhongMaterial({ color: 0x44aadd, emissive: 0x112233 });
      const head = new THREE.Mesh(headGeo, headMat);
      head.position.y = 3.5;
      head.castShadow = true;
      g.add(head);
      // Eyes (emissive)
      const eyeGeo = new THREE.BoxGeometry(0.15, 0.1, 0.05);
      const eyeMat = new THREE.MeshBasicMaterial({ color: 0x00ffff });
      const eyeL = new THREE.Mesh(eyeGeo, eyeMat);
      eyeL.position.set(-0.2, 3.55, 0.46);
      g.add(eyeL);
      const eyeR = eyeL.clone();
      eyeR.position.x = 0.2;
      g.add(eyeR);
      // Legs
      const legGeo = new THREE.BoxGeometry(0.35, 1, 0.35);
      const legMat = new THREE.MeshPhongMaterial({ color: 0x225588 });
      [-0.3, 0.3].forEach(x => {
        const leg = new THREE.Mesh(legGeo, legMat);
        leg.position.set(x, 0.9, 0);
        leg.castShadow = true;
        g.add(leg);
      });
      return g;
    },

    getTerrainHeight(x, z) {
      return noise(x * 0.02 + gameData.world.seed * 0.001, z * 0.02, 5) * 18;
    },

    update(delta) {
      if (!this.playerMesh) return;
      // Movement
      let mx = 0, mz = 0;
      if (Input.isKeyDown('w') || Input.isKeyDown('arrowup')) mz = -1;
      if (Input.isKeyDown('s') || Input.isKeyDown('arrowdown')) mz = 1;
      if (Input.isKeyDown('a') || Input.isKeyDown('arrowleft')) mx = -1;
      if (Input.isKeyDown('d') || Input.isKeyDown('arrowright')) mx = 1;

      // Gamepad
      const gp = Input.pollGamepad();
      if (gp) {
        if (Math.abs(gp.leftStick.x) > 0.15) mx = gp.leftStick.x;
        if (Math.abs(gp.leftStick.y) > 0.15) mz = gp.leftStick.y;
      }

      if (mx !== 0 || mz !== 0) {
        const angle = Math.atan2(mx, mz);
        this.playerRot = angle;
        const speed = this.moveSpeed * delta;
        this.playerPos.x += Math.sin(angle) * speed;
        this.playerPos.z += Math.cos(angle) * speed;
        // Clamp to terrain bounds
        const half = this.terrainSize * 0.45;
        this.playerPos.x = Math.max(-half, Math.min(half, this.playerPos.x));
        this.playerPos.z = Math.max(-half, Math.min(half, this.playerPos.z));
        // Drain energy slowly
        gameData.player.energy = Math.max(0, gameData.player.energy - delta * 0.5);
      }

      // Snap to terrain height
      const h = this.getTerrainHeight(this.playerPos.x, this.playerPos.z);
      this.playerPos.y = Math.max(h + 1, -0.5);
      this.playerMesh.position.copy(this.playerPos);
      this.playerMesh.rotation.y = this.playerRot;

      // Sync gameData position
      gameData.player.position.x = this.playerPos.x;
      gameData.player.position.y = this.playerPos.y;
      gameData.player.position.z = this.playerPos.z;

      CameraController.updateFollow(delta, this.playerPos);
      Weather.update(delta);
      DayNight.update(delta);

      // Minimap refresh (~4 Hz)
      if (frameCount % 15 === 0) Minimap.draw();
    },

    leaveToGalaxy() {
      Combat.cleanup();
      StatusEffects.clearAll();
      this.cleanup();
      scene.fog = new THREE.FogExp2(0x050510, 0.002);
      scene.background = new THREE.Color(0x050510);
      document.getElementById('minimap').style.display = 'none';
      document.getElementById('hud-env').style.display = 'none';
      setMode('galaxy');
      Galaxy.generate();
    },

    cleanup() {
      Enemies.cleanup();
      Bosses.cleanup();
      ShipDefense.cleanup();
      Companion.cleanup();
      AgentFleet.cleanup();
      Construction.cleanup();
      POISystem.cleanup();
      if (this.group) scene.remove(this.group);
      this.terrainMesh = null;
      this.waterMesh = null;
      this.trees = [];
      this.rocks = [];
      this.playerMesh = null;
      this.group = null;
    }
  };

  // ===== PHASE 2: WEATHER =====
  const WEATHER_ICONS = { clear: '‚òÄÔ∏è', rain: 'üåßÔ∏è', snow: '‚ùÑÔ∏è', fog: 'üå´Ô∏è', storm: '‚õàÔ∏è', sandstorm: 'üèúÔ∏è' };
  const Weather = {
    current: 'clear',
    timer: 120 + Math.random() * 180,
    particles: null,

    update(delta) {
      this.timer -= delta;
      if (this.timer <= 0) {
        const types = ['clear', 'clear', 'clear', 'rain', 'rain', 'snow', 'fog', 'storm', 'sandstorm'];
        this.current = types[Math.floor(Math.random() * types.length)];
        gameData.world.weather = this.current;
        this.timer = 120 + Math.random() * 180;
        this.applyEffects();
        Notifications.show((WEATHER_ICONS[this.current] || '') + ' Weather: ' + this.current, 'info', 2000);
      }
      this.updateUI();
    },

    applyEffects() {
      if (!scene.fog) return;
      switch (this.current) {
        case 'fog': scene.fog.density = 0.015; break;
        case 'storm': scene.fog.density = 0.012; break;
        case 'sandstorm': scene.fog.density = 0.018; break;
        default: scene.fog.density = 0.006; break;
      }
    },

    updateUI() {
      const el = document.getElementById('weather-indicator');
      if (el) el.textContent = (WEATHER_ICONS[this.current] || '') + ' ' + this.current.charAt(0).toUpperCase() + this.current.slice(1);
    }
  };

  // ===== PHASE 2: DAY/NIGHT CYCLE =====
  const DayNight = {
    cycleLength: 300, // 5 min = 1 game day

    update(delta) {
      gameData.world.dayNightCycle = (gameData.world.dayNightCycle + delta / this.cycleLength) % 1;
      const t = gameData.world.dayNightCycle;

      // 0=midnight, 0.25=dawn, 0.5=noon, 0.75=dusk
      let ambientIntensity, sunIntensity;
      let ambientColor, fogColor;

      if (t < 0.2) { // Night
        ambientIntensity = 0.15; sunIntensity = 0.1;
        ambientColor = 0x112244; fogColor = 0x111833;
      } else if (t < 0.3) { // Dawn
        const f = (t - 0.2) / 0.1;
        ambientIntensity = 0.15 + f * 0.45; sunIntensity = 0.1 + f * 0.6;
        ambientColor = 0x664433; fogColor = 0x886655;
      } else if (t < 0.7) { // Day
        ambientIntensity = 0.6; sunIntensity = 0.8;
        ambientColor = 0x556688; fogColor = 0x88aacc;
      } else if (t < 0.8) { // Dusk
        const f = (t - 0.7) / 0.1;
        ambientIntensity = 0.6 - f * 0.45; sunIntensity = 0.8 - f * 0.7;
        ambientColor = 0x664422; fogColor = 0x553322;
      } else { // Night
        ambientIntensity = 0.15; sunIntensity = 0.1;
        ambientColor = 0x112244; fogColor = 0x111833;
      }

      // Apply to scene lights
      scene.children.forEach(c => {
        if (c.isAmbientLight) { c.intensity = ambientIntensity; c.color.setHex(ambientColor); }
        if (c.isDirectionalLight) { c.intensity = sunIntensity; }
      });
      if (scene.background) scene.background.setHex(fogColor);

      this.updateUI(t);
    },

    updateUI(t) {
      const el = document.getElementById('time-indicator');
      if (!el) return;
      if (t < 0.2 || t >= 0.8) el.textContent = 'üåô Night';
      else if (t < 0.3) el.textContent = 'üåÖ Dawn';
      else if (t < 0.7) el.textContent = '‚òÄÔ∏è Day';
      else el.textContent = 'üåá Dusk';
    }
  };

  // ===== PHASE 2: MINIMAP =====
  const Minimap = {
    draw() {
      const canvas = document.getElementById('minimap');
      if (!canvas) return;
      const ctx = canvas.getContext('2d');
      const w = canvas.width, h = canvas.height;
      ctx.fillStyle = '#0a1520';
      ctx.fillRect(0, 0, w, h);

      const terrSize = World.terrainSize;
      const scale = w / terrSize;

      // Terrain colors
      for (let px = 0; px < w; px += 2) {
        for (let py = 0; py < h; py += 2) {
          const wx = (px / w - 0.5) * terrSize;
          const wz = (py / h - 0.5) * terrSize;
          const ht = World.getTerrainHeight(wx, wz);
          if (ht < -1) ctx.fillStyle = '#1a3366';
          else if (ht < 6) ctx.fillStyle = '#1a5522';
          else if (ht < 12) ctx.fillStyle = '#5a5040';
          else ctx.fillStyle = '#ccccdd';
          ctx.fillRect(px, py, 2, 2);
        }
      }

      // Trees as green dots
      World.trees.forEach(t => {
        const mx = (t.position.x / terrSize + 0.5) * w;
        const my = (t.position.z / terrSize + 0.5) * h;
        ctx.fillStyle = '#33aa44';
        ctx.fillRect(mx - 1, my - 1, 2, 2);
      });

      // Player indicator (pulsing white dot)
      const px = (World.playerPos.x / terrSize + 0.5) * w;
      const py = (World.playerPos.z / terrSize + 0.5) * h;
      const pulse = 2 + Math.sin(Date.now() * 0.005) * 1;
      ctx.fillStyle = '#ffffff';
      ctx.beginPath();
      ctx.arc(px, py, pulse, 0, Math.PI * 2);
      ctx.fill();
      // Direction indicator
      ctx.strokeStyle = '#00ffff';
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      ctx.moveTo(px, py);
      ctx.lineTo(px + Math.sin(World.playerRot) * 6, py + Math.cos(World.playerRot) * 6);
      ctx.stroke();

      // Phase 6: Draw agents
      AgentFleet.agents.forEach(a => {
        const ax = (a.position.x / terrSize + 0.5) * w;
        const ay = (a.position.z / terrSize + 0.5) * h;
        const aType = AgentFleet.types[a.type];
        ctx.fillStyle = '#' + aType.color.toString(16).padStart(6, '0');
        const sz = 1.5 + a.level * 0.2;
        ctx.beginPath();
        ctx.arc(ax, ay, sz, 0, Math.PI * 2);
        ctx.fill();
      });

      // Phase 7: Draw structures
      Construction.structures.forEach(s => {
        const sx = (s.position.x / terrSize + 0.5) * w;
        const sy = (s.position.z / terrSize + 0.5) * h;
        ctx.fillStyle = s.built ? '#00ddff' : '#555555';
        ctx.fillRect(sx-2, sy-2, 4, 4);
      });

      // Phase 7: Draw POIs
      POISystem.pois.forEach(p => {
        if (p.collected) return;
        const px2 = (p.position.x / terrSize + 0.5) * w;
        const py2 = (p.position.z / terrSize + 0.5) * h;
        const data = POISystem.types[p.type];
        ctx.fillStyle = '#' + data.color.toString(16).padStart(6,'0');
        ctx.beginPath();
        ctx.arc(px2, py2, p.discovered ? 3 : 2, 0, Math.PI * 2);
        ctx.fill();
      });

      // Phase 6: Draw companion
      if (Companion.mesh) {
        const cx = (Companion.mesh.position.x / terrSize + 0.5) * w;
        const cy = (Companion.mesh.position.z / terrSize + 0.5) * h;
        ctx.fillStyle = '#ffbb00';
        ctx.beginPath();
        ctx.arc(cx, cy, 2.5, 0, Math.PI * 2);
        ctx.fill();
      }
    }
  };

  // ===== PHASE 2: GALAXY CLICK HANDLING =====
  EventBus.on('click', (e) => {
    if (mode !== 'galaxy' || !Galaxy.group) return;
    Input.raycaster.setFromCamera(Input.mouse, camera);
    const hits = Input.raycaster.intersectObjects(Galaxy.starMeshes);
    if (hits.length > 0) {
      const idx = hits[0].object.userData.starIndex;
      if (idx !== undefined) Galaxy.select(idx);
    } else {
      Galaxy.select(-1);
    }
  });

  // Double-click to visit star
  let lastClickTime = 0;
  document.addEventListener('click', () => {
    const now = Date.now();
    if (now - lastClickTime < 400 && mode === 'galaxy' && Galaxy.selectedStar) {
      Galaxy.visit();
    }
    lastClickTime = now;
  });

  // ESC to leave world ‚Üí galaxy
  EventBus.on('keydown', (e) => {
    if (e.key === 'Escape' && mode === 'world') {
      World.leaveToGalaxy();
    }
    if (e.key === 'Enter' && mode === 'galaxy' && Galaxy.selectedStar) {
      Galaxy.visit();
    }
  });

  // ===== PHASE 2: UPDATE FUNCTIONS =====
  function updateGalaxy(delta) {
    Galaxy.update(delta);
    CameraController.updateOrbit(delta);
  }

  function updateWorld(delta) {
    World.update(delta);
    Combat.update(delta);
    StatusEffects.update(delta);
    Enemies.update(delta);
    Bosses.update(delta);
    WaveSystem.update(delta);
    ShipDefense.update(delta);
    Companion.update(delta);
    AgentFleet.update(delta);
    Construction.update(delta);
    POISystem.update(delta);
  }

  // ===== PHASE 3: COMBAT SYSTEM =====
  const Combat = {
    abilities: {
      powerStrike:   { key: 'q', name: 'Power Strike',    cooldown: 3,  damage: 25, energyCost: 10, timer: 0, type: 'melee' },
      shieldBash:    { key: 'e', name: 'Shield Bash',     cooldown: 5,  damage: 15, energyCost: 8,  timer: 0, type: 'melee', stun: 1.5 },
      fusRoDah:      { key: 'r', name: 'Force Push',      cooldown: 8,  damage: 30, energyCost: 20, timer: 0, type: 'aoe', radius: 15 },
      fireBlast:     { key: 't', name: 'Fire Blast',      cooldown: 6,  damage: 20, energyCost: 15, timer: 0, type: 'projectile', element: 'fire' },
      frostNova:     { key: 'f', name: 'Frost Nova',      cooldown: 10, damage: 15, energyCost: 18, timer: 0, type: 'aoe', radius: 12, element: 'ice' },
      lightningBolt: { key: 'z', name: 'Lightning Bolt',  cooldown: 4,  damage: 35, energyCost: 22, timer: 0, type: 'projectile', element: 'lightning' },
      poisonCloud:   { key: 'x', name: 'Poison Cloud',    cooldown: 12, damage: 8,  energyCost: 15, timer: 0, type: 'aoe', radius: 10, dot: 3, element: 'poison' },
      berserkerRage: { key: 'c', name: 'Berserker Rage',  cooldown: 20, damage: 0,  energyCost: 30, timer: 0, type: 'buff', duration: 8 }
    },
    comboCount: 0,
    comboTimer: 0,
    comboWindow: 3,
    hitStopTimer: 0,
    dodgeCooldown: 0,
    dodgeTimer: 0,
    dodgeDuration: 0.25,
    isDodging: false,
    parryWindow: 0,
    isParrying: false,
    buffs: [],
    damageFloaters: [],
    projectiles: [],
    shakeIntensity: 0,
    shakeDuration: 0,
    shakeTimer: 0,
    originalCameraPos: null,

    init() {
      const bar = document.getElementById('ability-bar');
      if (!bar) return;
      bar.innerHTML = '';

      for (const [key, ability] of Object.entries(this.abilities)) {
        const slot = document.createElement('div');
        slot.className = 'ability-slot ready';
        slot.dataset.ability = key;
        slot.innerHTML =
          `<span class="ability-icon">${ability.name.charAt(0)}</span>` +
          `<span class="key-hint">${ability.key.toUpperCase()}</span>` +
          `<span class="ability-name-tip">${ability.name} (${ability.energyCost}‚ö°)</span>`;
        slot.addEventListener('click', () => this.useAbility(key));
        bar.appendChild(slot);
      }

      // Key bindings for abilities
      EventBus.on('keydown', (e) => {
        if (mode !== 'world') return;
        // Don't trigger if user is typing in an input
        if (e.target && (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA')) return;

        const keyLower = e.key.toLowerCase();

        // Ability keys
        for (const [abilityKey, ability] of Object.entries(this.abilities)) {
          if (ability.key === keyLower) {
            this.useAbility(abilityKey);
            return;
          }
        }

        // Dodge (Space)
        if (e.key === ' ' || e.code === 'Space') {
          e.preventDefault();
          this.dodge();
        }

        // Parry (Shift)
        if (e.key === 'Shift') {
          this.startParry();
        }
      });

      Logger.debug('COMBAT', 'Combat system initialized with 8 abilities');
    },

    useAbility(abilityKey) {
      const ability = this.abilities[abilityKey];
      if (!ability) return;

      // Check cooldown
      if (ability.timer > 0) {
        Notifications.show(ability.name + ' on cooldown (' + ability.timer.toFixed(1) + 's)', 'warning', 1000);
        return;
      }

      // Check energy
      if (gameData.player.energy < ability.energyCost) {
        Notifications.show('Not enough energy for ' + ability.name, 'warning', 1000);
        return;
      }

      // Consume energy
      gameData.player.energy -= ability.energyCost;

      // Start cooldown
      ability.timer = ability.cooldown;

      // Bump combo
      this.comboCount++;
      this.comboTimer = this.comboWindow;

      const multiplier = this.getComboMultiplier();
      const finalDamage = Math.round(ability.damage * multiplier);

      // Execute by type
      switch (ability.type) {
        case 'melee':
          this.executeMelee(ability, finalDamage);
          break;
        case 'projectile':
          this.spawnProjectile(ability, finalDamage);
          break;
        case 'aoe':
          this.executeAoE(ability, finalDamage);
          break;
        case 'buff':
          this.executeBuff(ability);
          break;
      }

      // Hit-stop for impact
      if (ability.type !== 'buff') {
        this.applyHitStop(ability.type === 'aoe' ? 80 : 50);
      }

      // Visual feedback
      const dmgColor = ability.element ? StatusEffects.types[ability.element].color : '#ffffff';
      this.spawnDamageFloater(World.playerPos, finalDamage, dmgColor);

      EventBus.emit('abilityUsed', { ability: abilityKey, damage: finalDamage, combo: this.comboCount });

      if (this.comboCount > 1) {
        Notifications.show(`${ability.name}! Combo x${this.comboCount} (${multiplier.toFixed(1)}x)`, 'success', 1500);
      } else {
        Notifications.show(`${ability.name}! ${finalDamage > 0 ? finalDamage + ' damage' : ''}`, 'info', 1200);
      }
    },

    executeMelee(ability, damage) {
      // Visual flash on player
      if (World.playerMesh) {
        World.playerMesh.children.forEach(c => {
          if (c.material && c.material.emissive) {
            const orig = c.material.emissive.getHex();
            c.material.emissive.setHex(0xff4444);
            setTimeout(() => c.material.emissive.setHex(orig), 150);
          }
        });
      }
      screenShake(0.5, 0.2);

      // Phase 4: Hit nearby enemies
      const nearby = Enemies.findNearby(World.playerPos, 3);
      for (const enemy of nearby) {
        Enemies.damageEnemy(enemy, damage, 'melee');
        if (ability.stun) enemy.stunnedTimer = ability.stun;
      }
      // Also hit boss
      if (Bosses.activeBoss) {
        const bdx = Bosses.activeBoss.position.x - World.playerPos.x;
        const bdz = Bosses.activeBoss.position.z - World.playerPos.z;
        if (Math.sqrt(bdx * bdx + bdz * bdz) <= 4) {
          Bosses.damageBoss(damage, 'melee');
        }
      }
    },

    spawnProjectile(ability, damage) {
      const dir = new THREE.Vector3(
        Math.sin(World.playerRot),
        0,
        Math.cos(World.playerRot)
      ).normalize();

      const colorMap = { fire: 0xff4400, lightning: 0xffff00, ice: 0x88ddff, poison: 0x44ff44 };
      const color = colorMap[ability.element] || 0xffffff;

      const geo = new THREE.SphereGeometry(0.4, 8, 8);
      const mat = new THREE.MeshBasicMaterial({ color });
      const mesh = new THREE.Mesh(geo, mat);
      mesh.position.copy(World.playerPos).add(new THREE.Vector3(0, 2, 0));

      // Glow
      const glowMat = new THREE.SpriteMaterial({
        color, transparent: true, opacity: 0.5, blending: THREE.AdditiveBlending
      });
      const glow = new THREE.Sprite(glowMat);
      glow.scale.set(3, 3, 1);
      mesh.add(glow);

      if (World.group) World.group.add(mesh);

      this.projectiles.push({
        mesh, direction: dir, speed: 60, damage, element: ability.element,
        lifetime: 3, age: 0
      });

      screenShake(0.3, 0.15);
    },

    executeAoE(ability, damage) {
      // Visual ring expanding from player
      const color = ability.element ? StatusEffects.types[ability.element].color : '#ffffff';
      const colorHex = parseInt(color.replace('#', ''), 16) || 0xffffff;
      const radius = ability.radius || 10;

      const ringGeo = new THREE.RingGeometry(0.5, radius, 32);
      ringGeo.rotateX(-Math.PI / 2);
      const ringMat = new THREE.MeshBasicMaterial({
        color: colorHex, transparent: true, opacity: 0.6, side: THREE.DoubleSide
      });
      const ring = new THREE.Mesh(ringGeo, ringMat);
      ring.position.copy(World.playerPos);
      ring.position.y += 0.5;
      if (World.group) World.group.add(ring);

      // Animate ring fade
      let elapsed = 0;
      const animateRing = () => {
        elapsed += 0.016;
        if (elapsed > 0.6) {
          if (World.group) World.group.remove(ring);
          return;
        }
        ring.material.opacity = 0.6 * (1 - elapsed / 0.6);
        ring.scale.set(1 + elapsed * 2, 1, 1 + elapsed * 2);
        requestAnimationFrame(animateRing);
      };
      requestAnimationFrame(animateRing);

      // Apply elemental effect if applicable
      if (ability.element) {
        Logger.debug('COMBAT', `AoE ${ability.element} in radius ${radius}`);
      }

      // DoT setup for poison cloud
      if (ability.dot && ability.element) {
        Logger.debug('COMBAT', `DoT: ${ability.dot}s of ${ability.element}`);
      }

      // Phase 4: Hit enemies in AoE radius
      const aoEnemies = Enemies.findNearby(World.playerPos, radius);
      for (const enemy of aoEnemies) {
        Enemies.damageEnemy(enemy, damage, 'aoe');
        if (ability.element) {
          // Apply elemental status to enemy (using stun for ice/lightning)
          if (ability.element === 'ice') enemy.stunnedTimer = (enemy.stunnedTimer || 0) + 1;
          if (ability.element === 'lightning') enemy.stunnedTimer = (enemy.stunnedTimer || 0) + 0.5;
        }
      }
      // AoE hits boss too
      if (Bosses.activeBoss) {
        const bdx = Bosses.activeBoss.position.x - World.playerPos.x;
        const bdz = Bosses.activeBoss.position.z - World.playerPos.z;
        if (Math.sqrt(bdx * bdx + bdz * bdz) <= radius) {
          Bosses.damageBoss(damage, 'aoe');
        }
      }

      screenShake(0.8, 0.3);
    },

    executeBuff(ability) {
      const buff = {
        name: ability.name,
        duration: ability.duration,
        timer: ability.duration,
        damageMultiplier: 1.5,
        speedMultiplier: 1.3
      };
      this.buffs.push(buff);

      // Visual: player glows gold
      if (World.playerMesh) {
        World.playerMesh.children.forEach(c => {
          if (c.material && c.material.emissive) {
            c.material.emissive.setHex(0xff8800);
          }
        });
      }

      Notifications.show(`üî• ${ability.name} active! (${ability.duration}s)`, 'success', 2000);
      this.updateBuffUI();
    },

    update(delta) {
      if (mode !== 'world') return;

      // Hit-stop: freeze game briefly
      if (this.hitStopTimer > 0) {
        this.hitStopTimer -= delta * 1000;
        return; // Skip other updates during hit-stop
      }

      // Cooldown ticks
      for (const ability of Object.values(this.abilities)) {
        if (ability.timer > 0) {
          ability.timer = Math.max(0, ability.timer - delta);
        }
      }

      // Combo timer
      if (this.comboTimer > 0) {
        this.comboTimer -= delta;
        if (this.comboTimer <= 0) {
          if (this.comboCount > 1) {
            Notifications.show(`Combo ended: ${this.comboCount} hits`, 'info', 1200);
          }
          this.comboCount = 0;
        }
      }

      // Dodge timer
      if (this.isDodging) {
        this.dodgeTimer -= delta;
        if (this.dodgeTimer <= 0) {
          this.isDodging = false;
        }
      }
      if (this.dodgeCooldown > 0) {
        this.dodgeCooldown -= delta;
      }

      // Parry window
      if (this.isParrying) {
        this.parryWindow -= delta;
        if (this.parryWindow <= 0) {
          this.isParrying = false;
        }
      }

      // Buff timers
      for (let i = this.buffs.length - 1; i >= 0; i--) {
        this.buffs[i].timer -= delta;
        if (this.buffs[i].timer <= 0) {
          const expired = this.buffs.splice(i, 1)[0];
          Notifications.show(`${expired.name} expired`, 'info', 1500);
          // Reset player emissive
          if (World.playerMesh) {
            World.playerMesh.children.forEach(c => {
              if (c.material && c.material.emissive) {
                c.material.emissive.setHex(c.material === World.playerMesh.children[0]?.material ? 0x112244 : 0x112233);
              }
            });
          }
          this.updateBuffUI();
        }
      }

      // Update projectiles
      this.updateProjectiles(delta);

      // Update damage floaters
      this.updateDamageFloaters(delta);

      // Screen shake
      this.updateScreenShake(delta);

      // Update ability bar UI
      this.updateAbilityBarUI();

      // Energy regen (2/sec baseline)
      gameData.player.energy = Math.min(
        gameData.player.maxEnergy,
        gameData.player.energy + delta * 2
      );
    },

    updateProjectiles(delta) {
      for (let i = this.projectiles.length - 1; i >= 0; i--) {
        const proj = this.projectiles[i];
        proj.age += delta;

        // Move
        proj.mesh.position.addScaledVector(proj.direction, proj.speed * delta);

        // Check lifetime
        if (proj.age >= proj.lifetime) {
          if (World.group) World.group.remove(proj.mesh);
          this.projectiles.splice(i, 1);
          continue;
        }

        // Check out of bounds
        const half = World.terrainSize * 0.5;
        if (Math.abs(proj.mesh.position.x) > half || Math.abs(proj.mesh.position.z) > half) {
          if (World.group) World.group.remove(proj.mesh);
          this.projectiles.splice(i, 1);
          continue;
        }

        // Phase 4: Enemy projectile hits player
        if (proj.isEnemy) {
          const dx = proj.mesh.position.x - World.playerPos.x;
          const dz = proj.mesh.position.z - World.playerPos.z;
          const dy = proj.mesh.position.y - World.playerPos.y;
          if (Math.sqrt(dx * dx + dy * dy + dz * dz) < 2) {
            this.takeDamage(proj.damage, 'enemy projectile');
            if (World.group) World.group.remove(proj.mesh);
            this.projectiles.splice(i, 1);
            continue;
          }
        }

        // Phase 4: Player projectile hits enemies
        if (!proj.isEnemy) {
          let hitSomething = false;
          const nearby = Enemies.findNearby(proj.mesh.position, 2);
          for (const enemy of nearby) {
            const edx = proj.mesh.position.x - enemy.position.x;
            const edz = proj.mesh.position.z - enemy.position.z;
            if (Math.sqrt(edx * edx + edz * edz) < enemy.template.size + 0.5) {
              Enemies.damageEnemy(enemy, proj.damage, 'projectile');
              if (proj.element) {
                if (proj.element === 'ice') enemy.stunnedTimer = (enemy.stunnedTimer || 0) + 1;
                if (proj.element === 'lightning') enemy.stunnedTimer = (enemy.stunnedTimer || 0) + 0.5;
              }
              hitSomething = true;
              break;
            }
          }
          // Check boss hit
          if (!hitSomething && Bosses.activeBoss) {
            const bpos = Bosses.activeBoss.position;
            const bdx = proj.mesh.position.x - bpos.x;
            const bdz = proj.mesh.position.z - bpos.z;
            if (Math.sqrt(bdx * bdx + bdz * bdz) < Bosses.activeBoss.template.size) {
              Bosses.damageBoss(proj.damage, 'projectile');
              hitSomething = true;
            }
          }
          if (hitSomething) {
            if (World.group) World.group.remove(proj.mesh);
            this.projectiles.splice(i, 1);
            continue;
          }
        }

        // Terrain collision
        const terrainH = World.getTerrainHeight(proj.mesh.position.x, proj.mesh.position.z);
        if (proj.mesh.position.y < terrainH) {
          // Impact effect
          this.spawnDamageFloater(proj.mesh.position, proj.damage, StatusEffects.types[proj.element]?.color || '#ffffff');
          if (World.group) World.group.remove(proj.mesh);
          this.projectiles.splice(i, 1);
        }
      }
    },

    takeDamage(amount, source) {
      // Check dodge
      if (this.isDodging) {
        Notifications.show('Dodged!', 'success', 1000);
        return 0;
      }

      // Check parry
      if (this.isParrying) {
        Notifications.show('Parried! Reflected ' + Math.round(amount * 0.5) + ' damage!', 'success', 1500);
        this.isParrying = false;
        screenShake(0.6, 0.25);
        return -Math.round(amount * 0.5); // Negative = reflected
      }

      // Apply defense reduction
      const defense = gameData.player.stats.defense || 0;
      const reducedAmount = Math.max(1, Math.round(amount * (1 - defense * 0.02)));

      gameData.player.hp = Math.max(0, gameData.player.hp - reducedAmount);

      // Visual feedback
      this.spawnDamageFloater(World.playerPos, reducedAmount, '#ff4444');
      screenShake(reducedAmount / 20, 0.3);

      // Flash player red
      if (World.playerMesh) {
        World.playerMesh.children.forEach(c => {
          if (c.material && c.material.emissive) {
            const orig = c.material.emissive.getHex();
            c.material.emissive.setHex(0xff0000);
            setTimeout(() => c.material.emissive.setHex(orig), 200);
          }
        });
      }

      if (gameData.player.hp <= 0) {
        Notifications.show('üíÄ Probe destroyed!', 'error', 3000);
        gameData.session.deaths++;
        // Respawn with half resources
        setTimeout(() => {
          gameData.player.hp = Math.round(gameData.player.maxHp * 0.5);
          gameData.player.energy = Math.round(gameData.player.maxEnergy * 0.5);
          World.playerPos.set(0, World.getTerrainHeight(0, 0) + 1, 0);
          Notifications.show('Probe reconstructed at base', 'info', 2000);
        }, 1500);
      }

      EventBus.emit('damageTaken', { amount: reducedAmount, source });
      return reducedAmount;
    },

    heal(amount) {
      const before = gameData.player.hp;
      gameData.player.hp = Math.min(gameData.player.maxHp, gameData.player.hp + amount);
      const healed = gameData.player.hp - before;
      if (healed > 0) {
        this.spawnDamageFloater(World.playerPos, healed, '#00ff88');
        Notifications.show(`+${healed} HP`, 'success', 1000);
      }
      return healed;
    },

    dodge() {
      if (this.dodgeCooldown > 0) {
        Notifications.show('Dodge on cooldown', 'warning', 800);
        return;
      }

      this.isDodging = true;
      this.dodgeTimer = this.dodgeDuration;
      this.dodgeCooldown = 1.5;

      // Dash in movement direction
      const dashDist = 8;
      let dx = 0, dz = 0;
      if (Input.isKeyDown('w') || Input.isKeyDown('arrowup')) dz = -1;
      if (Input.isKeyDown('s') || Input.isKeyDown('arrowdown')) dz = 1;
      if (Input.isKeyDown('a') || Input.isKeyDown('arrowleft')) dx = -1;
      if (Input.isKeyDown('d') || Input.isKeyDown('arrowright')) dx = 1;

      // Default to forward if no input
      if (dx === 0 && dz === 0) {
        dx = Math.sin(World.playerRot);
        dz = Math.cos(World.playerRot);
      }

      const len = Math.sqrt(dx * dx + dz * dz);
      if (len > 0) {
        World.playerPos.x += (dx / len) * dashDist;
        World.playerPos.z += (dz / len) * dashDist;
        // Clamp
        const half = World.terrainSize * 0.45;
        World.playerPos.x = Math.max(-half, Math.min(half, World.playerPos.x));
        World.playerPos.z = Math.max(-half, Math.min(half, World.playerPos.z));
      }

      // Brief flash
      if (World.playerMesh) {
        World.playerMesh.visible = false;
        setTimeout(() => { if (World.playerMesh) World.playerMesh.visible = true; }, 100);
        setTimeout(() => { if (World.playerMesh) World.playerMesh.visible = false; }, 150);
        setTimeout(() => { if (World.playerMesh) World.playerMesh.visible = true; }, 200);
      }

      Logger.debug('COMBAT', 'Dodge executed');
    },

    startParry() {
      if (this.isParrying) return;
      this.isParrying = true;
      this.parryWindow = 0.3;

      // Visual: brief cyan flash
      if (World.playerMesh) {
        World.playerMesh.children.forEach(c => {
          if (c.material && c.material.emissive) {
            const orig = c.material.emissive.getHex();
            c.material.emissive.setHex(0x00ffff);
            setTimeout(() => {
              if (!this.isParrying && c.material) c.material.emissive.setHex(orig);
            }, 300);
          }
        });
      }

      Logger.debug('COMBAT', 'Parry window open');
    },

    applyHitStop(durationMs) {
      this.hitStopTimer = Math.max(this.hitStopTimer, durationMs);
    },

    spawnDamageFloater(position, amount, color) {
      if (!position || !camera || !renderer) return;

      // Project 3D position to screen
      const vec = new THREE.Vector3(position.x, position.y + 4, position.z);
      vec.project(camera);

      const hw = window.innerWidth / 2;
      const hh = window.innerHeight / 2;
      const screenX = (vec.x * hw) + hw + (Math.random() - 0.5) * 30;
      const screenY = -(vec.y * hh) + hh;

      // Don't show if behind camera
      if (vec.z > 1) return;

      const el = document.createElement('div');
      el.className = 'damage-floater';
      el.textContent = amount > 0 ? amount : '0';
      el.style.left = screenX + 'px';
      el.style.top = screenY + 'px';
      el.style.color = color || '#ff4444';

      // Scale with combo
      const scale = 1 + this.comboCount * 0.08;
      el.style.fontSize = Math.round(18 * scale) + 'px';

      document.body.appendChild(el);

      // Remove after animation
      setTimeout(() => {
        if (el.parentNode) el.parentNode.removeChild(el);
      }, 1200);
    },

    updateDamageFloaters() {
      // HTML floaters are self-removing via CSS animation + setTimeout
    },

    updateScreenShake(delta) {
      if (this.shakeTimer > 0) {
        this.shakeTimer -= delta;
        if (this.shakeTimer <= 0 && this.originalCameraPos) {
          camera.position.copy(this.originalCameraPos);
          this.originalCameraPos = null;
        } else if (this.originalCameraPos) {
          const factor = this.shakeTimer / this.shakeDuration;
          const intensity = this.shakeIntensity * factor;
          camera.position.x = this.originalCameraPos.x + (Math.random() - 0.5) * intensity;
          camera.position.y = this.originalCameraPos.y + (Math.random() - 0.5) * intensity;
        }
      }
    },

    getComboMultiplier() {
      return Math.min(3, 1 + this.comboCount * 0.1);
    },

    updateAbilityBarUI() {
      const bar = document.getElementById('ability-bar');
      if (!bar) return;

      const slots = bar.querySelectorAll('.ability-slot');
      const keys = Object.keys(this.abilities);

      slots.forEach((slot, i) => {
        const ability = this.abilities[keys[i]];
        if (!ability) return;

        const cdOverlay = slot.querySelector('.cd-overlay');

        if (ability.timer > 0) {
          slot.className = 'ability-slot on-cooldown';
          if (!cdOverlay) {
            const overlay = document.createElement('div');
            overlay.className = 'cd-overlay';
            overlay.textContent = ability.timer.toFixed(1);
            slot.appendChild(overlay);
          } else {
            cdOverlay.textContent = ability.timer.toFixed(1);
          }
        } else if (gameData.player.energy < ability.energyCost) {
          slot.className = 'ability-slot no-energy';
          if (cdOverlay) cdOverlay.remove();
        } else {
          slot.className = 'ability-slot ready';
          if (cdOverlay) cdOverlay.remove();
        }
      });
    },

    updateBuffUI() {
      const container = document.getElementById('buff-indicators');
      if (!container) return;
      container.innerHTML = '';
      for (const buff of this.buffs) {
        const el = document.createElement('div');
        el.className = 'buff-icon';
        el.textContent = buff.name.charAt(0);
        el.title = `${buff.name} (${buff.timer.toFixed(1)}s)`;
        container.appendChild(el);
      }
    },

    cleanup() {
      // Remove all projectiles from scene
      for (const proj of this.projectiles) {
        if (World.group) World.group.remove(proj.mesh);
      }
      this.projectiles = [];
      this.buffs = [];
      this.comboCount = 0;
      this.comboTimer = 0;
      this.hitStopTimer = 0;
      this.isDodging = false;
      this.isParrying = false;
      // Reset all cooldowns
      for (const ability of Object.values(this.abilities)) {
        ability.timer = 0;
      }
    }
  };

  // ===== PHASE 3: SCREEN SHAKE =====
  function screenShake(intensity, duration) {
    if (Combat.shakeTimer > 0 && Combat.shakeIntensity >= intensity) return;
    Combat.shakeIntensity = intensity;
    Combat.shakeDuration = duration;
    Combat.shakeTimer = duration;
    if (!Combat.originalCameraPos) {
      Combat.originalCameraPos = camera.position.clone();
    }
  }

  // ===== PHASE 3: STATUS EFFECTS =====
  const StatusEffects = {
    active: [],

    types: {
      fire:      { tickDamage: 3, tickRate: 1,   duration: 5, color: '#ff4400' },
      ice:       { slowFactor: 0.5, tickRate: 0, duration: 4, color: '#88ddff' },
      lightning: { stunDuration: 0.5, chainRange: 8, tickRate: 0, duration: 0.5, color: '#ffff00' },
      poison:    { tickDamage: 2, tickRate: 0.5, duration: 6, color: '#44ff44' }
    },

    apply(target, type, duration) {
      const template = this.types[type];
      if (!template) return;

      // Don't stack same type; refresh instead
      const existing = this.active.find(e => e.type === type && e.target === target);
      if (existing) {
        existing.duration = duration || template.duration;
        existing.timer = 0;
        return;
      }

      this.active.push({
        type,
        target,
        duration: duration || template.duration,
        elapsed: 0,
        tickRate: template.tickRate || 0,
        tickDamage: template.tickDamage || 0,
        timer: 0,
        color: template.color
      });

      Notifications.show(`${type.charAt(0).toUpperCase() + type.slice(1)} effect applied!`, 'warning', 1500);

      // Immediate effect for lightning stun
      if (type === 'lightning' && template.stunDuration) {
        Combat.applyHitStop(template.stunDuration * 1000);
      }

      // Slow for ice
      if (type === 'ice' && target === 'player') {
        World.moveSpeed *= template.slowFactor;
      }
    },

    update(delta) {
      for (let i = this.active.length - 1; i >= 0; i--) {
        const effect = this.active[i];
        effect.elapsed += delta;

        // Tick damage
        if (effect.tickRate > 0 && effect.tickDamage > 0) {
          effect.timer += delta;
          if (effect.timer >= effect.tickRate) {
            effect.timer -= effect.tickRate;
            if (effect.target === 'player') {
              gameData.player.hp = Math.max(0, gameData.player.hp - effect.tickDamage);
              Combat.spawnDamageFloater(World.playerPos, effect.tickDamage, effect.color);
            }
          }
        }

        // Expire
        if (effect.elapsed >= effect.duration) {
          // Undo effects
          if (effect.type === 'ice' && effect.target === 'player') {
            World.moveSpeed = 30; // Reset to default
          }
          this.active.splice(i, 1);
        }
      }
    },

    clearAll() {
      // Undo any active effects
      for (const effect of this.active) {
        if (effect.type === 'ice' && effect.target === 'player') {
          World.moveSpeed = 30;
        }
      }
      this.active = [];
    }
  };

  // ===== PHASE 4: SPATIAL PARTITIONING =====
  class QuadTree {
    constructor(bounds, capacity = 8) {
      this.bounds = bounds; // {x, z, w, h}
      this.capacity = capacity;
      this.items = [];
      this.divided = false;
      this.children = [];
    }

    contains(bounds, item) {
      return item.x >= bounds.x - bounds.w &&
             item.x <= bounds.x + bounds.w &&
             item.z >= bounds.z - bounds.h &&
             item.z <= bounds.z + bounds.h;
    }

    intersects(a, b) {
      return !(a.x - a.w > b.x + b.w || a.x + a.w < b.x - b.w ||
               a.z - a.h > b.z + b.h || a.z + a.h < b.z - b.h);
    }

    insert(item) {
      if (!this.contains(this.bounds, item)) return false;
      if (this.items.length < this.capacity && !this.divided) {
        this.items.push(item);
        return true;
      }
      if (!this.divided) this.subdivide();
      for (const child of this.children) {
        if (child.insert(item)) return true;
      }
      // Fallback: store here if children can't contain it
      this.items.push(item);
      return true;
    }

    query(range, found = []) {
      if (!this.intersects(this.bounds, range)) return found;
      for (const item of this.items) {
        if (this.contains(range, item)) found.push(item);
      }
      if (this.divided) {
        for (const child of this.children) child.query(range, found);
      }
      return found;
    }

    subdivide() {
      const { x, z, w, h } = this.bounds;
      const hw = w / 2, hh = h / 2;
      this.children.push(
        new QuadTree({ x: x - hw, z: z - hh, w: hw, h: hh }, this.capacity),
        new QuadTree({ x: x + hw, z: z - hh, w: hw, h: hh }, this.capacity),
        new QuadTree({ x: x - hw, z: z + hh, w: hw, h: hh }, this.capacity),
        new QuadTree({ x: x + hw, z: z + hh, w: hw, h: hh }, this.capacity)
      );
      this.divided = true;
    }

    clear() {
      this.items = [];
      this.divided = false;
      this.children = [];
    }
  }

  // ===== PHASE 4: OBJECT POOL =====
  class ObjectPool {
    constructor(factory, reset, initialSize = 20) {
      this.factory = factory;
      this.reset = reset;
      this.pool = [];
      this.active = [];
      for (let i = 0; i < initialSize; i++) this.pool.push(factory());
    }

    get() {
      const item = this.pool.length > 0 ? this.pool.pop() : this.factory();
      this.reset(item);
      this.active.push(item);
      return item;
    }

    release(item) {
      const idx = this.active.indexOf(item);
      if (idx !== -1) {
        this.active.splice(idx, 1);
        this.pool.push(item);
      }
    }

    releaseAll() {
      while (this.active.length > 0) {
        this.pool.push(this.active.pop());
      }
    }

    getActiveCount() { return this.active.length; }
  }

  // ===== PHASE 4: ENEMY SYSTEM =====
  const Enemies = {
    list: [],
    quadTree: null,
    spawnTimer: 0,
    spawnInterval: 3,
    maxEnemies: 30,

    types: {
      scout:   { hp: 30,  damage: 5,  speed: 12, xp: 10, gold: 5,  color: 0xff4444, size: 0.7, aggroRange: 20 },
      warrior: { hp: 60,  damage: 10, speed: 8,  xp: 20, gold: 10, color: 0xcc2222, size: 1.0, aggroRange: 15 },
      brute:   { hp: 120, damage: 18, speed: 5,  xp: 40, gold: 20, color: 0x991111, size: 1.4, aggroRange: 12 },
      ranger:  { hp: 40,  damage: 12, speed: 10, xp: 25, gold: 15, color: 0xdd6622, size: 0.8, aggroRange: 25, ranged: true },
      healer:  { hp: 50,  damage: 3,  speed: 9,  xp: 30, gold: 15, color: 0x44cc44, size: 0.8, healRate: 5, healRange: 12 },
    },

    affixes: ['enraged', 'shielded', 'vampiric', 'explosive', 'teleporting', 'freezing'],

    init() {
      this.list = [];
      this.spawnTimer = 0;
      const half = World.terrainSize / 2;
      this.quadTree = new QuadTree({ x: 0, z: 0, w: half, h: half });
      const el = document.getElementById('enemy-count');
      if (el) el.style.display = 'inline';
      Logger.debug('ENEMIES', 'Enemy system initialized');
    },

    spawn(position, typeName, isElite = false) {
      if (this.list.length >= this.maxEnemies) return null;

      const template = this.types[typeName];
      if (!template) return null;

      const affix = isElite ? this.affixes[Math.floor(Math.random() * this.affixes.length)] : null;
      const hpMult = isElite ? 2 : 1;
      const dmgMult = isElite ? 1.5 : 1;

      const mesh = this.createEnemyMesh(template, isElite);
      mesh.position.copy(position);

      if (World.group) World.group.add(mesh);

      const enemy = {
        type: typeName,
        template,
        hp: template.hp * hpMult,
        maxHp: template.hp * hpMult,
        damage: template.damage * dmgMult,
        speed: template.speed,
        position: position.clone(),
        mesh,
        state: 'idle',      // idle, aggro, chase, attack, retreat
        attackTimer: 0,
        attackCooldown: 1.5,
        healTimer: 0,
        isElite,
        affix,
        x: position.x,      // For QuadTree
        z: position.z,
        stunnedTimer: 0,
      };

      this.list.push(enemy);
      return enemy;
    },

    createEnemyMesh(template, isElite) {
      const g = new THREE.Group();
      const s = template.size * (isElite ? 1.3 : 1);

      // Body
      const bodyGeo = new THREE.BoxGeometry(s * 1.0, s * 1.4, s * 0.7);
      const bodyMat = new THREE.MeshPhongMaterial({
        color: template.color,
        emissive: isElite ? 0x442200 : 0x110000
      });
      const body = new THREE.Mesh(bodyGeo, bodyMat);
      body.position.y = s * 1.2;
      body.castShadow = true;
      g.add(body);

      // Head
      const headGeo = new THREE.SphereGeometry(s * 0.4, 8, 8);
      const headMat = new THREE.MeshPhongMaterial({
        color: template.color,
        emissive: isElite ? 0x442200 : 0x110000
      });
      const head = new THREE.Mesh(headGeo, headMat);
      head.position.y = s * 2.2;
      head.castShadow = true;
      g.add(head);

      // Eyes
      const eyeGeo = new THREE.SphereGeometry(s * 0.08, 4, 4);
      const eyeMat = new THREE.MeshBasicMaterial({ color: 0xff0000 });
      [-0.12, 0.12].forEach(xOff => {
        const eye = new THREE.Mesh(eyeGeo, eyeMat);
        eye.position.set(xOff * s, s * 2.3, s * 0.35);
        g.add(eye);
      });

      // Elite glow ring
      if (isElite) {
        const ringGeo = new THREE.RingGeometry(s * 1.2, s * 1.4, 16);
        ringGeo.rotateX(-Math.PI / 2);
        const ringMat = new THREE.MeshBasicMaterial({
          color: 0xffaa00, transparent: true, opacity: 0.5, side: THREE.DoubleSide
        });
        const ring = new THREE.Mesh(ringGeo, ringMat);
        ring.position.y = 0.1;
        g.add(ring);
      }

      return g;
    },

    update(delta) {
      if (this.list.length === 0 && this.spawnTimer <= 0) {
        this.spawnTimer = this.spawnInterval;
      }

      // Spawn timer
      this.spawnTimer -= delta;
      if (this.spawnTimer <= 0 && this.list.length < this.maxEnemies) {
        this.spawnWave();
        this.spawnTimer = this.spawnInterval;
      }

      // Rebuild QuadTree
      const half = World.terrainSize / 2;
      if (!this.quadTree) this.quadTree = new QuadTree({ x: 0, z: 0, w: half, h: half });
      this.quadTree.clear();
      for (const enemy of this.list) {
        enemy.x = enemy.position.x;
        enemy.z = enemy.position.z;
        this.quadTree.insert(enemy);
      }

      const playerPos = World.playerPos;

      for (let i = this.list.length - 1; i >= 0; i--) {
        const enemy = this.list[i];

        // Stunned check
        if (enemy.stunnedTimer > 0) {
          enemy.stunnedTimer -= delta;
          continue;
        }

        const dx = playerPos.x - enemy.position.x;
        const dz = playerPos.z - enemy.position.z;
        const dist = Math.sqrt(dx * dx + dz * dz);

        // State machine
        const aggroRange = enemy.template.aggroRange;
        const attackRange = enemy.template.ranged ? 18 : 2.0;

        switch (enemy.state) {
          case 'idle':
            if (dist < aggroRange) enemy.state = 'chase';
            break;

          case 'chase':
            if (dist > aggroRange * 1.5) {
              enemy.state = 'idle';
            } else if (dist <= attackRange) {
              enemy.state = 'attack';
            } else {
              // Move toward player
              const moveSpeed = enemy.speed * delta;
              const angle = Math.atan2(dx, dz);

              // Elite affix: enraged speeds up at low hp
              const speedMult = (enemy.isElite && enemy.affix === 'enraged' && enemy.hp < enemy.maxHp * 0.3) ? 1.8 : 1;

              enemy.position.x += Math.sin(angle) * moveSpeed * speedMult;
              enemy.position.z += Math.cos(angle) * moveSpeed * speedMult;

              // Clamp to terrain
              const terrainHalf = World.terrainSize * 0.45;
              enemy.position.x = Math.max(-terrainHalf, Math.min(terrainHalf, enemy.position.x));
              enemy.position.z = Math.max(-terrainHalf, Math.min(terrainHalf, enemy.position.z));

              // Snap Y to terrain
              enemy.position.y = World.getTerrainHeight(enemy.position.x, enemy.position.z) + enemy.template.size * 0.5;

              // Face player
              enemy.mesh.rotation.y = angle;
            }
            break;

          case 'attack':
            if (dist > attackRange * 1.3) {
              enemy.state = 'chase';
              break;
            }
            enemy.attackTimer -= delta;
            if (enemy.attackTimer <= 0) {
              enemy.attackTimer = enemy.attackCooldown;

              if (enemy.template.ranged) {
                // Ranged: spawn enemy projectile
                this.spawnEnemyProjectile(enemy);
              } else {
                // Melee: deal damage directly
                const dmg = Combat.takeDamage(enemy.damage, enemy.type);

                // Vampiric affix: heal on hit
                if (enemy.isElite && enemy.affix === 'vampiric' && dmg > 0) {
                  enemy.hp = Math.min(enemy.maxHp, enemy.hp + dmg * 0.3);
                }

                // Freezing affix: slow player
                if (enemy.isElite && enemy.affix === 'freezing') {
                  StatusEffects.apply('player', 'ice', 2);
                }
              }
            }
            break;

          case 'retreat':
            // Move away from player
            if (dist < aggroRange) {
              const away = Math.atan2(-dx, -dz);
              enemy.position.x += Math.sin(away) * enemy.speed * delta;
              enemy.position.z += Math.cos(away) * enemy.speed * delta;
              enemy.position.y = World.getTerrainHeight(enemy.position.x, enemy.position.z) + enemy.template.size * 0.5;
            } else {
              enemy.state = 'idle';
            }
            break;
        }

        // Healer: heal nearby wounded allies
        if (enemy.template.healRate && enemy.state !== 'idle') {
          enemy.healTimer -= delta;
          if (enemy.healTimer <= 0) {
            enemy.healTimer = 2;
            const nearby = this.findNearby(enemy.position, enemy.template.healRange || 12);
            for (const ally of nearby) {
              if (ally !== enemy && ally.hp < ally.maxHp) {
                ally.hp = Math.min(ally.maxHp, ally.hp + enemy.template.healRate);
                Combat.spawnDamageFloater(ally.position, enemy.template.healRate, '#44cc44');
                break; // heal one per tick
              }
            }
          }
        }

        // Elite affix: shielded damage reduction is handled in damageEnemy
        // Elite affix: teleporting - random blink near player
        if (enemy.isElite && enemy.affix === 'teleporting' && enemy.state === 'chase' && Math.random() < 0.005) {
          const tAngle = Math.random() * Math.PI * 2;
          const tDist = 5 + Math.random() * 5;
          enemy.position.x = playerPos.x + Math.cos(tAngle) * tDist;
          enemy.position.z = playerPos.z + Math.sin(tAngle) * tDist;
          enemy.position.y = World.getTerrainHeight(enemy.position.x, enemy.position.z) + enemy.template.size * 0.5;
        }

        // Update mesh position
        enemy.mesh.position.copy(enemy.position);
      }

      // Update HUD
      const el = document.getElementById('enemy-count');
      if (el) el.textContent = '‚öî ' + this.list.length;
    },

    spawnEnemyProjectile(enemy) {
      const dx = World.playerPos.x - enemy.position.x;
      const dz = World.playerPos.z - enemy.position.z;
      const len = Math.sqrt(dx * dx + dz * dz);
      if (len === 0) return;

      const dir = new THREE.Vector3(dx / len, 0, dz / len);
      const geo = new THREE.SphereGeometry(0.25, 6, 6);
      const mat = new THREE.MeshBasicMaterial({ color: 0xff6600 });
      const mesh = new THREE.Mesh(geo, mat);
      mesh.position.set(enemy.position.x, enemy.position.y + enemy.template.size, enemy.position.z);

      if (World.group) World.group.add(mesh);

      Combat.projectiles.push({
        mesh, direction: dir, speed: 30, damage: enemy.damage,
        element: null, lifetime: 3, age: 0, isEnemy: true
      });
    },

    spawnWave() {
      const typeNames = Object.keys(this.types);
      const count = 3 + Math.floor(Math.random() * 4);
      const level = gameData.player.level || 1;
      const eliteChance = Math.min(0.3, 0.05 + level * 0.02);

      for (let i = 0; i < count; i++) {
        if (this.list.length >= this.maxEnemies) break;

        const angle = Math.random() * Math.PI * 2;
        const dist = 30 + Math.random() * 20;
        const px = World.playerPos.x + Math.cos(angle) * dist;
        const pz = World.playerPos.z + Math.sin(angle) * dist;
        const half = World.terrainSize * 0.45;

        if (Math.abs(px) > half || Math.abs(pz) > half) continue;

        const py = World.getTerrainHeight(px, pz);
        if (py < -0.5) continue; // skip water

        // Pick type: weight toward easier types at low level
        let typeIdx = Math.floor(Math.random() * Math.min(typeNames.length, 2 + level));
        typeIdx = Math.min(typeIdx, typeNames.length - 1);

        const isElite = Math.random() < eliteChance;
        const pos = new THREE.Vector3(px, py + this.types[typeNames[typeIdx]].size * 0.5, pz);
        this.spawn(pos, typeNames[typeIdx], isElite);
      }
    },

    damageEnemy(enemy, amount, source) {
      if (!enemy || enemy.hp <= 0) return 0;

      // Shielded affix: 50% damage reduction
      let finalDmg = amount;
      if (enemy.isElite && enemy.affix === 'shielded') {
        finalDmg = Math.round(amount * 0.5);
      }

      enemy.hp -= finalDmg;

      Combat.spawnDamageFloater(enemy.position, finalDmg, enemy.isElite ? '#ffaa00' : '#ffffff');

      // Flash enemy red
      enemy.mesh.children.forEach(c => {
        if (c.material && c.material.emissive) {
          const orig = c.material.emissive.getHex();
          c.material.emissive.setHex(0xffffff);
          setTimeout(() => { if (c.material) c.material.emissive.setHex(orig); }, 100);
        }
      });

      if (enemy.hp <= 0) {
        this.killEnemy(enemy);
      }

      return finalDmg;
    },

    killEnemy(enemy) {
      // Award XP and gold via Phase 5 systems
      const bonuses = TalentTree.getBonuses();
      const xp = enemy.template.xp * (enemy.isElite ? 3 : 1);
      const goldMult = (1 + bonuses.goldMult) * (bonuses.doubleLoot ? 2 : 1);
      const gold = Math.round(enemy.template.gold * (enemy.isElite ? 3 : 1) * goldMult);

      Leveling.addXP(xp);
      gameData.player.gold = (gameData.player.gold || 0) + gold;
      gameData.session.killCount++;

      // Phase 5: Track quests
      Quests.track('kills', 1);
      if (enemy.isElite) Quests.track('eliteKills', 1);

      // Phase 5: Roll and award loot drops
      const drops = LootSystem.rollDrop(gameData.player.level, enemy.isElite, false);
      LootSystem.awardDrops(drops);

      // Elite death: bonus notification
      if (enemy.isElite) {
        Notifications.show(`üíÄ Elite ${enemy.type} slain! +${xp} XP +${gold} gold`, 'success', 2500);
      }

      // Explosive affix: AoE damage on death
      if (enemy.isElite && enemy.affix === 'explosive') {
        const dist = World.playerPos.distanceTo(enemy.position);
        if (dist < 8) {
          Combat.takeDamage(15, 'explosion');
          Notifications.show('üí• Explosive death!', 'warning', 1500);
          screenShake(1.0, 0.4);
        }
      }

      // Remove mesh
      if (World.group) World.group.remove(enemy.mesh);
      const idx = this.list.indexOf(enemy);
      if (idx !== -1) this.list.splice(idx, 1);

      // Feed into wave system and boss checks
      WaveSystem.onEnemyKilled();
      Bosses.checkSpawn();

      EventBus.emit('enemyKilled', { type: enemy.type, isElite: enemy.isElite, xp, gold });
    },

    findNearby(position, range) {
      if (!this.quadTree) return [];
      return this.quadTree.query({
        x: position.x, z: position.z,
        w: range, h: range
      }).filter(e => {
        const dx = e.position.x - position.x;
        const dz = e.position.z - position.z;
        return Math.sqrt(dx * dx + dz * dz) <= range;
      });
    },

    cleanup() {
      for (const enemy of this.list) {
        if (World.group) World.group.remove(enemy.mesh);
      }
      this.list = [];
      if (this.quadTree) this.quadTree.clear();
      const el = document.getElementById('enemy-count');
      if (el) el.style.display = 'none';
    }
  };

  // ===== PHASE 4: BOSS SYSTEM =====
  const Bosses = {
    activeBoss: null,
    spawnGateThreshold: 50,

    types: {
      overlord:   { hp: 500, damage: 30, speed: 6,  xp: 200, gold: 100, size: 3,   color: 0xff0000, attacks: ['slam', 'charge', 'summon'] },
      colossus:   { hp: 800, damage: 25, speed: 3,  xp: 300, gold: 150, size: 4,   color: 0x880088, attacks: ['stomp', 'sweep', 'roar'] },
      shadowLord: { hp: 400, damage: 40, speed: 10, xp: 250, gold: 120, size: 2.5, color: 0x220044, attacks: ['teleport', 'shadowBolt', 'darkAura'] },
    },

    checkSpawn() {
      if (this.activeBoss) return;
      if (gameData.session.killCount > 0 && gameData.session.killCount % this.spawnGateThreshold === 0) {
        this.spawn();
      }
    },

    spawn() {
      const typeNames = Object.keys(this.types);
      const typeName = typeNames[Math.floor(Math.random() * typeNames.length)];
      const template = this.types[typeName];

      const angle = Math.random() * Math.PI * 2;
      const dist = 40 + Math.random() * 20;
      const px = World.playerPos.x + Math.cos(angle) * dist;
      const pz = World.playerPos.z + Math.sin(angle) * dist;
      const half = World.terrainSize * 0.45;
      const cx = Math.max(-half, Math.min(half, px));
      const cz = Math.max(-half, Math.min(half, pz));
      const py = World.getTerrainHeight(cx, cz);

      // Build boss mesh
      const mesh = this.createBossMesh(template);
      mesh.position.set(cx, py + template.size * 0.5, cz);
      if (World.group) World.group.add(mesh);

      this.activeBoss = {
        type: typeName,
        template,
        hp: template.hp,
        maxHp: template.hp,
        damage: template.damage,
        speed: template.speed,
        position: new THREE.Vector3(cx, py + template.size * 0.5, cz),
        mesh,
        attackTimer: 0,
        attackCooldown: 3,
        currentAttack: 0,
        phase: 1,
        x: cx,
        z: cz,
      };

      // Show boss HUD
      const bar = document.getElementById('boss-health-bar');
      if (bar) bar.style.display = 'block';
      const nameEl = document.getElementById('boss-name');
      if (nameEl) nameEl.textContent = '‚ò† ' + typeName.toUpperCase();

      Notifications.show(`‚ö† BOSS: ${typeName.toUpperCase()} has appeared!`, 'error', 4000);
      screenShake(1.5, 0.6);
      Logger.debug('BOSS', `Spawned ${typeName} at ${cx.toFixed(0)},${cz.toFixed(0)}`);
    },

    createBossMesh(template) {
      const g = new THREE.Group();
      const s = template.size;

      // Body
      const bodyGeo = new THREE.BoxGeometry(s * 1.2, s * 1.8, s * 0.9);
      const bodyMat = new THREE.MeshPhongMaterial({
        color: template.color,
        emissive: 0x330000,
        shininess: 30
      });
      const body = new THREE.Mesh(bodyGeo, bodyMat);
      body.position.y = s * 1.2;
      body.castShadow = true;
      g.add(body);

      // Head
      const headGeo = new THREE.SphereGeometry(s * 0.5, 10, 10);
      const headMat = new THREE.MeshPhongMaterial({ color: template.color, emissive: 0x440000 });
      const head = new THREE.Mesh(headGeo, headMat);
      head.position.y = s * 2.6;
      head.castShadow = true;
      g.add(head);

      // Crown spikes
      for (let i = 0; i < 5; i++) {
        const spikeGeo = new THREE.ConeGeometry(s * 0.1, s * 0.6, 4);
        const spikeMat = new THREE.MeshBasicMaterial({ color: 0xff4400 });
        const spike = new THREE.Mesh(spikeGeo, spikeMat);
        const a = (i / 5) * Math.PI * 2;
        spike.position.set(Math.cos(a) * s * 0.35, s * 3.1, Math.sin(a) * s * 0.35);
        g.add(spike);
      }

      // Glow ring at base
      const ringGeo = new THREE.RingGeometry(s * 1.5, s * 1.8, 24);
      ringGeo.rotateX(-Math.PI / 2);
      const ringMat = new THREE.MeshBasicMaterial({
        color: 0xff0000, transparent: true, opacity: 0.4, side: THREE.DoubleSide
      });
      const ring = new THREE.Mesh(ringGeo, ringMat);
      ring.position.y = 0.1;
      g.add(ring);

      return g;
    },

    update(delta) {
      if (!this.activeBoss) return;
      const boss = this.activeBoss;

      const dx = World.playerPos.x - boss.position.x;
      const dz = World.playerPos.z - boss.position.z;
      const dist = Math.sqrt(dx * dx + dz * dz);

      // Phase transitions
      const hpPct = boss.hp / boss.maxHp;
      boss.phase = hpPct > 0.6 ? 1 : hpPct > 0.3 ? 2 : 3;
      boss.attackCooldown = boss.phase === 3 ? 1.5 : boss.phase === 2 ? 2 : 3;

      // Move toward player
      if (dist > 4) {
        const angle = Math.atan2(dx, dz);
        const speedMult = boss.phase === 3 ? 1.5 : 1;
        boss.position.x += Math.sin(angle) * boss.speed * speedMult * delta;
        boss.position.z += Math.cos(angle) * boss.speed * speedMult * delta;

        const terrainHalf = World.terrainSize * 0.45;
        boss.position.x = Math.max(-terrainHalf, Math.min(terrainHalf, boss.position.x));
        boss.position.z = Math.max(-terrainHalf, Math.min(terrainHalf, boss.position.z));
        boss.position.y = World.getTerrainHeight(boss.position.x, boss.position.z) + boss.template.size * 0.5;

        boss.mesh.rotation.y = angle;
      }

      // Attack
      boss.attackTimer -= delta;
      if (boss.attackTimer <= 0 && dist < 20) {
        boss.attackTimer = boss.attackCooldown;

        const attacks = boss.template.attacks;
        const atkName = attacks[boss.currentAttack % attacks.length];
        boss.currentAttack++;

        this.executeAttack(boss, atkName, dist);
      }

      // Update mesh and HUD
      boss.mesh.position.copy(boss.position);
      // Animate boss glow ring spin
      const ring = boss.mesh.children[boss.mesh.children.length - 1];
      if (ring) ring.rotation.z += delta * 0.5;

      const fill = document.getElementById('boss-bar-fill');
      if (fill) fill.style.width = (hpPct * 100) + '%';
    },

    executeAttack(boss, atkName, dist) {
      switch (atkName) {
        case 'slam':
        case 'stomp':
          if (dist < 8) {
            Combat.takeDamage(boss.damage, boss.type + ' ' + atkName);
            screenShake(1.2, 0.5);
          }
          // Visual: ground ring
          this.spawnAttackRing(boss.position, 8, 0xff4400);
          break;

        case 'charge':
        case 'sweep':
          if (dist < 12) {
            Combat.takeDamage(Math.round(boss.damage * 0.7), boss.type + ' ' + atkName);
            screenShake(0.8, 0.3);
          }
          break;

        case 'summon':
        case 'roar':
          // Summon 2-3 minions
          for (let i = 0; i < 2 + Math.floor(Math.random() * 2); i++) {
            const a = Math.random() * Math.PI * 2;
            const d = 5 + Math.random() * 5;
            const sx = boss.position.x + Math.cos(a) * d;
            const sz = boss.position.z + Math.sin(a) * d;
            const sy = World.getTerrainHeight(sx, sz);
            if (sy > -0.5) {
              Enemies.spawn(new THREE.Vector3(sx, sy + 0.5, sz), 'scout', false);
            }
          }
          Notifications.show('Boss summoned minions!', 'warning', 2000);
          break;

        case 'teleport':
          // Teleport near player
          const tAngle = Math.random() * Math.PI * 2;
          boss.position.x = World.playerPos.x + Math.cos(tAngle) * 5;
          boss.position.z = World.playerPos.z + Math.sin(tAngle) * 5;
          boss.position.y = World.getTerrainHeight(boss.position.x, boss.position.z) + boss.template.size * 0.5;
          Combat.takeDamage(Math.round(boss.damage * 0.5), 'teleport strike');
          screenShake(0.6, 0.2);
          break;

        case 'shadowBolt':
        case 'darkAura':
          if (dist < 15) {
            Combat.takeDamage(boss.damage, boss.type + ' ' + atkName);
            StatusEffects.apply('player', 'poison', 3);
          }
          this.spawnAttackRing(boss.position, 15, 0x440088);
          break;
      }
    },

    spawnAttackRing(position, radius, color) {
      const ringGeo = new THREE.RingGeometry(0.5, radius, 24);
      ringGeo.rotateX(-Math.PI / 2);
      const ringMat = new THREE.MeshBasicMaterial({
        color, transparent: true, opacity: 0.5, side: THREE.DoubleSide
      });
      const ring = new THREE.Mesh(ringGeo, ringMat);
      ring.position.copy(position);
      ring.position.y += 0.3;
      if (World.group) World.group.add(ring);

      let elapsed = 0;
      const fade = () => {
        elapsed += 0.016;
        if (elapsed > 0.8) {
          if (World.group) World.group.remove(ring);
          return;
        }
        ring.material.opacity = 0.5 * (1 - elapsed / 0.8);
        requestAnimationFrame(fade);
      };
      requestAnimationFrame(fade);
    },

    damageBoss(amount, source) {
      if (!this.activeBoss) return 0;
      const boss = this.activeBoss;

      boss.hp -= amount;
      Combat.spawnDamageFloater(boss.position, amount, '#ffaa00');

      // Flash boss white
      boss.mesh.children.forEach(c => {
        if (c.material && c.material.emissive) {
          const orig = c.material.emissive.getHex();
          c.material.emissive.setHex(0xffffff);
          setTimeout(() => { if (c.material) c.material.emissive.setHex(orig); }, 120);
        }
      });

      if (boss.hp <= 0) {
        this.killBoss();
      }
      return amount;
    },

    killBoss() {
      const boss = this.activeBoss;
      if (!boss) return;

      const xp = boss.template.xp;
      const bonuses = TalentTree.getBonuses();
      const goldMult = (1 + bonuses.goldMult) * (bonuses.doubleLoot ? 2 : 1);
      const gold = Math.round(boss.template.gold * goldMult);
      Leveling.addXP(xp);
      gameData.player.gold = (gameData.player.gold || 0) + gold;
      gameData.session.killCount++;
      gameData.session.bossKills++;

      // Phase 5: Track quests and loot
      Quests.track('kills', 1);
      Quests.track('bossKills', 1);
      const drops = LootSystem.rollDrop(gameData.player.level, false, true);
      LootSystem.awardDrops(drops);

      Notifications.show(`üèÜ BOSS DEFEATED: ${boss.type.toUpperCase()}! +${xp} XP +${gold} gold`, 'success', 5000);
      screenShake(2.0, 0.8);

      if (World.group) World.group.remove(boss.mesh);
      this.activeBoss = null;

      const bar = document.getElementById('boss-health-bar');
      if (bar) bar.style.display = 'none';

      EventBus.emit('bossKilled', { type: boss.type, xp, gold });
    },

    cleanup() {
      if (this.activeBoss && World.group) {
        World.group.remove(this.activeBoss.mesh);
      }
      this.activeBoss = null;
      const bar = document.getElementById('boss-health-bar');
      if (bar) bar.style.display = 'none';
    }
  };

  // ===== PHASE 4: WAVE SYSTEM =====
  const WaveSystem = {
    waveNumber: 0,
    active: false,
    enemiesRemaining: 0,
    timer: 0,
    betweenWaveDelay: 15,

    start() {
      this.waveNumber++;
      this.active = true;
      const count = 3 + this.waveNumber * 2;
      this.enemiesRemaining = count;
      Notifications.show(`Wave ${this.waveNumber} ‚Äî ${count} enemies incoming!`, 'warning', 3000);

      // Spawn in batches
      let spawned = 0;
      const batchSize = Math.min(count, 6);
      const spawnBatch = () => {
        const toSpawn = Math.min(batchSize, count - spawned);
        for (let i = 0; i < toSpawn; i++) {
          const angle = Math.random() * Math.PI * 2;
          const dist = 30 + Math.random() * 20;
          const px = World.playerPos.x + Math.cos(angle) * dist;
          const pz = World.playerPos.z + Math.sin(angle) * dist;
          const half = World.terrainSize * 0.45;
          if (Math.abs(px) <= half && Math.abs(pz) <= half) {
            const py = World.getTerrainHeight(px, pz);
            if (py > -0.5) {
              const typeNames = Object.keys(Enemies.types);
              const level = gameData.player.level || 1;
              const typeIdx = Math.min(Math.floor(Math.random() * Math.min(typeNames.length, 2 + level)), typeNames.length - 1);
              const isElite = this.waveNumber >= 3 && Math.random() < 0.15;
              const typeName = typeNames[typeIdx];
              Enemies.spawn(new THREE.Vector3(px, py + Enemies.types[typeName].size * 0.5, pz), typeName, isElite);
            }
          }
          spawned++;
        }
        if (spawned < count) setTimeout(spawnBatch, 1500);
      };
      spawnBatch();
    },

    onEnemyKilled() {
      if (!this.active) return;
      this.enemiesRemaining--;
      if (this.enemiesRemaining <= 0) {
        this.active = false;
        Notifications.show(`Wave ${this.waveNumber} complete!`, 'success', 3000);
        this.timer = this.betweenWaveDelay;
      }
    },

    update(delta) {
      if (this.active) return;
      this.timer -= delta;
      if (this.timer <= 0) {
        this.start();
      }
    }
  };

  // ===== PHASE 4: SHIP DEFENSE =====
  const ShipDefense = {
    shipMesh: null,
    shipHp: 200,
    maxShipHp: 200,
    lasers: [],
    autoTargetTimer: 0,
    autoTargetCooldown: 2,
    laserRange: 25,
    laserDamage: 15,
    position: null,

    init(position) {
      this.position = position.clone();
      this.shipHp = this.maxShipHp;

      // Build ship mesh: wider, flatter robot-ship
      const g = new THREE.Group();

      // Hull
      const hullGeo = new THREE.BoxGeometry(4, 1.5, 3);
      const hullMat = new THREE.MeshPhongMaterial({ color: 0x556688, emissive: 0x112233, shininess: 40 });
      const hull = new THREE.Mesh(hullGeo, hullMat);
      hull.position.y = 1.5;
      hull.castShadow = true;
      g.add(hull);

      // Cockpit
      const cockpitGeo = new THREE.SphereGeometry(0.8, 8, 8, 0, Math.PI * 2, 0, Math.PI / 2);
      const cockpitMat = new THREE.MeshPhongMaterial({ color: 0x88ccff, emissive: 0x224466, transparent: true, opacity: 0.7 });
      const cockpit = new THREE.Mesh(cockpitGeo, cockpitMat);
      cockpit.position.y = 2.25;
      g.add(cockpit);

      // Engine glow
      [-1.2, 1.2].forEach(x => {
        const glowMat = new THREE.MeshBasicMaterial({ color: 0x00aaff });
        const glowGeo = new THREE.CylinderGeometry(0.3, 0.4, 0.3, 6);
        const glow = new THREE.Mesh(glowGeo, glowMat);
        glow.position.set(x, 0.8, -1.2);
        g.add(glow);
      });

      // Landing legs
      [-1.5, 1.5].forEach(x => {
        [-0.8, 0.8].forEach(z => {
          const legGeo = new THREE.CylinderGeometry(0.08, 0.12, 0.8, 4);
          const legMat = new THREE.MeshPhongMaterial({ color: 0x445566 });
          const leg = new THREE.Mesh(legGeo, legMat);
          leg.position.set(x, 0.4, z);
          g.add(leg);
        });
      });

      g.position.copy(this.position);
      g.position.y = World.getTerrainHeight(this.position.x, this.position.z) + 0.5;
      this.position.y = g.position.y;

      if (World.group) World.group.add(g);
      this.shipMesh = g;

      Logger.debug('SHIP', 'Ship defense initialized');
    },

    update(delta) {
      if (!this.shipMesh) return;

      // Update lasers (fade out)
      for (let i = this.lasers.length - 1; i >= 0; i--) {
        const laser = this.lasers[i];
        laser.age += delta;
        if (laser.age > 0.2) {
          if (World.group) World.group.remove(laser.mesh);
          this.lasers.splice(i, 1);
        } else {
          laser.mesh.material.opacity = 1 - (laser.age / 0.2);
        }
      }

      // Auto-target
      this.autoTargetTimer -= delta;
      if (this.autoTargetTimer > 0) return;

      // Find nearest enemy
      const nearby = Enemies.findNearby(this.position, this.laserRange);
      if (nearby.length === 0) return;

      // Sort by distance
      let closest = null;
      let closestDist = Infinity;
      for (const enemy of nearby) {
        const dx = enemy.position.x - this.position.x;
        const dz = enemy.position.z - this.position.z;
        const d = Math.sqrt(dx * dx + dz * dz);
        if (d < closestDist) {
          closestDist = d;
          closest = enemy;
        }
      }

      // Also check boss
      if (Bosses.activeBoss) {
        const bdx = Bosses.activeBoss.position.x - this.position.x;
        const bdz = Bosses.activeBoss.position.z - this.position.z;
        const bd = Math.sqrt(bdx * bdx + bdz * bdz);
        if (bd < this.laserRange && bd < closestDist) {
          // Fire at boss
          this.fireLaser(Bosses.activeBoss.position);
          Bosses.damageBoss(this.laserDamage, 'ship laser');
          this.autoTargetTimer = this.autoTargetCooldown;
          return;
        }
      }

      if (!closest) return;

      this.fireLaser(closest.position);
      Enemies.damageEnemy(closest, this.laserDamage, 'ship laser');
      this.autoTargetTimer = this.autoTargetCooldown;
    },

    fireLaser(targetPos) {
      const from = this.position.clone();
      from.y += 2;
      const to = targetPos.clone();
      to.y += 1;

      const points = [from, to];
      const geo = new THREE.BufferGeometry().setFromPoints(points);
      const mat = new THREE.LineBasicMaterial({
        color: 0x00aaff, transparent: true, opacity: 1, linewidth: 2
      });
      const line = new THREE.Line(geo, mat);

      if (World.group) World.group.add(line);
      this.lasers.push({ mesh: line, age: 0 });
    },

    takeDamage(amount) {
      this.shipHp = Math.max(0, this.shipHp - amount);
      if (this.shipHp <= 0) {
        Notifications.show('‚ö† Ship destroyed!', 'error', 3000);
      }
    },

    cleanup() {
      for (const laser of this.lasers) {
        if (World.group) World.group.remove(laser.mesh);
      }
      this.lasers = [];
      if (this.shipMesh && World.group) {
        World.group.remove(this.shipMesh);
      }
      this.shipMesh = null;
    }
  };

  // ===== PHASE 5: LEVELING SYSTEM =====
  const Leveling = {
    xpCurve(level) { return Math.floor(100 * Math.pow(1.5, level - 1)); },

    addXP(amount) {
      amount = Math.round(amount * Prestige.bonusMultiplier());
      gameData.player.xp += amount;
      while (gameData.player.xp >= gameData.player.xpToNext) {
        gameData.player.xp -= gameData.player.xpToNext;
        gameData.player.level++;
        gameData.player.xpToNext = this.xpCurve(gameData.player.level);
        this.onLevelUp();
      }
      this.updateUI();
    },

    onLevelUp() {
      const lvl = gameData.player.level;
      gameData.player.maxHp += 10;
      gameData.player.hp = gameData.player.maxHp;
      gameData.player.maxEnergy += 5;
      gameData.player.energy = gameData.player.maxEnergy;
      gameData.player.stats.strength += 2;
      gameData.player.stats.defense += 1;
      Notifications.show(`‚¨Ü Level Up! Now level ${lvl}`, 'success', 3000);
      A11y.announce(`Level up. Now level ${lvl}`);
      EventBus.emit('levelUp', { level: lvl });
    },

    updateUI() {
      const p = gameData.player;
      const pct = (p.xp / p.xpToNext) * 100;
      const bar = document.getElementById('xp-bar');
      const text = document.getElementById('xp-text');
      const lvlEl = document.getElementById('player-level');
      if (bar) bar.style.width = pct + '%';
      if (text) text.textContent = `${p.xp} / ${p.xpToNext} XP`;
      if (lvlEl) lvlEl.textContent = p.level;
    }
  };

  // ===== PHASE 5: EQUIPMENT SYSTEM =====
  const Equipment = {
    slots: ['weapon', 'armor', 'accessory', 'rune'],
    rarities: ['common', 'uncommon', 'rare', 'epic', 'legendary'],
    rarityColors: { common: '#aaa', uncommon: '#2ecc71', rare: '#3498db', epic: '#9b59b6', legendary: '#f39c12' },
    rarityMultipliers: { common: 1, uncommon: 1.3, rare: 1.6, epic: 2, legendary: 3 },

    weaponNames: ['Blade','Sword','Axe','Mace','Dagger','Staff','Spear','Hammer'],
    armorNames: ['Chestplate','Mail','Vest','Robe','Shield','Cuirass'],
    accessoryNames: ['Ring','Amulet','Pendant','Charm','Talisman','Brooch'],
    runeNames: ['Rune of Power','Rune of Warding','Rune of Haste','Rune of Fortune','Rune of Flame','Rune of Frost'],

    generate(level, forcedRarity) {
      const slot = this.slots[Math.floor(Math.random() * this.slots.length)];
      const rarity = forcedRarity || this._rollRarity();
      const mult = this.rarityMultipliers[rarity];
      const base = Math.max(1, Math.floor(level * 1.2));
      const names = slot === 'weapon' ? this.weaponNames : slot === 'armor' ? this.armorNames : slot === 'accessory' ? this.accessoryNames : this.runeNames;
      const name = `${rarity.charAt(0).toUpperCase() + rarity.slice(1)} ${names[Math.floor(Math.random() * names.length)]}`;
      return {
        name, slot, rarity, level,
        stats: {
          strength: slot === 'weapon' ? Math.round(base * mult * (1 + Math.random() * 0.5)) : Math.round(base * mult * Math.random() * 0.3),
          defense: slot === 'armor' ? Math.round(base * mult * (1 + Math.random() * 0.5)) : Math.round(base * mult * Math.random() * 0.3),
          speed: slot === 'accessory' ? Math.round(base * mult * Math.random() * 0.5) : 0,
          luck: slot === 'accessory' ? Math.round(base * mult * Math.random() * 0.4) : 0
        },
        value: Math.round(base * mult * 10),
        enchant: null
      };
    },

    _rollRarity() {
      const r = Math.random();
      if (r < 0.01) return 'legendary';
      if (r < 0.06) return 'epic';
      if (r < 0.18) return 'rare';
      if (r < 0.40) return 'uncommon';
      return 'common';
    },

    equip(item) {
      const old = gameData.player.equipment[item.slot];
      gameData.player.equipment[item.slot] = item;
      if (old) gameData.player.inventory.push(old);
      const idx = gameData.player.inventory.indexOf(item);
      if (idx !== -1) gameData.player.inventory.splice(idx, 1);
      this.recalcStats();
      Notifications.show(`Equipped ${item.name}`, 'success');
    },

    unequip(slot) {
      const item = gameData.player.equipment[slot];
      if (!item) return;
      gameData.player.equipment[slot] = null;
      gameData.player.inventory.push(item);
      this.recalcStats();
      Notifications.show(`Unequipped ${item.name}`, 'info');
    },

    recalcStats() {
      const base = { strength: 10, defense: 5, speed: 8, luck: 3 };
      for (const slot of this.slots) {
        const item = gameData.player.equipment[slot];
        if (item && item.stats) {
          base.strength += item.stats.strength || 0;
          base.defense += item.stats.defense || 0;
          base.speed += item.stats.speed || 0;
          base.luck += item.stats.luck || 0;
        }
      }
      const talentBonuses = TalentTree.getBonuses();
      base.strength = Math.round(base.strength * (1 + (talentBonuses.meleeDamage || 0)));
      base.defense = Math.round(base.defense * (1 + (talentBonuses.maxHpMult || 0)));
      gameData.player.stats = base;
    },

    getItemTooltip(item) {
      return `${item.name}\n${item.rarity} ${item.slot}\nSTR +${item.stats.strength} DEF +${item.stats.defense}${item.stats.speed ? ' SPD +' + item.stats.speed : ''}${item.stats.luck ? ' LCK +' + item.stats.luck : ''}${item.enchant ? '\n‚ú® ' + item.enchant : ''}`;
    }
  };

  // ===== PHASE 5: CRAFTING SYSTEM =====
  const Crafting = {
    recipes: [
      { name: 'Iron Sword', slot: 'weapon', materials: { iron: 3, wood: 1 }, stats: { strength: 8, defense: 0, speed: 0, luck: 0 }, rarity: 'uncommon' },
      { name: 'Steel Armor', slot: 'armor', materials: { iron: 5, leather: 2 }, stats: { strength: 0, defense: 10, speed: 0, luck: 0 }, rarity: 'uncommon' },
      { name: 'Lucky Charm', slot: 'accessory', materials: { crystal: 2, gold_dust: 1 }, stats: { strength: 0, defense: 0, speed: 2, luck: 5 }, rarity: 'rare' },
      { name: 'Fire Rune', slot: 'rune', materials: { crystal: 3, fire_essence: 2 }, stats: { strength: 4, defense: 0, speed: 0, luck: 0 }, rarity: 'rare', element: 'fire' },
      { name: 'Health Potion', type: 'consumable', materials: { herb: 2 }, effect: { heal: 50 } },
      { name: 'Energy Potion', type: 'consumable', materials: { crystal: 1, herb: 1 }, effect: { energy: 50 } },
    ],

    canCraft(recipe) {
      const mats = this.getMaterials();
      for (const [mat, count] of Object.entries(recipe.materials)) {
        const reduction = TalentTree.getBonuses().craftCostReduction || 0;
        if ((mats[mat] || 0) < Math.max(1, count - reduction)) return false;
      }
      return true;
    },

    craft(recipeName) {
      const recipe = this.recipes.find(r => r.name === recipeName);
      if (!recipe || !this.canCraft(recipe)) return false;
      const reduction = TalentTree.getBonuses().craftCostReduction || 0;
      for (const [mat, count] of Object.entries(recipe.materials)) {
        let needed = Math.max(1, count - reduction);
        for (let i = gameData.player.inventory.length - 1; i >= 0 && needed > 0; i--) {
          const item = gameData.player.inventory[i];
          if (item.type === 'material' && item.name === mat) {
            gameData.player.inventory.splice(i, 1);
            needed--;
          }
        }
      }
      if (recipe.type === 'consumable') {
        gameData.player.inventory.push({ type: 'consumable', name: recipe.name, effect: recipe.effect });
      } else {
        const item = {
          name: recipe.name, slot: recipe.slot, rarity: recipe.rarity || 'uncommon',
          level: gameData.player.level,
          stats: { ...recipe.stats },
          value: 20, enchant: null
        };
        if (recipe.element) item.element = recipe.element;
        gameData.player.inventory.push(item);
      }
      Notifications.show(`Crafted ${recipe.name}!`, 'success');
      if (!gameData.player.achievements.includes('craft_first')) Achievements.unlock('craft_first');
      return true;
    },

    getMaterials() {
      const counts = {};
      gameData.player.inventory.forEach(item => {
        if (item.type === 'material') {
          counts[item.name] = (counts[item.name] || 0) + (item.quantity || 1);
        }
      });
      return counts;
    }
  };

  // ===== PHASE 5: ENCHANTMENT SYSTEM =====
  const Enchanting = {
    enchants: {
      lifesteal:        { name: 'Lifesteal',          desc: 'Heal 10% of damage dealt',         cost: 50 },
      thorns:           { name: 'Thorns',             desc: 'Reflect 15% damage to attackers',  cost: 60 },
      haste:            { name: 'Haste',              desc: '+15% movement speed',              cost: 40 },
      fortify:          { name: 'Fortify',            desc: '+20% max HP',                      cost: 70 },
      manaFlow:         { name: 'Mana Flow',          desc: '+25% energy regen',                cost: 55 },
      critStrike:       { name: 'Critical Strike',    desc: '15% chance for 2x damage',         cost: 65 },
      elementalMastery: { name: 'Elemental Mastery',  desc: '+30% elemental damage',            cost: 80 },
      ironSkin:         { name: 'Iron Skin',          desc: '-10% damage taken',                cost: 50 },
    },

    apply(item, enchantKey) {
      const enchant = this.enchants[enchantKey];
      if (!enchant) return false;
      if (gameData.player.gold < enchant.cost) {
        Notifications.show('Not enough gold!', 'warning');
        return false;
      }
      gameData.player.gold -= enchant.cost;
      item.enchant = enchantKey;
      Notifications.show(`‚ú® Enchanted ${item.name} with ${enchant.name}`, 'success');
      return true;
    },

    getEnchantedBonuses() {
      const bonuses = {};
      for (const slot of Equipment.slots) {
        const item = gameData.player.equipment[slot];
        if (item && item.enchant && this.enchants[item.enchant]) {
          bonuses[item.enchant] = true;
        }
      }
      return bonuses;
    }
  };

  // ===== PHASE 5: TALENT TREE =====
  const TalentTree = {
    trees: {
      combat: {
        name: 'Combat', color: '#ff4444',
        talents: [
          { id: 'c1', name: 'Sharpened Blade',  desc: '+10% melee damage',              maxRank: 3, requires: [] },
          { id: 'c2', name: 'Quick Strikes',    desc: '-10% ability cooldown',           maxRank: 3, requires: ['c1'] },
          { id: 'c3', name: 'Devastating Blow',  desc: '5% chance for critical hit',     maxRank: 3, requires: ['c1'] },
          { id: 'c4', name: 'Battle Fury',      desc: '+1 combo duration per rank',      maxRank: 2, requires: ['c2','c3'] },
          { id: 'c5', name: 'Warlord',          desc: 'Abilities cost 20% less energy',  maxRank: 1, requires: ['c4'] },
        ]
      },
      survival: {
        name: 'Survival', color: '#00ff88',
        talents: [
          { id: 's1', name: 'Thick Skin',     desc: '+10% max HP',                           maxRank: 3, requires: [] },
          { id: 's2', name: 'Quick Recovery',  desc: '+15% HP regen',                         maxRank: 3, requires: ['s1'] },
          { id: 's3', name: 'Evasion',         desc: '5% dodge chance',                       maxRank: 3, requires: ['s1'] },
          { id: 's4', name: 'Second Wind',     desc: 'Heal 30% HP when below 20%',            maxRank: 1, requires: ['s2'] },
          { id: 's5', name: 'Immortal',        desc: 'Survive fatal hit with 1 HP (60s CD)',  maxRank: 1, requires: ['s3','s4'] },
        ]
      },
      fortune: {
        name: 'Fortune', color: '#ffbb00',
        talents: [
          { id: 'f1', name: 'Lucky Find',          desc: '+15% gold from kills',          maxRank: 3, requires: [] },
          { id: 'f2', name: 'Treasure Hunter',      desc: '+10% rare item chance',        maxRank: 3, requires: ['f1'] },
          { id: 'f3', name: 'Efficient Crafting',   desc: '-1 material cost per rank',    maxRank: 2, requires: ['f1'] },
          { id: 'f4', name: 'Midas Touch',          desc: 'Enemies drop 2x gold',         maxRank: 1, requires: ['f2'] },
          { id: 'f5', name: 'Jackpot',              desc: '1% chance for 10x loot',        maxRank: 1, requires: ['f2','f3'] },
        ]
      }
    },

    _findTalent(talentId) {
      for (const tree of Object.values(this.trees)) {
        const t = tree.talents.find(t => t.id === talentId);
        if (t) return t;
      }
      return null;
    },

    getRank(talentId) { return gameData.player.talents[talentId] || 0; },

    canLearn(talentId) {
      const talent = this._findTalent(talentId);
      if (!talent) return false;
      if (this.getRank(talentId) >= talent.maxRank) return false;
      if (this.getTalentPoints() <= 0) return false;
      for (const req of talent.requires) {
        const reqTalent = this._findTalent(req);
        if (reqTalent && this.getRank(req) < reqTalent.maxRank) return false;
      }
      return true;
    },

    learn(talentId) {
      if (!this.canLearn(talentId)) return false;
      gameData.player.talents[talentId] = this.getRank(talentId) + 1;
      const talent = this._findTalent(talentId);
      Notifications.show(`Learned ${talent.name} (Rank ${this.getRank(talentId)})`, 'success');
      Equipment.recalcStats();
      return true;
    },

    getTalentPoints() {
      const spent = Object.values(gameData.player.talents).reduce((a, b) => a + b, 0);
      return Math.floor(gameData.player.level / 2) - spent;
    },

    getBonuses() {
      const b = { meleeDamage: 0, cooldownReduction: 0, critChance: 0, comboDuration: 0, energyCostReduction: 0, maxHpMult: 0, hpRegen: 0, dodgeChance: 0, secondWind: false, immortal: false, goldMult: 0, rareItemChance: 0, craftCostReduction: 0, doubleLoot: false, jackpot: false };
      b.meleeDamage       = this.getRank('c1') * 0.10;
      b.cooldownReduction = this.getRank('c2') * 0.10;
      b.critChance        = this.getRank('c3') * 0.05;
      b.comboDuration     = this.getRank('c4') * 1;
      b.energyCostReduction = this.getRank('c5') > 0 ? 0.20 : 0;
      b.maxHpMult         = this.getRank('s1') * 0.10;
      b.hpRegen           = this.getRank('s2') * 0.15;
      b.dodgeChance       = this.getRank('s3') * 0.05;
      b.secondWind        = this.getRank('s4') > 0;
      b.immortal          = this.getRank('s5') > 0;
      b.goldMult          = this.getRank('f1') * 0.15;
      b.rareItemChance    = this.getRank('f2') * 0.10;
      b.craftCostReduction = this.getRank('f3');
      b.doubleLoot        = this.getRank('f4') > 0;
      b.jackpot           = this.getRank('f5') > 0;
      return b;
    }
  };

  // ===== PHASE 5: QUEST SYSTEM =====
  const Quests = {
    templates: {
      daily: [
        { id: 'kill_10',     name: 'Hunter',       desc: 'Kill 10 enemies',               goal: 10, track: 'kills',      reward: { xp: 50,  gold: 25 } },
        { id: 'kill_elite',  name: 'Elite Hunter',  desc: 'Kill 3 elite enemies',          goal: 3,  track: 'eliteKills', reward: { xp: 100, gold: 50 } },
        { id: 'collect_5',   name: 'Gatherer',      desc: 'Collect 5 materials',           goal: 5,  track: 'materials',  reward: { xp: 30,  gold: 15 } },
        { id: 'explore_pois', name: 'Explorer',     desc: 'Discover 2 points of interest', goal: 2,  track: 'pois',      reward: { xp: 60,  gold: 30 } },
      ],
      weekly: [
        { id: 'kill_100',  name: 'Slayer',      desc: 'Kill 100 enemies',  goal: 100, track: 'kills',     reward: { xp: 300, gold: 150 } },
        { id: 'boss_kill', name: 'Boss Slayer',  desc: 'Defeat a boss',     goal: 1,   track: 'bossKills', reward: { xp: 500, gold: 250 } },
      ],
      story: [
        { id: 'story_1', name: 'First Steps',    desc: 'Visit your first star system', goal: 1,  track: 'planetsVisited', reward: { xp: 100, gold: 50 } },
        { id: 'story_2', name: 'Combat Ready',   desc: 'Reach level 5',                goal: 5,  track: 'level',          reward: { xp: 200, gold: 100 } },
        { id: 'story_3', name: 'Elite Warrior',  desc: 'Reach level 10',               goal: 10, track: 'level',          reward: { xp: 500, gold: 250 } },
      ]
    },

    trackers: { kills: 0, eliteKills: 0, materials: 0, pois: 0, bossKills: 0, planetsVisited: 0, level: 0 },

    generateDaily() {
      const pool = [...this.templates.daily];
      const picked = [];
      for (let i = 0; i < 3 && pool.length > 0; i++) {
        const idx = Math.floor(Math.random() * pool.length);
        const q = { ...pool.splice(idx, 1)[0], progress: 0, type: 'daily' };
        picked.push(q);
      }
      gameData.player.quests.active = gameData.player.quests.active.filter(q => q.type !== 'daily');
      gameData.player.quests.active.push(...picked);
    },

    generateWeekly() {
      const pool = [...this.templates.weekly];
      const idx = Math.floor(Math.random() * pool.length);
      const q = { ...pool[idx], progress: 0, type: 'weekly' };
      gameData.player.quests.active = gameData.player.quests.active.filter(q => q.type !== 'weekly');
      gameData.player.quests.active.push(q);
    },

    initStoryQuests() {
      const completed = gameData.player.quests.completed.map(q => q.id);
      this.templates.story.forEach(sq => {
        if (!completed.includes(sq.id) && !gameData.player.quests.active.find(q => q.id === sq.id)) {
          gameData.player.quests.active.push({ ...sq, progress: 0, type: 'story' });
        }
      });
    },

    track(event, amount) {
      this.trackers[event] = (this.trackers[event] || 0) + amount;
      this.trackers.level = gameData.player.level;
      gameData.player.quests.active.forEach(quest => {
        if (quest.track === event) {
          quest.progress = this.trackers[event];
          if (this.isComplete(quest) && !quest.rewarded) {
            quest.rewarded = true;
            Leveling.addXP(quest.reward.xp);
            gameData.player.gold += quest.reward.gold;
            Notifications.show(`üìú Quest Complete: ${quest.name}! +${quest.reward.xp} XP +${quest.reward.gold} gold`, 'success', 4000);
            A11y.announce(`Quest complete: ${quest.name}`);
            gameData.player.quests.completed.push(quest);
            const idx = gameData.player.quests.active.indexOf(quest);
            if (idx !== -1) gameData.player.quests.active.splice(idx, 1);
          }
        }
      });
    },

    update() {
      this.trackers.level = gameData.player.level;
      gameData.player.quests.active.forEach(quest => {
        if (quest.track === 'level') {
          quest.progress = gameData.player.level;
          if (this.isComplete(quest) && !quest.rewarded) {
            quest.rewarded = true;
            Leveling.addXP(quest.reward.xp);
            gameData.player.gold += quest.reward.gold;
            Notifications.show(`üìú Quest Complete: ${quest.name}!`, 'success', 4000);
            gameData.player.quests.completed.push(quest);
            const idx = gameData.player.quests.active.indexOf(quest);
            if (idx !== -1) gameData.player.quests.active.splice(idx, 1);
          }
        }
      });
    },

    getActive() { return gameData.player.quests.active; },
    isComplete(quest) { return (this.trackers[quest.track] || 0) >= quest.goal; }
  };

  // ===== PHASE 5: ACHIEVEMENT SYSTEM =====
  const Achievements = {
    definitions: [
      { id: 'first_kill',    name: 'First Blood',   desc: 'Kill your first enemy',          check: () => gameData.session.killCount >= 1 },
      { id: 'kill_100',      name: 'Centurion',     desc: 'Kill 100 enemies',               check: () => gameData.session.killCount >= 100 },
      { id: 'level_5',       name: 'Apprentice',    desc: 'Reach level 5',                  check: () => gameData.player.level >= 5 },
      { id: 'level_10',      name: 'Veteran',       desc: 'Reach level 10',                 check: () => gameData.player.level >= 10 },
      { id: 'craft_first',   name: 'Artisan',       desc: 'Craft your first item',          check: () => gameData.player.achievements.includes('craft_first') },
      { id: 'boss_kill',     name: 'Boss Slayer',   desc: 'Defeat a boss',                  check: () => gameData.session.bossKills >= 1 },
      { id: 'combo_10',      name: 'Combo Master',  desc: 'Reach a 10-hit combo',           check: () => false },
      { id: 'survive_death', name: 'Second Wind',   desc: 'Survive with less than 5% HP',   check: () => false },
    ],

    check() {
      this.definitions.forEach(a => {
        if (!gameData.player.achievements.includes(a.id) && a.check()) {
          this.unlock(a.id);
        }
      });
    },

    unlock(id) {
      if (gameData.player.achievements.includes(id)) return;
      gameData.player.achievements.push(id);
      const def = this.definitions.find(d => d.id === id);
      Notifications.show(`üèÜ Achievement: ${def.name}`, 'success', 4000);
      A11y.announce(`Achievement unlocked: ${def.name}`);
    }
  };

  // ===== PHASE 5: PRESTIGE SYSTEM =====
  const Prestige = {
    level: 0,
    bonusMultiplier() { return 1 + this.level * 0.15; },

    canPrestige() { return gameData.player.level >= 20; },

    prestige() {
      if (!this.canPrestige()) return;
      this.level++;
      gameData.player.level = 1;
      gameData.player.xp = 0;
      gameData.player.gold = 0;
      gameData.player.xpToNext = 100;
      gameData.player.hp = 100;
      gameData.player.maxHp = 100;
      gameData.player.energy = 100;
      gameData.player.maxEnergy = 100;
      gameData.player.stats = { strength: 10, defense: 5, speed: 8, luck: 3 };
      gameData.player.talents = {};
      gameData.player.inventory = [];
      gameData.player.equipment = { weapon: null, armor: null, accessory: null, rune: null };
      // Keep achievements and completed quests
      Notifications.show(`‚ú® Prestige ${this.level}! +${this.level * 15}% all bonuses`, 'success', 5000);
      A11y.announce(`Prestige level ${this.level}`);
      Leveling.updateUI();
    }
  };

  // ===== PHASE 5: LOOT SYSTEM =====
  const LootSystem = {
    materials: ['iron', 'wood', 'leather', 'crystal', 'herb', 'gold_dust', 'fire_essence'],

    rollDrop(enemyLevel, isElite, isBoss) {
      const drops = [];
      const matCount = 1 + Math.floor(Math.random() * 3);
      const bonuses = TalentTree.getBonuses();
      for (let i = 0; i < matCount; i++) {
        const qty = (bonuses.jackpot && Math.random() < 0.01) ? 10 : 1;
        drops.push({ type: 'material', name: this.materials[Math.floor(Math.random() * this.materials.length)], quantity: qty });
      }
      let equipChance = isElite ? 0.4 : isBoss ? 0.9 : 0.1;
      equipChance += bonuses.rareItemChance || 0;
      if (Math.random() < equipChance) {
        drops.push({ type: 'equipment', item: Equipment.generate(enemyLevel) });
      }
      return drops;
    },

    awardDrops(drops) {
      drops.forEach(drop => {
        if (drop.type === 'material') {
          gameData.player.inventory.push(drop);
          Quests.track('materials', drop.quantity || 1);
        } else if (drop.type === 'equipment') {
          gameData.player.inventory.push(drop.item);
          const color = Equipment.rarityColors[drop.item.rarity] || '#fff';
          Notifications.show(`üéÅ Loot: ${drop.item.name} (${drop.item.rarity})`, 'info');
        }
      });
    }
  };

  // ===== PHASE 5: LOCAL LEADERBOARD =====
  const Leaderboard = {
    key: 'leviathan-leaderboard',

    getEntries() { return StorageManager.load(this.key) || []; },

    submit(entry) {
      const entries = this.getEntries();
      entries.push(entry);
      entries.sort((a, b) => b.kills - a.kills);
      if (entries.length > 20) entries.length = 20;
      StorageManager.save(this.key, entries);
    },

    submitCurrent() {
      this.submit({
        name: gameData.player.name,
        level: gameData.player.level,
        kills: gameData.session.killCount,
        gold: gameData.player.gold,
        time: Math.floor((Date.now() - gameData.session.startTime) / 1000),
        date: new Date().toISOString()
      });
    }
  };

  // ===== PHASE 6: PET COMPANION SYSTEM ===== //
  const Companion = {
    mesh: null,
    data: null,
    types: {
      fox:     { name: 'Glitch Fox',    color: 0xff8844, ability: 'scavenge', evolveLevel: 3 },
      drone:   { name: 'Scout Drone',   color: 0x44aaff, ability: 'scan',     evolveLevel: 3 },
      golem:   { name: 'Stone Golem',   color: 0x887766, ability: 'tank',     evolveLevel: 4 },
      spirit:  { name: 'Wisp Spirit',   color: 0x88ff88, ability: 'heal',     evolveLevel: 3 },
      phoenix: { name: 'Ember Phoenix', color: 0xff4400, ability: 'fireball', evolveLevel: 5 },
    },

    summon(typeName) {
      const type = this.types[typeName];
      if (!type) return;
      this.data = { name: type.name, type: typeName, level: 1, bond: 0, xp: 0, hp: 50, maxHp: 50, evolved: false };
      gameData.companion = this.data;
      this.createMesh(typeName);
      Notifications.show(`${type.name} joined you!`, 'success');
    },

    createMesh(typeName) {
      const type = this.types[typeName];
      const g = new THREE.Group();
      const bodyGeo = new THREE.SphereGeometry(0.5, 8, 8);
      const bodyMat = new THREE.MeshPhongMaterial({ color: type.color, emissive: type.color, emissiveIntensity: 0.3 });
      g.add(new THREE.Mesh(bodyGeo, bodyMat));
      const glowMat = new THREE.SpriteMaterial({ color: type.color, transparent: true, opacity: 0.3, blending: THREE.AdditiveBlending });
      const glow = new THREE.Sprite(glowMat);
      glow.scale.set(2, 2, 1);
      g.add(glow);
      this.mesh = g;
      if (World.group) World.group.add(g);
    },

    update(delta) {
      if (!this.mesh || !this.data) return;
      const t = clock.getElapsedTime();
      const ox = Math.sin(t * 1.5) * 3;
      const oz = Math.cos(t * 1.5) * 3;
      const targetY = World.playerPos.y + 2 + Math.sin(t * 2) * 0.5;
      this.mesh.position.set(World.playerPos.x + ox, targetY, World.playerPos.z + oz);
      this.data.bond += delta * 0.01;
      if (!this.data.evolved && this.data.bond >= this.types[this.data.type].evolveLevel) {
        this.evolve();
      }
      this.useAbility(delta);
    },

    evolve() {
      this.data.evolved = true;
      this.data.maxHp *= 2;
      this.data.hp = this.data.maxHp;
      this.data.name = 'Evolved ' + this.data.name;
      Notifications.show(`${this.data.name} evolved!`, 'success', 4000);
      if (this.mesh) this.mesh.scale.set(1.5, 1.5, 1.5);
    },

    useAbility(delta) { /* periodic ability based on type */ },

    cleanup() {
      if (this.mesh && World.group) World.group.remove(this.mesh);
      this.mesh = null;
    }
  };

  // ===== PHASE 6: AGENT FLEET SYSTEM ===== //
  const AgentFleet = {
    agents: [],
    maxAgents: 10,

    types: {
      gatherer:    { name: 'Gatherer',    icon: 'üåæ', color: 0x44aa44, action: 'harvest',   tool: 'pickaxe' },
      hunter:      { name: 'Hunter',      icon: '‚öîÔ∏è', color: 0xcc4444, action: 'combat',    tool: 'sword' },
      miner:       { name: 'Miner',       icon: '‚õèÔ∏è', color: 0x8888aa, action: 'mine',      tool: 'drill' },
      healer:      { name: 'Healer',      icon: 'üíö', color: 0x44cc88, action: 'heal',      tool: 'cross' },
      scout:       { name: 'Scout',       icon: 'üî≠', color: 0x4488cc, action: 'explore',   tool: 'antenna' },
      explorer:    { name: 'Explorer',    icon: 'üß≠', color: 0x8844cc, action: 'explore',   tool: 'compass' },
      fisher:      { name: 'Fisher',      icon: 'üé£', color: 0x2288aa, action: 'fish',      tool: 'rod' },
      protector:   { name: 'Protector',   icon: 'üõ°Ô∏è', color: 0xaa8844, action: 'patrol',    tool: 'shield' },
      terraformer: { name: 'Terraformer', icon: 'üöú', color: 0x88aa44, action: 'terraform', tool: 'blade' },
      builder:     { name: 'Builder',     icon: 'üîß', color: 0xaaaa44, action: 'build',     tool: 'wrench' },
    },

    spawn(typeName) {
      if (this.agents.length >= this.maxAgents) {
        Notifications.show('Agent fleet full!', 'warning');
        return null;
      }
      const type = this.types[typeName];
      if (!type) return null;

      const id = 'agent-' + Date.now();
      const pos = World.playerPos.clone().add(new THREE.Vector3((Math.random()-0.5)*10, 0, (Math.random()-0.5)*10));
      pos.y = World.getTerrainHeight(pos.x, pos.z) + 1;

      const agent = {
        id, type: typeName, name: `${type.name}-${this.agents.length+1}`,
        level: 1, xp: 0, hp: 80, maxHp: 80, energy: 100, maxEnergy: 100,
        position: pos, mesh: null, state: 'idle', task: null,
        combo: 0, bestCombo: 0, efficiency: 0.4, totalActions: 0, successCount: 0,
        moveTarget: null, actionTimer: 0, transcripts: []
      };

      agent.mesh = this.createAgentMesh(type);
      agent.mesh.position.copy(pos);
      if (World.group) World.group.add(agent.mesh);

      this.agents.push(agent);
      gameData.agents.push({ id, type: typeName, name: agent.name, level: agent.level });
      Notifications.show(`${type.icon} ${agent.name} deployed!`, 'success');
      this.updatePanel();
      return agent;
    },

    createAgentMesh(type) {
      const g = new THREE.Group();
      const body = new THREE.Mesh(
        new THREE.BoxGeometry(0.6, 0.8, 0.4),
        new THREE.MeshPhongMaterial({ color: type.color, emissive: type.color, emissiveIntensity: 0.15 })
      );
      body.position.y = 1;
      body.castShadow = true;
      g.add(body);
      const head = new THREE.Mesh(
        new THREE.BoxGeometry(0.4, 0.4, 0.4),
        new THREE.MeshPhongMaterial({ color: 0xdddddd })
      );
      head.position.y = 1.7;
      g.add(head);
      const eye = new THREE.Mesh(
        new THREE.BoxGeometry(0.08, 0.06, 0.02),
        new THREE.MeshBasicMaterial({ color: type.color })
      );
      eye.position.set(-0.1, 1.72, 0.21);
      g.add(eye);
      const eye2 = eye.clone();
      eye2.position.x = 0.1;
      g.add(eye2);
      return g;
    },

    update(delta) {
      this.agents.forEach(agent => {
        switch (agent.state) {
          case 'idle': this.findTask(agent); break;
          case 'moving': this.moveToTarget(agent, delta); break;
          case 'working': this.doWork(agent, delta); break;
          case 'returning': this.returnToBase(agent, delta); break;
          case 'combat': this.agentCombat(agent, delta); break;
        }
        agent.hp = Math.min(agent.maxHp, agent.hp + delta * (1 + agent.level * 0.5));
        agent.energy = Math.min(agent.maxEnergy, agent.energy + delta * 2);
        if (agent.mesh) agent.mesh.position.copy(agent.position);
      });
    },

    findTask(agent) {
      const angle = Math.random() * Math.PI * 2;
      const dist = 15 + Math.random() * 25;
      agent.moveTarget = new THREE.Vector3(
        World.playerPos.x + Math.cos(angle) * dist,
        0,
        World.playerPos.z + Math.sin(angle) * dist
      );
      agent.moveTarget.y = World.getTerrainHeight(agent.moveTarget.x, agent.moveTarget.z) + 1;
      agent.state = 'moving';
    },

    moveToTarget(agent, delta) {
      if (!agent.moveTarget) { agent.state = 'idle'; return; }
      const dir = agent.moveTarget.clone().sub(agent.position);
      const dist = dir.length();
      if (dist < 1.5) {
        agent.state = 'working';
        agent.actionTimer = 2 + Math.random() * 3;
        return;
      }
      dir.normalize().multiplyScalar(8 * delta);
      agent.position.add(dir);
      agent.position.y = World.getTerrainHeight(agent.position.x, agent.position.z) + 1;
      if (agent.mesh) agent.mesh.rotation.y = Math.atan2(dir.x, dir.z);
      agent.energy = Math.max(0, agent.energy - delta * 0.5);
    },

    doWork(agent, delta) {
      agent.actionTimer -= delta;
      if (agent.actionTimer <= 0) {
        const successChance = agent.efficiency + agent.level * 0.05;
        const success = Math.random() < successChance;
        agent.totalActions++;
        if (success) {
          agent.successCount++;
          agent.combo++;
          if (agent.combo > agent.bestCombo) agent.bestCombo = agent.combo;
          const xpGain = 5 + agent.combo;
          agent.xp += xpGain;
          if (agent.xp >= agent.level * 50) {
            agent.xp -= agent.level * 50;
            agent.level = Math.min(10, agent.level + 1);
            agent.efficiency = Math.min(0.95, 0.4 + agent.level * 0.06);
            agent.maxHp += 10;
            agent.hp = agent.maxHp;
            Notifications.show(`${agent.name} leveled up to ${agent.level}!`, 'success');
          }
          this.awardTaskReward(agent);
          agent.transcripts.push(`[${new Date().toLocaleTimeString()}] ${AgentFleet.types[agent.type].action} success (combo ${agent.combo}x)`);
        } else {
          agent.combo = 0;
          agent.transcripts.push(`[${new Date().toLocaleTimeString()}] ${AgentFleet.types[agent.type].action} failed`);
        }
        agent.state = 'idle';
      }
    },

    awardTaskReward(agent) {
      switch (agent.type) {
        case 'gatherer': case 'miner':
          const mats = ['iron','wood','crystal','herb'];
          const mat = mats[Math.floor(Math.random()*mats.length)];
          gameData.player.inventory.push({ type:'material', name: mat, quantity: 1 + Math.floor(agent.level/3) });
          break;
        case 'hunter': case 'protector':
          gameData.player.gold += 3 + agent.level;
          gameData.session.killCount++;
          break;
        case 'healer':
          const healAmt = 10 + agent.level * 2;
          gameData.player.hp = Math.min(gameData.player.maxHp, gameData.player.hp + healAmt);
          break;
        case 'fisher':
          gameData.player.inventory.push({ type:'material', name: agent.level >= 5 ? 'golden_fish' : 'fish', quantity: 1 });
          break;
      }
    },

    returnToBase(agent, delta) { agent.state = 'idle'; },
    agentCombat(agent, delta) { agent.state = 'idle'; },

    recall(agentId) {
      const idx = this.agents.findIndex(a => a.id === agentId);
      if (idx < 0) return;
      const agent = this.agents[idx];
      if (agent.mesh && World.group) World.group.remove(agent.mesh);
      this.agents.splice(idx, 1);
      gameData.agents = gameData.agents.filter(a => a.id !== agentId);
      Notifications.show(`${agent.name} recalled (Lvl ${agent.level}, Best combo: ${agent.bestCombo}x)`, 'info');
      this.updatePanel();
    },

    recallAll() {
      [...this.agents].forEach(a => this.recall(a.id));
    },

    updatePanel() {
      const panel = document.getElementById('agent-panel');
      const countEl = document.getElementById('agent-count-display');
      if (panel) panel.style.display = this.agents.length > 0 ? 'block' : 'none';
      if (countEl) countEl.textContent = this.agents.length;
    },

    cleanup() {
      this.agents.forEach(a => { if (a.mesh && World.group) World.group.remove(a.mesh); });
      this.agents = [];
      this.updatePanel();
    }
  };

  // ===== PHASE 6: AGENT SPAWN SHORTCUT ===== //
  const AGENT_KEYMAP = { '1':'gatherer', '2':'hunter', '3':'miner', '4':'healer', '5':'scout', '6':'explorer', '7':'fisher', '8':'protector', '9':'terraformer', '0':'builder' };
  EventBus.on('keydown', (e) => {
    if (mode !== 'world') return;
    const typeName = AGENT_KEYMAP[e.key];
    if (typeName) AgentFleet.spawn(typeName);
  });

  // ===== PHASE 7: CONSTRUCTION SYSTEM ===== //
  const Construction = {
    structures: [],
    selectedBlueprint: 0,
    blueprintKeys: ['battery_charger', 'turret', 'beacon', 'shelter', 'refinery'],
    blueprints: {
      battery_charger: { name: 'Battery Charger', cost: { iron: 5, crystal: 3 }, hp: 100, buildTime: 10 },
      turret: { name: 'Defense Turret', cost: { iron: 8, crystal: 2 }, hp: 150, buildTime: 15 },
      beacon: { name: 'Navigation Beacon', cost: { crystal: 4 }, hp: 50, buildTime: 5 },
      shelter: { name: 'Emergency Shelter', cost: { iron: 6, wood: 4 }, hp: 200, buildTime: 12 },
      refinery: { name: 'Resource Refinery', cost: { iron: 10, crystal: 5 }, hp: 180, buildTime: 20 },
    },

    canBuild(blueprintKey) {
      const bp = this.blueprints[blueprintKey];
      if (!bp) return false;
      for (const [mat, count] of Object.entries(bp.cost)) {
        const have = gameData.player.inventory.filter(i => i.type === 'material' && i.name === mat).reduce((sum, i) => sum + (i.quantity || 1), 0);
        if (have < count) return false;
      }
      return true;
    },

    build(blueprintKey, position) {
      if (!this.canBuild(blueprintKey)) { Notifications.show('Not enough materials!', 'warning'); return; }
      const bp = this.blueprints[blueprintKey];
      for (const [mat, count] of Object.entries(bp.cost)) {
        let remaining = count;
        gameData.player.inventory = gameData.player.inventory.filter(item => {
          if (remaining <= 0) return true;
          if (item.type === 'material' && item.name === mat) { remaining -= (item.quantity || 1); return false; }
          return true;
        });
      }
      const structure = {
        type: blueprintKey, position: position.clone(),
        mesh: this.createStructureMesh(blueprintKey, position),
        hp: bp.hp, maxHp: bp.hp,
        efficiency: this.getTerrainEfficiency(position),
        buildProgress: 0, built: false
      };
      this.structures.push(structure);
      gameData.world.structures.push({ type: blueprintKey, x: position.x, y: position.y, z: position.z });
      if (World.group) World.group.add(structure.mesh);
      Notifications.show(`Building ${bp.name}...`, 'info');
    },

    createStructureMesh(type, pos) {
      const g = new THREE.Group();
      switch (type) {
        case 'battery_charger': {
          const base = new THREE.Mesh(new THREE.CylinderGeometry(1.5, 1.8, 0.3, 8), new THREE.MeshPhongMaterial({ color: 0x445566 }));
          g.add(base);
          const pillar = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.3, 2.5, 6), new THREE.MeshPhongMaterial({ color: 0x667788 }));
          pillar.position.y = 1.4;
          g.add(pillar);
          const ring = new THREE.Mesh(new THREE.TorusGeometry(1, 0.08, 8, 24), new THREE.MeshBasicMaterial({ color: 0x00ffff }));
          ring.position.y = 2.2;
          ring.rotation.x = Math.PI / 2;
          ring.userData.spin = true;
          g.add(ring);
          const light = new THREE.PointLight(0x00ffff, 0.5, 15);
          light.position.y = 3;
          g.add(light);
          break;
        }
        case 'turret': {
          const tBase = new THREE.Mesh(new THREE.CylinderGeometry(0.8, 1, 0.6, 8), new THREE.MeshPhongMaterial({ color: 0x556655 }));
          g.add(tBase);
          const barrel = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.1, 1.5, 6), new THREE.MeshPhongMaterial({ color: 0x888888 }));
          barrel.position.set(0, 0.8, 0.5);
          barrel.rotation.x = -Math.PI / 6;
          g.add(barrel);
          break;
        }
        case 'beacon': {
          const pole = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.15, 4, 6), new THREE.MeshPhongMaterial({ color: 0xccccaa }));
          pole.position.y = 2;
          g.add(pole);
          const beacon = new THREE.Mesh(new THREE.SphereGeometry(0.3, 8, 8), new THREE.MeshBasicMaterial({ color: 0xffbb00 }));
          beacon.position.y = 4.2;
          beacon.userData.pulse = true;
          g.add(beacon);
          const bLight = new THREE.PointLight(0xffbb00, 0.8, 25);
          bLight.position.y = 4.2;
          g.add(bLight);
          break;
        }
        case 'shelter': {
          const walls = new THREE.Mesh(new THREE.BoxGeometry(3, 2, 3), new THREE.MeshPhongMaterial({ color: 0x556677, transparent: true, opacity: 0.85 }));
          walls.position.y = 1;
          g.add(walls);
          const roof = new THREE.Mesh(new THREE.ConeGeometry(2.5, 1.2, 4), new THREE.MeshPhongMaterial({ color: 0x667788 }));
          roof.position.y = 2.6;
          roof.rotation.y = Math.PI / 4;
          g.add(roof);
          break;
        }
        case 'refinery': {
          const rBase = new THREE.Mesh(new THREE.BoxGeometry(2.5, 1, 2.5), new THREE.MeshPhongMaterial({ color: 0x445544 }));
          rBase.position.y = 0.5;
          g.add(rBase);
          const chimney = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.4, 2, 6), new THREE.MeshPhongMaterial({ color: 0x555555 }));
          chimney.position.set(0.5, 2, 0.5);
          g.add(chimney);
          break;
        }
      }
      g.position.copy(pos);
      return g;
    },

    getTerrainEfficiency(pos) {
      let variance = 0;
      const heights = [];
      for (let dx = -2; dx <= 2; dx += 2) {
        for (let dz = -2; dz <= 2; dz += 2) {
          heights.push(World.getTerrainHeight(pos.x + dx, pos.z + dz));
        }
      }
      const avg = heights.reduce((a,b)=>a+b,0) / heights.length;
      variance = heights.reduce((s,h) => s + Math.abs(h-avg), 0) / heights.length;
      const isTerraformed = gameData.world.terraformedAreas.some(a =>
        Math.abs(a.x - pos.x) < 5 && Math.abs(a.z - pos.z) < 5);
      return isTerraformed ? 1.0 : Math.max(0.4, 1 - variance * 0.1);
    },

    update(delta) {
      this.structures.forEach(s => {
        if (!s.built) {
          s.buildProgress += delta / this.blueprints[s.type].buildTime;
          if (s.buildProgress >= 1) {
            s.built = true;
            Notifications.show(`${this.blueprints[s.type].name} complete!`, 'success');
          }
          if (s.mesh) s.mesh.scale.setScalar(Math.min(1, s.buildProgress));
          return;
        }
        if (s.mesh) {
          s.mesh.children.forEach(c => {
            if (c.userData.spin) c.rotation.z += delta * 2;
            if (c.userData.pulse) {
              const t = clock.getElapsedTime();
              c.scale.setScalar(1 + Math.sin(t * 3) * 0.2);
            }
          });
        }
        if (s.built && s.type === 'battery_charger') {
          const dist = World.playerPos.distanceTo(s.position);
          if (dist < 8) gameData.player.energy = Math.min(gameData.player.maxEnergy, gameData.player.energy + delta * 10 * s.efficiency);
        }
        if (s.built && s.type === 'shelter') {
          const dist = World.playerPos.distanceTo(s.position);
          if (dist < 5) gameData.player.hp = Math.min(gameData.player.maxHp, gameData.player.hp + delta * 3);
        }
      });
    },

    cleanup() {
      this.structures.forEach(s => { if (s.mesh && World.group) World.group.remove(s.mesh); });
      this.structures = [];
    }
  };

  // ===== PHASE 7: TERRAFORMING SYSTEM ===== //
  const Terraforming = {
    areas: [],

    terraform(x, z, radius = 5) {
      gameData.world.terraformedAreas.push({ x, z, radius });
      this.areas.push({ x, z, radius });
      if (World.terrainMesh) {
        const verts = World.terrainMesh.geometry.attributes.position;
        const avgHeight = World.getTerrainHeight(x, z);
        for (let i = 0; i < verts.count; i++) {
          const vx = verts.getX(i), vz = verts.getZ(i);
          const dist = Math.sqrt((vx-x)**2 + (vz-z)**2);
          if (dist < radius) {
            const blend = 1 - dist / radius;
            const currentY = verts.getY(i);
            verts.setY(i, currentY + (avgHeight - currentY) * blend * 0.5);
          }
        }
        verts.needsUpdate = true;
        World.terrainMesh.geometry.computeVertexNormals();
      }
      Notifications.show('Area terraformed!', 'success');
    }
  };

  // ===== PHASE 7: POI SYSTEM ===== //
  const POISystem = {
    pois: [],
    types: {
      ruins:    { name: 'Ancient Ruins', icon: 'üèõÔ∏è', color: 0xaa8844, reward: { xp: 50, gold: 30 } },
      cave:     { name: 'Crystal Cave', icon: 'üíé', color: 0x4488cc, reward: { xp: 40, materials: ['crystal','crystal'] } },
      shrine:   { name: 'Healing Shrine', icon: '‚õ©Ô∏è', color: 0x44cc88, reward: { heal: true } },
      wreckage: { name: 'Ship Wreckage', icon: 'üöÄ', color: 0x888888, reward: { xp: 60, equipment: true } },
      garden:   { name: 'Lost Garden', icon: 'üåø', color: 0x44aa44, reward: { materials: ['herb','herb','herb'] } },
    },

    generate() {
      this.pois = [];
      const count = 8 + Math.floor(Math.random() * 6);
      const types = Object.keys(this.types);
      for (let i = 0; i < count; i++) {
        const x = (Math.random() - 0.5) * World.terrainSize * 0.8;
        const z = (Math.random() - 0.5) * World.terrainSize * 0.8;
        const h = World.getTerrainHeight(x, z);
        if (h < 0) continue;
        const type = types[Math.floor(Math.random() * types.length)];
        const poi = { type, position: new THREE.Vector3(x, h+1, z), discovered: false, collected: false, mesh: null };
        poi.mesh = this.createPOIMesh(type, poi.position);
        if (World.group) World.group.add(poi.mesh);
        this.pois.push(poi);
      }
    },

    createPOIMesh(type, pos) {
      const data = this.types[type];
      const g = new THREE.Group();
      const marker = new THREE.Mesh(
        new THREE.OctahedronGeometry(0.6, 0),
        new THREE.MeshBasicMaterial({ color: data.color, transparent: true, opacity: 0.8 })
      );
      marker.position.y = 2;
      g.add(marker);
      const glow = new THREE.Sprite(new THREE.SpriteMaterial({ color: data.color, transparent: true, opacity: 0.3, blending: THREE.AdditiveBlending }));
      glow.scale.set(3, 3, 1);
      glow.position.y = 2;
      g.add(glow);
      g.position.copy(pos);
      return g;
    },

    update(delta) {
      const t = clock.getElapsedTime();
      this.pois.forEach(poi => {
        if (poi.collected || !poi.mesh) return;
        poi.mesh.children[0].rotation.y += delta * 2;
        poi.mesh.children[0].position.y = 2 + Math.sin(t * 2) * 0.3;
        const dist = World.playerPos.distanceTo(poi.position);
        if (dist < 5 && !poi.discovered) {
          poi.discovered = true;
          gameData.world.discoveredPOIs.push(poi.type);
          Notifications.show(`Discovered: ${this.types[poi.type].icon} ${this.types[poi.type].name}`, 'info');
          Quests.track('pois', 1);
        }
        if (dist < 2 && !poi.collected) {
          poi.collected = true;
          this.collectReward(poi);
          if (World.group) World.group.remove(poi.mesh);
        }
      });
    },

    collectReward(poi) {
      const reward = this.types[poi.type].reward;
      if (reward.xp) Leveling.addXP(reward.xp);
      if (reward.gold) gameData.player.gold += reward.gold;
      if (reward.heal) { gameData.player.hp = gameData.player.maxHp; gameData.player.energy = gameData.player.maxEnergy; }
      if (reward.materials) reward.materials.forEach(m => gameData.player.inventory.push({ type:'material', name: m, quantity: 1 }));
      if (reward.equipment) {
        const item = Equipment.generate(gameData.player.level);
        gameData.player.inventory.push(item);
        Notifications.show(`Found: ${item.name}!`, 'success');
      }
      Notifications.show(`${this.types[poi.type].icon} Reward collected!`, 'success');
    },

    cleanup() {
      this.pois.forEach(p => { if (p.mesh && World.group) World.group.remove(p.mesh); });
      this.pois = [];
    }
  };

  // ===== PHASE 7: BUILD SHORTCUT ===== //
  EventBus.on('keydown', (e) => {
    if (mode !== 'world') return;
    if (e.key === 'b' || e.key === 'B') {
      const key = Construction.blueprintKeys[Construction.selectedBlueprint];
      Construction.build(key, World.playerPos.clone());
    }
    if (e.key === 'Tab') {
      e.preventDefault();
      Construction.selectedBlueprint = (Construction.selectedBlueprint + 1) % Construction.blueprintKeys.length;
      const key = Construction.blueprintKeys[Construction.selectedBlueprint];
      Notifications.show(`Blueprint: ${Construction.blueprints[key].name}`, 'info');
    }
  });

  // ===== PHASE 8: SOCIAL & MULTIPLAYER ===== //

  // --- P2P Spectator Streaming ---
  const SpectatorSystem = {
    peer: null,
    peerId: null,
    connections: [],
    isHost: false,
    isSpectator: false,
    spectatorPeer: null,
    streamInterval: null,

    initHost() {
      this.peer = new Peer();
      this.peer.on('open', id => {
        this.peerId = id;
        this.isHost = true;
        Logger.debug('P2P', 'Host ready with ID:', id);
        Notifications.show('üì° Spectator hosting active', 'success');
      });
      this.peer.on('connection', conn => {
        this.connections.push(conn);
        conn.on('open', () => {
          Notifications.show('üëÅÔ∏è Spectator connected!', 'info');
          Logger.debug('P2P', 'Spectator connected');
        });
        conn.on('close', () => {
          this.connections = this.connections.filter(c => c !== conn);
          Logger.debug('P2P', 'Spectator disconnected');
        });
      });
      this.peer.on('error', err => Logger.warn('P2P', 'Peer error:', err.type));

      // Start broadcasting at 10 FPS
      this.streamInterval = setInterval(() => this.broadcast(), 100);
    },

    broadcast() {
      if (this.connections.length === 0) return;
      const state = {
        player: {
          position: { x: World.playerPos.x, y: World.playerPos.y, z: World.playerPos.z },
          rotation: World.playerRot,
          hp: gameData.player.hp, maxHp: gameData.player.maxHp,
          energy: gameData.player.energy, maxEnergy: gameData.player.maxEnergy,
          level: gameData.player.level,
        },
        camera: {
          position: { x: camera.position.x, y: camera.position.y, z: camera.position.z },
          rotation: { x: camera.rotation.x, y: camera.rotation.y, z: camera.rotation.z },
        },
        mode,
        agents: AgentFleet.agents.length,
        enemies: typeof Enemies !== 'undefined' ? Enemies.list.length : 0,
        structures: Construction.structures.length,
        weather: Weather.current,
        timestamp: Date.now()
      };
      this.connections.forEach(conn => {
        try { conn.send(JSON.stringify(state)); } catch(e) {}
      });
    },

    joinAsSpectator(hostId) {
      this.spectatorPeer = new Peer();
      this.spectatorPeer.on('open', () => {
        const conn = this.spectatorPeer.connect(hostId);
        conn.on('open', () => {
          this.isSpectator = true;
          const banner = document.getElementById('spectator-banner');
          if (banner) banner.style.display = '';
          Notifications.show('üëÅÔ∏è Connected as spectator!', 'success');
          conn.on('data', data => {
            try {
              const state = JSON.parse(data);
              this.applySpectatorState(state);
            } catch(e) {}
          });
        });
        conn.on('close', () => {
          this.isSpectator = false;
          const banner = document.getElementById('spectator-banner');
          if (banner) banner.style.display = 'none';
          Notifications.show('Spectator connection lost', 'warning');
        });
      });
    },

    applySpectatorState(state) {
      if (state.camera) {
        camera.position.lerp(new THREE.Vector3(state.camera.position.x, state.camera.position.y, state.camera.position.z), 0.3);
      }
    },

    getShareURL() {
      if (!this.peerId) return null;
      const base = window.location.href.split('?')[0];
      return `${base}?spectate=${this.peerId}`;
    },

    stop() {
      if (this.streamInterval) clearInterval(this.streamInterval);
      if (this.peer) this.peer.destroy();
      if (this.spectatorPeer) this.spectatorPeer.destroy();
      this.connections = [];
      this.isHost = false;
      this.isSpectator = false;
      const banner = document.getElementById('spectator-banner');
      if (banner) banner.style.display = 'none';
    }
  };

  // --- QR Code Show Mode ---
  const ShowMode = {
    active: false,

    open() {
      if (!SpectatorSystem.peerId) {
        SpectatorSystem.initHost();
        setTimeout(() => this.show(), 1500);
        return;
      }
      this.show();
    },

    show() {
      const url = SpectatorSystem.getShareURL();
      if (!url) { Notifications.show('P2P not ready', 'warning'); return; }
      this.active = true;

      const modal = document.getElementById('show-mode-modal');
      if (modal) {
        document.getElementById('show-mode-url').textContent = url;
        this.generateQR(url);
        modal.style.display = 'flex';
      }
    },

    generateQR(text) {
      const canvas = document.getElementById('qr-canvas');
      if (!canvas) return;
      const ctx = canvas.getContext('2d');
      const size = 200;
      canvas.width = size;
      canvas.height = size;
      ctx.fillStyle = '#fff';
      ctx.fillRect(0, 0, size, size);
      ctx.fillStyle = '#000';
      const cellSize = 8;
      const cells = Math.floor(size / cellSize);
      for (let y = 0; y < cells; y++) {
        for (let x = 0; x < cells; x++) {
          const hash = Math.sin(x * 12.9898 + y * 78.233 + text.length * 43758.5453);
          if ((hash - Math.floor(hash)) > 0.5) {
            ctx.fillRect(x * cellSize, y * cellSize, cellSize, cellSize);
          }
        }
      }
      this.drawFinderPattern(ctx, 0, 0, cellSize);
      this.drawFinderPattern(ctx, size - 7*cellSize, 0, cellSize);
      this.drawFinderPattern(ctx, 0, size - 7*cellSize, cellSize);
    },

    drawFinderPattern(ctx, x, y, cell) {
      ctx.fillStyle = '#000';
      ctx.fillRect(x, y, 7*cell, 7*cell);
      ctx.fillStyle = '#fff';
      ctx.fillRect(x+cell, y+cell, 5*cell, 5*cell);
      ctx.fillStyle = '#000';
      ctx.fillRect(x+2*cell, y+2*cell, 3*cell, 3*cell);
    },

    close() {
      this.active = false;
      const modal = document.getElementById('show-mode-modal');
      if (modal) modal.style.display = 'none';
    },

    copyURL() {
      const url = SpectatorSystem.getShareURL();
      if (url) {
        navigator.clipboard.writeText(url).then(() => Notifications.show('URL copied!', 'success'));
      }
    }
  };

  // --- Ship Landing Mini-Game ---
  const LandingGame = {
    active: false,
    shipY: 100,
    shipVelocity: 0,
    thrust: 0,
    fuel: 100,
    targetY: 0,
    success: false,

    start() {
      this.active = true;
      this.shipY = 100;
      this.shipVelocity = 0;
      this.thrust = 0;
      this.fuel = 100;
      this.success = false;
      setMode('landing');
      Notifications.show('üöÄ Landing sequence! Hold SPACE for thrust', 'warning', 4000);
    },

    update(delta) {
      if (!this.active) return;
      // Gravity
      this.shipVelocity += 9.8 * delta;
      // Thrust (Space key)
      if (Input.isKeyDown(' ') && this.fuel > 0) {
        this.thrust = -20;
        this.fuel -= delta * 20;
      } else {
        this.thrust = 0;
      }
      this.shipVelocity += this.thrust * delta;
      this.shipY -= this.shipVelocity * delta;

      // Landing check
      if (this.shipY <= this.targetY + 1) {
        if (Math.abs(this.shipVelocity) < 5) {
          this.success = true;
          Notifications.show('üéâ Perfect landing!', 'success', 3000);
          Leveling.addXP(50);
        } else {
          Notifications.show('üí• Crash landing! Ship damaged.', 'warning', 3000);
          gameData.player.hp = Math.max(1, gameData.player.hp - 30);
        }
        this.active = false;
        setTimeout(() => {
          setMode('world');
          World.generate();
        }, 1500);
      }

      // Update camera to show landing view
      camera.position.set(10, this.shipY + 5, 20);
      camera.lookAt(0, this.shipY, 0);
    },

    draw() {
      // Landing UI overlay (placeholder for future rendering)
    }
  };

  // --- Auto-detect Spectator Mode from URL ---
  function checkSpectatorMode() {
    const params = new URLSearchParams(window.location.search);
    const spectateId = params.get('spectate');
    if (spectateId) {
      Notifications.show('Joining as spectator...', 'info');
      SpectatorSystem.joinAsSpectator(spectateId);
    }
  }

  // ===== PHASE 8: KEYBOARD SHORTCUTS ===== //
  EventBus.on('keydown', (e) => {
    if (mode !== 'world') return;
    if (e.key === 'p' || e.key === 'P') {
      ShowMode.open();
    }
    if (e.key === 'l' || e.key === 'L') {
      LandingGame.start();
    }
  });

  // ===== PHASE 9: UI, ACCESSIBILITY & POLISH ===== //

  // --- Biophone Boot Sequence ---
  const Biophone = {
    active: false,
    narrative: [
      "INITIALIZING NEURAL BRIDGE...",
      "SOMA INDUSTRIES ‚Ä¢ Mk.VII BIOPHONE",
      "Consciousness transfer protocol engaged.",
      "Scanning compatible robotic chassis...",
      "Target: Explorer Unit LEVI-07",
      "Warning: Remote location detected.",
      "Biosphere analysis: Unknown planet cluster.",
      "Mission: Explore. Survive. Build.",
      "TRANSFER READY."
    ],
    currentLine: 0,
    timer: 0,

    start() {
      this.active = true;
      const el = document.getElementById('biophone-boot');
      if (el) el.style.display = 'flex';
      this.showNextLine();
    },

    showNextLine() {
      if (this.currentLine >= this.narrative.length) {
        this.showTransferButton();
        return;
      }
      const textEl = document.getElementById('biophone-narrative');
      if (textEl) {
        textEl.textContent = this.narrative[this.currentLine];
        A11y.announce(this.narrative[this.currentLine]);
      }
      const progressEl = document.getElementById('biophone-progress');
      if (progressEl) progressEl.style.width = ((this.currentLine + 1) / this.narrative.length * 100) + '%';
      this.currentLine++;
      setTimeout(() => this.showNextLine(), 1500);
    },

    showTransferButton() {
      const btn = document.getElementById('transfer-btn');
      if (btn) btn.style.display = 'block';
    },

    skip() {
      this.finish();
    },

    finish() {
      this.active = false;
      const el = document.getElementById('biophone-boot');
      if (el) { el.style.opacity = '0'; setTimeout(() => el.style.display = 'none', 500); }
      // Now start the actual game
      EventBus.emit('gameStart');
    }
  };

  // --- Reality Glitch Engine ---
  const RealityGlitch = {
    overlay: null,
    active: false,

    init() {
      this.overlay = document.getElementById('reality-glitch-overlay');
    },

    trigger(type = 'scan', duration = 1000) {
      if (!this.overlay) return;
      this.overlay.className = 'reality-glitch-overlay glitch-' + type;
      this.overlay.style.display = 'block';
      setTimeout(() => { this.overlay.style.display = 'none'; }, duration);
    },

    types: {
      scan: 'Horizontal scan lines sweep across screen',
      chromatic: 'RGB channel offset for brief moment',
      static: 'Brief burst of TV static',
      tear: 'Vertical tear/displacement effect',
      flash: 'Quick white flash (cryogenics)',
    }
  };

  // --- Settings Modal ---
  const SettingsModal = {
    open() {
      const modal = document.getElementById('settings-modal');
      if (modal) modal.style.display = 'flex';
      A11y.focusTrap(modal);
      this.populateValues();
    },
    close() {
      const modal = document.getElementById('settings-modal');
      if (modal) modal.style.display = 'none';
      A11y.releaseTrap();
    },
    populateValues() {
      const s = gameData.settings;
      this.setChecked('setting-fps', s.showFPS);
      this.setChecked('setting-lowpower', s.lowPowerMode);
      this.setChecked('setting-screereader', s.screenReaderMode);
      this.setChecked('setting-highcontrast', s.highContrast);
    },
    setChecked(id, val) { const el = document.getElementById(id); if (el) el.checked = val; },
    save() {
      gameData.settings.showFPS = document.getElementById('setting-fps')?.checked ?? true;
      gameData.settings.lowPowerMode = document.getElementById('setting-lowpower')?.checked ?? false;
      gameData.settings.screenReaderMode = document.getElementById('setting-screereader')?.checked ?? false;
      gameData.settings.highContrast = document.getElementById('setting-highcontrast')?.checked ?? false;
      // Apply body classes
      document.body.classList.toggle('high-contrast', gameData.settings.highContrast);
      document.body.classList.toggle('low-power', gameData.settings.lowPowerMode);
      StorageManager.save('gameData', gameData);
      Notifications.show('Settings saved', 'success');
      this.close();
    }
  };

  // --- Stats Modal ---
  const StatsModal = {
    open() {
      const modal = document.getElementById('stats-modal');
      if (!modal) return;
      modal.style.display = 'flex';
      this.populate();
      A11y.focusTrap(modal);
    },
    close() {
      const modal = document.getElementById('stats-modal');
      if (modal) modal.style.display = 'none';
      A11y.releaseTrap();
    },
    populate() {
      const el = document.getElementById('stats-content');
      if (!el) return;
      const p = gameData.player;
      const s = gameData.session;
      const playTime = Math.floor(s.totalPlayTime / 60);
      el.innerHTML = `
        <div class="stat-line"><span>Level</span><span>${p.level}</span></div>
        <div class="stat-line"><span>XP</span><span>${p.xp} / ${p.xpToNext}</span></div>
        <div class="stat-line"><span>Gold</span><span>${p.gold}</span></div>
        <div class="stat-line"><span>Kills</span><span>${s.killCount}</span></div>
        <div class="stat-line"><span>Deaths</span><span>${s.deaths}</span></div>
        <div class="stat-line"><span>Play Time</span><span>${playTime} min</span></div>
        <div class="stat-line"><span>Achievements</span><span>${p.achievements.length}</span></div>
        <div class="stat-line"><span>Quests Done</span><span>${p.quests.completed.length}</span></div>
        <div class="stat-line"><span>Agents Deployed</span><span>${AgentFleet.agents.length}</span></div>
        <div class="stat-line"><span>Structures Built</span><span>${Construction.structures.length}</span></div>
      `;
    }
  };

  // --- Inventory/Equipment Modal ---
  const InventoryModal = {
    open() {
      const modal = document.getElementById('inventory-modal');
      if (!modal) return;
      modal.style.display = 'flex';
      this.populate();
      A11y.focusTrap(modal);
    },
    close() {
      const modal = document.getElementById('inventory-modal');
      if (modal) modal.style.display = 'none';
      A11y.releaseTrap();
    },
    populate() {
      const el = document.getElementById('inventory-content');
      if (!el) return;
      const equip = gameData.player.equipment;
      const inv = gameData.player.inventory;

      let html = '<h3 style="color:#0ff;font-size:14px;margin-bottom:8px">Equipment</h3>';
      ['weapon','armor','accessory','rune'].forEach(slot => {
        const item = equip[slot];
        html += `<div class="inv-slot"><span class="inv-slot-name">${slot}</span>`;
        html += item ? `<span style="color:${Equipment.rarityColors[item.rarity]||'#aaa'}">${item.name}</span>` : '<span style="color:#555">Empty</span>';
        html += '</div>';
      });

      html += '<h3 style="color:#fb0;font-size:14px;margin:12px 0 8px">Inventory</h3>';
      const mats = {};
      inv.filter(i => i.type === 'material').forEach(i => { mats[i.name] = (mats[i.name]||0) + (i.quantity||1); });
      Object.entries(mats).forEach(([name, count]) => {
        html += `<div class="inv-item">${name}: ${count}</div>`;
      });
      inv.filter(i => i.type !== 'material' && i.name).forEach((item, idx) => {
        html += `<div class="inv-item" style="color:${Equipment.rarityColors[item.rarity]||'#aaa'};cursor:pointer" onclick="Equipment.equip(gameData.player.inventory[${inv.indexOf(item)}]);InventoryModal.populate()">${item.name} (${item.slot})</div>`;
      });

      if (Object.keys(mats).length === 0 && inv.filter(i => i.name).length === 0) html += '<div style="color:#555;font-size:12px">Empty</div>';
      el.innerHTML = html;
    }
  };

  // --- Help Overlay ---
  const HelpOverlay = {
    visible: false,
    toggle() {
      this.visible = !this.visible;
      const el = document.getElementById('help-overlay');
      if (el) el.style.display = this.visible ? 'flex' : 'none';
    }
  };

  // --- Performance Telemetry Overlay ---
  const PerfOverlay = {
    visible: false,
    toggle() {
      this.visible = !this.visible;
      const el = document.getElementById('perf-overlay');
      if (el) el.style.display = this.visible ? 'block' : 'none';
    },
    update() {
      if (!this.visible) return;
      const el = document.getElementById('perf-content');
      if (!el) return;
      const mem = performance.memory ? `${(performance.memory.usedJSHeapSize/1048576).toFixed(1)}MB` : 'N/A';
      el.textContent = `FPS: ${fps} | Entities: ${Enemies.list.length} | Agents: ${AgentFleet.agents.length} | Structs: ${Construction.structures.length} | Mem: ${mem}`;
    }
  };

  // --- Phase 9: Keyboard Bindings for Modals ---
  EventBus.on('keydown', (e) => {
    // Skip if typing in an input element
    if (e.target && (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.isContentEditable)) return;
    // Biophone: Space to skip
    if (Biophone.active && e.key === ' ') { e.preventDefault(); Biophone.skip(); return; }

    const key = e.key;
    // Escape: close any open modal first, then leave world
    if (key === 'Escape') {
      const modals = ['settings-modal','stats-modal','inventory-modal','help-overlay'];
      let closed = false;
      modals.forEach(id => {
        const m = document.getElementById(id);
        if (m && m.style.display !== 'none') { m.style.display = 'none'; closed = true; }
      });
      if (closed) { A11y.releaseTrap(); return; }
      // fall through to default Escape behavior
    }
    if (key === 'i' || key === 'I') {
      const m = document.getElementById('inventory-modal');
      if (m && m.style.display !== 'none') InventoryModal.close(); else InventoryModal.open();
    }
    if (key === 'm' || key === 'M') {
      const m = document.getElementById('stats-modal');
      if (m && m.style.display !== 'none') StatsModal.close(); else StatsModal.open();
    }
    if (key === ',') {
      const m = document.getElementById('settings-modal');
      if (m && m.style.display !== 'none') SettingsModal.close(); else SettingsModal.open();
    }
    if (key === '?' || key === 'h' || key === 'H') {
      HelpOverlay.toggle();
    }
    if (key === '`') {
      PerfOverlay.toggle();
    }
  });

  // ===== 15. GAME LOOP =====
  let fps = 0, frameCount = 0, lastFpsTime = 0;

  function gameLoop() {
    requestAnimationFrame(gameLoop);

    const delta = clock.getDelta();
    const elapsed = clock.getElapsedTime();

    // FPS counter
    frameCount++;
    if (elapsed - lastFpsTime >= 1) {
      fps = frameCount;
      frameCount = 0;
      lastFpsTime = elapsed;
      updateFPSDisplay(fps);
    }

    // Low power mode: skip alternate frames
    if (gameData.settings.lowPowerMode && frameCount % 2 !== 0) return;

    // Update game state based on mode
    switch (mode) {
      case 'galaxy': updateGalaxy(delta); break;
      case 'world': updateWorld(delta); break;
      case 'landing': LandingGame.update(delta); break;
      // Other modes handled in later phases
    }

    // Update HUD (throttled to ~10 Hz)
    if (frameCount % 6 === 0) updateHUD();

    // Phase 5: Achievement & quest checks (every ~1s)
    if (frameCount % 60 === 0) {
      Achievements.check();
      Quests.update();
    }

    // Phase 9: Performance telemetry (throttled to ~2 Hz)
    if (frameCount % 30 === 0) PerfOverlay.update();

    // Phase 9: Gamepad UI navigation
    if (Input.gamepadConnected) {
      const gp = Input.pollGamepad();
      if (gp && gp.buttons[9]) HelpOverlay.toggle(); // Start button
      if (gp && gp.buttons[8]) SettingsModal.open(); // Select button
    }

    // Render
    renderer.render(scene, camera);
  }

  // ===== 16. RESIZE HANDLER =====
  function onResize() {
    if (!camera || !renderer) return;
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  }

  // ===== 17. INITIALIZATION =====
  function init() {
    const end = Logger.perf('init');

    // Load saved data
    const saved = StorageManager.load('gameData');
    if (saved) {
      try {
        // Deep merge to preserve defaults for new fields
        function deepMerge(target, source) {
          for (const key of Object.keys(source)) {
            if (source[key] && typeof source[key] === 'object' && !Array.isArray(source[key]) && target[key] && typeof target[key] === 'object') {
              deepMerge(target[key], source[key]);
            } else {
              target[key] = source[key];
            }
          }
        }
        deepMerge(gameData, saved);
        Logger.debug('INIT', 'Loaded saved game data');
      } catch (e) {
        Logger.warn('INIT', 'Failed to merge saved data, using defaults');
      }
    }

    // Ensure current session
    gameData.session.startTime = Date.now();
    gameData.meta.version = VERSION;

    // Initialize systems
    initThreeJS();
    Input.init();
    Combat.init();
    Galaxy.generate();
    checkSpectatorMode();

    // Phase 9: Initialize UI & polish systems
    RealityGlitch.init();
    if (gameData.settings.highContrast) document.body.classList.add('high-contrast');
    if (gameData.settings.lowPowerMode) document.body.classList.add('low-power');

    // Phase 5: Initialize progression systems
    Quests.generateDaily();
    Quests.generateWeekly();
    Quests.initStoryQuests();
    Leveling.updateUI();

    // Set initial mode from saved state or default
    if (VALID_MODES.includes(gameData.meta.lastMode)) {
      setMode(gameData.meta.lastMode);
    }

    // Fade out loading screen
    const loadingScreen = document.getElementById('loading-screen');
    if (loadingScreen) {
      loadingScreen.classList.add('fade-out');
      setTimeout(() => { loadingScreen.style.display = 'none'; }, 500);
    }

    // Phase 9: Biophone boot for first-time play
    if (!saved) {
      setTimeout(() => Biophone.start(), 600);
    }

    // Auto-save every 30 seconds
    setInterval(() => {
      gameData.meta.lastSave = new Date().toISOString();
      gameData.session.totalPlayTime += 30;
      StorageManager.save('gameData', gameData);
      Logger.debug('SAVE', 'Auto-saved');
    }, 30000);

    // Start game loop
    gameLoop();

    // Welcome notification
    Notifications.show('LEVIATHAN: OMNIVERSE v' + VERSION, 'info', 3000);
    setTimeout(() => Notifications.show('Click a star to select ¬∑ Double-click to visit', 'success', 4000), 800);

    end();
    console.log(`‚ö° LEVIATHAN: OMNIVERSE v${VERSION} initialized`);
  }

  document.addEventListener('DOMContentLoaded', init);
  </script>

  <!-- Phase 8: Show Mode Modal -->
  <div id="show-mode-modal" class="modal-overlay" style="display:none">
    <div class="modal-content show-mode-content">
      <button class="modal-close" onclick="ShowMode.close()" aria-label="Close">&times;</button>
      <h2 class="show-mode-title">üì° SHOW MODE</h2>
      <p class="show-mode-subtitle">Scan to spectate your game live</p>
      <canvas id="qr-canvas" width="200" height="200" style="background:#fff;border-radius:8px;margin:16px auto;display:block"></canvas>
      <div id="show-mode-url" class="show-mode-url"></div>
      <button class="btn-primary" onclick="ShowMode.copyURL()">COPY URL</button>
    </div>
  </div>

  <!-- Phase 8: Spectator Banner -->
  <div id="spectator-banner" class="spectator-banner" style="display:none">
    üëÅÔ∏è SPECTATOR MODE <button onclick="SpectatorSystem.stop()" class="btn-sm" style="margin-left:12px">EXIT</button>
  </div>

  <!-- Phase 9: Reality Glitch Overlay -->
  <div id="reality-glitch-overlay" class="reality-glitch-overlay" style="display:none" aria-hidden="true"></div>

  <!-- Phase 9: Performance Telemetry Overlay -->
  <div id="perf-overlay" style="display:none;position:fixed;top:40px;left:50%;transform:translateX(-50%);background:rgba(0,0,0,0.8);color:#0f0;font-family:monospace;font-size:11px;padding:4px 12px;border-radius:4px;z-index:9500;pointer-events:none">
    <span id="perf-content"></span>
  </div>

  <!-- Phase 9: Settings Modal -->
  <div id="settings-modal" class="modal-overlay" style="display:none" role="dialog" aria-label="Settings">
    <div class="modal-content" style="max-width:350px">
      <button class="modal-close" onclick="SettingsModal.close()">&times;</button>
      <h2 style="margin-bottom:16px;color:#0ff">‚öôÔ∏è Settings</h2>
      <label class="setting-row"><input type="checkbox" id="setting-fps" checked> Show FPS Counter</label>
      <label class="setting-row"><input type="checkbox" id="setting-lowpower"> Low Power Mode</label>
      <label class="setting-row"><input type="checkbox" id="setting-screereader"> Screen Reader Mode</label>
      <label class="setting-row"><input type="checkbox" id="setting-highcontrast"> High Contrast</label>
      <div style="margin-top:16px;display:flex;gap:8px">
        <button class="btn-primary" onclick="SettingsModal.save()">Save</button>
        <button class="btn-secondary" onclick="StorageManager.exportAll()">Export Data</button>
      </div>
    </div>
  </div>

  <!-- Phase 9: Stats Modal -->
  <div id="stats-modal" class="modal-overlay" style="display:none" role="dialog" aria-label="Statistics">
    <div class="modal-content" style="max-width:350px">
      <button class="modal-close" onclick="StatsModal.close()">&times;</button>
      <h2 style="margin-bottom:16px;color:#fb0">üìä Statistics</h2>
      <div id="stats-content"></div>
    </div>
  </div>

  <!-- Phase 9: Inventory Modal -->
  <div id="inventory-modal" class="modal-overlay" style="display:none" role="dialog" aria-label="Inventory">
    <div class="modal-content" style="max-width:350px">
      <button class="modal-close" onclick="InventoryModal.close()">&times;</button>
      <h2 style="margin-bottom:16px;color:#0f8">üéí Inventory</h2>
      <div id="inventory-content"></div>
    </div>
  </div>

  <!-- Phase 9: Help Overlay -->
  <div id="help-overlay" class="modal-overlay" style="display:none" role="dialog" aria-label="Keyboard Controls">
    <div class="modal-content" style="max-width:400px;text-align:left">
      <button class="modal-close" onclick="HelpOverlay.toggle()">&times;</button>
      <h2 style="margin-bottom:12px;color:#fb0">‚å®Ô∏è Controls</h2>
      <div class="help-grid">
        <div class="help-key">WASD / Arrows</div><div>Move</div>
        <div class="help-key">Space</div><div>Dodge</div>
        <div class="help-key">Shift</div><div>Parry</div>
        <div class="help-key">Q E R T F Z X C</div><div>Abilities</div>
        <div class="help-key">1-0</div><div>Spawn Agents</div>
        <div class="help-key">B</div><div>Build Structure</div>
        <div class="help-key">Tab</div><div>Cycle Blueprint</div>
        <div class="help-key">I</div><div>Inventory</div>
        <div class="help-key">M</div><div>Stats</div>
        <div class="help-key">P</div><div>Show Mode (P2P)</div>
        <div class="help-key">,</div><div>Settings</div>
        <div class="help-key">Esc</div><div>Leave World / Close</div>
        <div class="help-key">? or H</div><div>This Help</div>
      </div>
    </div>
  </div>

</body>
</html>
