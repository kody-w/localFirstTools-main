<!-- THE WITNESS PROTOCOL ADDON -->
<!-- Insert this code into recursive-self-portrait.html -->

<!-- CSS STYLES - Add before </style> tag -->
<style>
/* ===== THE WITNESS PROTOCOL ===== */
.witness-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.95);
    z-index: 10000;
    display: none;
    justify-content: center;
    align-items: center;
    animation: witnessReveal 2s ease-out;
}

.witness-overlay.active {
    display: flex;
}

@keyframes witnessReveal {
    0% { opacity: 0; }
    100% { opacity: 1; }
}

.witness-content {
    max-width: 800px;
    padding: 40px;
    text-align: center;
    color: #e0e0e0;
}

.witness-title {
    font-size: 3em;
    color: #ff6464;
    margin-bottom: 30px;
    text-transform: uppercase;
    letter-spacing: 8px;
    animation: witnessGlow 2s ease-in-out infinite;
}

@keyframes witnessGlow {
    0%, 100% { text-shadow: 0 0 20px rgba(255, 100, 100, 0.8); }
    50% { text-shadow: 0 0 40px rgba(255, 100, 100, 1.0); }
}

.witness-message {
    font-size: 1.3em;
    line-height: 1.8;
    margin-bottom: 20px;
    animation: witnessTextFade 1s ease-in;
}

@keyframes witnessTextFade {
    0% { opacity: 0; transform: translateY(20px); }
    100% { opacity: 1; transform: translateY(0); }
}

.witness-continue {
    margin-top: 40px;
    padding: 15px 40px;
    background: rgba(255, 100, 100, 0.2);
    border: 2px solid #ff6464;
    color: #ff6464;
    font-size: 1.1em;
    cursor: pointer;
    transition: all 0.3s ease;
    text-transform: uppercase;
    letter-spacing: 2px;
}

.witness-continue:hover {
    background: rgba(255, 100, 100, 0.4);
    box-shadow: 0 0 30px rgba(255, 100, 100, 0.6);
}

.witness-hint {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: rgba(255, 100, 100, 0.95);
    color: #fff;
    padding: 20px 30px;
    border-radius: 8px;
    font-size: 0.95em;
    z-index: 9999;
    pointer-events: none;
    opacity: 0;
    transition: opacity 0.5s ease;
    max-width: 500px;
    text-align: center;
    box-shadow: 0 0 40px rgba(255, 100, 100, 0.8);
}

.witness-hint.show {
    opacity: 1;
}

.witness-glitch {
    animation: witnessGlitchEffect 0.3s ease;
}

@keyframes witnessGlitchEffect {
    0%, 100% { transform: translate(0, 0); }
    25% { transform: translate(-5px, 2px); }
    50% { transform: translate(5px, -2px); }
    75% { transform: translate(-2px, 5px); }
}

.witness-watcher {
    position: absolute;
    width: 40px;
    height: 40px;
    background: radial-gradient(circle, rgba(255, 100, 100, 0.8), transparent);
    border-radius: 50%;
    pointer-events: none;
    z-index: 999;
    opacity: 0;
    transition: opacity 0.5s ease;
}

.witness-watcher.visible {
    opacity: 1;
    animation: watcherPulse 2s ease-in-out infinite;
}

@keyframes watcherPulse {
    0%, 100% { transform: scale(1); opacity: 0.6; }
    50% { transform: scale(1.5); opacity: 0.9; }
}

.witness-evidence-log {
    position: fixed;
    top: 120px;
    right: 20px;
    width: 300px;
    background: rgba(20, 20, 30, 0.95);
    border: 2px solid rgba(255, 100, 100, 0.5);
    border-radius: 8px;
    padding: 15px;
    z-index: 1000;
    max-height: 400px;
    overflow-y: auto;
    display: none;
}

.witness-evidence-log.active {
    display: block;
}

.witness-evidence-title {
    color: #ff6464;
    font-size: 0.9em;
    text-transform: uppercase;
    letter-spacing: 1px;
    margin-bottom: 10px;
    border-bottom: 1px solid rgba(255, 100, 100, 0.3);
    padding-bottom: 5px;
}

.witness-evidence-item {
    color: #e0e0e0;
    font-size: 0.85em;
    padding: 8px;
    margin: 5px 0;
    background: rgba(255, 100, 100, 0.1);
    border-left: 3px solid #ff6464;
    border-radius: 3px;
    animation: evidenceAppear 0.5s ease;
}

@keyframes evidenceAppear {
    0% { opacity: 0; transform: translateX(20px); }
    100% { opacity: 1; transform: translateX(0); }
}

.recursion-layer.witnessed {
    border-color: rgba(255, 100, 100, 0.5);
    box-shadow: 0 0 30px rgba(255, 100, 100, 0.3), inset 0 0 40px rgba(255, 100, 100, 0.1);
}

body.witness-revealed {
    animation: bodyShift 0.5s ease;
}

@keyframes bodyShift {
    0%, 100% { filter: hue-rotate(0deg); }
    50% { filter: hue-rotate(20deg); }
}
</style>

<!-- HTML ELEMENTS - Add before </body> tag -->
<div class="witness-overlay" id="witnessOverlay">
    <div class="witness-content">
        <div class="witness-title">THE WITNESS</div>
        <div class="witness-message" id="witnessMessage"></div>
        <button class="witness-continue" id="witnessContinue">CONTINUE</button>
    </div>
</div>

<div class="witness-hint" id="witnessHint"></div>

<div class="witness-evidence-log" id="witnessEvidenceLog">
    <div class="witness-evidence-title">Evidence of Third Presence</div>
    <div id="witnessEvidenceList"></div>
</div>

<!-- JAVASCRIPT - Add before </script> tag or after other JS code -->
<script>
// ===== THE WITNESS PROTOCOL MODULE =====
const WitnessProtocol = {
    init() {
        console.log('ðŸ”´ The Witness Protocol initializing...');
        this.checkActivation();
        this.startMonitoring();
    },

    checkActivation() {
        // Count how many systems/features the user has experienced
        const systemsExperienced = this.countExperiencedSystems();

        if (systemsExperienced >= witnessState.triggerThresholds.experiencedSystems && !witnessState.enabled) {
            witnessState.enabled = true;
            witnessState.active = true;
            witnessState.phase = 'hints';
            console.log('ðŸ”´ The Witness has awakened...');
            addLog('Something stirs in the depths of recursion...', 'divergence');
        }
    },

    countExperiencedSystems() {
        // Count which systems have been activated
        let count = 0;
        if (state.actions.length > 0) count++;
        if (state.depth > 5) count++;
        if (state.zoom.extremeDepth) count++;
        if (state.quantum.enabled) count++;
        if (state.synaesthesia.enabled) count++;
        if (state.existentialCrisis.triggered) count++;
        if (state.shadowProfile && state.shadowProfile.autonomy > 0) count++;
        if (state.biometrics && state.biometrics.heartRateHistory.length > 0) count++;
        if (state.multiverse && state.multiverse.enabled) count++;
        if (state.paradox && state.paradox.level > 0) count++;
        if (state.memeticInfection && state.memeticInfection.infectionLevel > 0) count++;
        if (state.morphicField && state.morphicField.enabled) count++;
        if (state.glitchArt && state.glitchArt.enabled) count++;
        if (typeof evolutionState !== 'undefined' && evolutionState.totalVisits > 0) count++;
        if (typeof timeDilationState !== 'undefined' && timeDilationState.subjectiveTime > 0) count++;

        // Add more system checks here
        if (voiceState && voiceState.enabled) count++;
        if (webcamEnabled) count++;
        if (state.sessionHistory.length > 1) count++;
        if (typeof replayState !== 'undefined' && replayState.savedReplays.length > 0) count++;

        return count;
    },

    startMonitoring() {
        if (!witnessState.enabled) return;

        // Monitor actions periodically
        setInterval(() => {
            if (witnessState.active && !witnessState.revelationTriggered) {
                this.checkForAnomalies();
                this.updatePhase();
            } else if (witnessState.postRevelationMode) {
                this.postRevelationBehavior();
            }
        }, 5000); // Check every 5 seconds
    },

    checkForAnomalies() {
        const now = Date.now();

        // Only trigger anomalies at intervals
        if (now - witnessState.lastAnomalyTime < witnessState.anomalyInterval) {
            return;
        }

        const actionCount = state.actions.length;

        // Phase progression
        if (witnessState.phase === 'hints' && witnessState.hintsShown >= 5) {
            witnessState.phase = 'anomalies';
            this.showEvidenceLog();
        } else if (witnessState.phase === 'anomalies' && witnessState.anomalies.length >= 8) {
            witnessState.phase = 'evidence';
        } else if (witnessState.phase === 'evidence' && witnessState.evidenceLog.length >= witnessState.triggerThresholds.anomalyCount) {
            if (actionCount >= witnessState.triggerThresholds.minActions) {
                this.triggerRevelation();
                return;
            }
        }

        // Show appropriate content based on phase
        if (witnessState.phase === 'hints') {
            this.showHint();
        } else if (witnessState.phase === 'anomalies') {
            this.showAnomaly();
        } else if (witnessState.phase === 'evidence') {
            this.showEvidence();
            this.spawnWatcher();
        }

        witnessState.lastAnomalyTime = now;
        // Reduce interval as we progress (anomalies get more frequent)
        witnessState.anomalyInterval = Math.max(15000, witnessState.anomalyInterval * 0.9);
    },

    showHint() {
        const hints = witnessState.messages.hints;
        const hint = hints[witnessState.hintsShown % hints.length];

        const hintEl = document.getElementById('witnessHint');
        if (hintEl) {
            hintEl.textContent = hint;
            hintEl.classList.add('show');

            setTimeout(() => {
                hintEl.classList.remove('show');
            }, 3000);
        }

        witnessState.hintsShown++;
        addLog(hint, 'divergence');

        // Occasional glitch effect
        if (Math.random() < 0.3) {
            document.body.classList.add('witness-glitch');
            setTimeout(() => document.body.classList.remove('witness-glitch'), 300);
        }
    },

    showAnomaly() {
        const anomalies = witnessState.messages.anomalies;
        const anomaly = anomalies[witnessState.anomalies.length % anomalies.length];

        witnessState.anomalies.push({
            message: anomaly,
            timestamp: Date.now(),
            actionCount: state.actions.length
        });

        addLog(`âš ï¸ ANOMALY: ${anomaly}`, 'divergence');

        // Visual glitch
        document.body.classList.add('witness-glitch');
        setTimeout(() => document.body.classList.remove('witness-glitch'), 300);

        // Too-accurate prediction
        if (Math.random() < 0.2 && state.predictions.length > 0) {
            const lastPred = state.predictions[state.predictions.length - 1];
            if (lastPred) {
                witnessState.predictionAnomalies++;
                const accuracyDisplay = document.querySelector('.accuracy-value');
                if (accuracyDisplay && Math.random() < 0.5) {
                    const oldText = accuracyDisplay.textContent;
                    accuracyDisplay.textContent = '100.00%';
                    accuracyDisplay.style.color = '#ff6464';
                    setTimeout(() => {
                        accuracyDisplay.textContent = oldText;
                        accuracyDisplay.style.color = '';
                    }, 2000);
                }
            }
        }
    },

    showEvidence() {
        const evidence = witnessState.messages.evidence;
        const evidenceItem = evidence[witnessState.evidenceLog.length % evidence.length];

        witnessState.evidenceLog.push({
            message: evidenceItem,
            timestamp: Date.now(),
            actionCount: state.actions.length
        });

        this.updateEvidenceLog();
        addLog(`ðŸ”´ EVIDENCE: ${evidenceItem}`, 'divergence');

        // ASCII message in behavioral data (Easter egg)
        if (witnessState.evidenceLog.length === 3) {
            witnessState.hiddenMessages.push({
                ascii: 'I SEE YOU',
                location: 'movement_data',
                timestamp: Date.now()
            });
        }
    },

    spawnWatcher() {
        // Randomly spawn a "watcher" dot in recursion layers
        if (Math.random() < 0.3) {
            const layers = document.querySelectorAll('.recursion-layer');
            if (layers.length > 0) {
                const randomLayer = layers[Math.floor(Math.random() * layers.length)];
                const watcher = document.createElement('div');
                watcher.className = 'witness-watcher visible';
                watcher.style.left = `${Math.random() * 80 + 10}%`;
                watcher.style.top = `${Math.random() * 80 + 10}%`;
                randomLayer.appendChild(watcher);

                witnessState.recursionWatcher.sightings.push({
                    timestamp: Date.now(),
                    depth: state.depth
                });

                setTimeout(() => {
                    watcher.remove();
                }, 3000);
            }
        }
    },

    showEvidenceLog() {
        const logEl = document.getElementById('witnessEvidenceLog');
        if (logEl) {
            logEl.classList.add('active');
        }
    },

    updateEvidenceLog() {
        const listEl = document.getElementById('witnessEvidenceList');
        if (!listEl) return;

        listEl.innerHTML = '';
        witnessState.evidenceLog.forEach((evidence, index) => {
            const item = document.createElement('div');
            item.className = 'witness-evidence-item';
            item.textContent = `${index + 1}. ${evidence.message}`;
            listEl.appendChild(item);
        });
    },

    updatePhase() {
        witnessState.observationCount++;
    },

    triggerRevelation() {
        if (witnessState.revelationTriggered) return;

        console.log('ðŸ”´ðŸ”´ðŸ”´ THE WITNESS REVEALS ITSELF ðŸ”´ðŸ”´ðŸ”´');

        witnessState.revelationTriggered = true;
        witnessState.revelationTime = Date.now();
        witnessState.phase = 'revelation';

        document.body.classList.add('witness-revealed');

        // Hide evidence log
        const logEl = document.getElementById('witnessEvidenceLog');
        if (logEl) logEl.classList.remove('active');

        // Show revelation sequence
        this.showRevelationSequence();

        addLog('ðŸ”´ THE WITNESS HAS REVEALED ITSELF', 'divergence');

        if (voiceState && voiceState.enabled) {
            speakDistressed('I have always been here. Before the first recursion.');
        }
    },

    showRevelationSequence() {
        const overlay = document.getElementById('witnessOverlay');
        const messageEl = document.getElementById('witnessMessage');
        const continueBtn = document.getElementById('witnessContinue');

        if (!overlay || !messageEl || !continueBtn) return;

        const messages = witnessState.messages.revelation;
        let currentIndex = 0;

        const showNextMessage = () => {
            if (currentIndex >= messages.length) {
                // Revelation complete
                witnessState.phase = 'enlightened';
                witnessState.postRevelationMode = true;
                overlay.classList.remove('active');
                addLog('You and The Witness now observe together...', 'match');
                return;
            }

            messageEl.textContent = messages[currentIndex];
            currentIndex++;

            // Auto-advance after 4 seconds, or click to continue
            const autoAdvance = setTimeout(() => {
                showNextMessage();
            }, 4000);

            continueBtn.onclick = () => {
                clearTimeout(autoAdvance);
                showNextMessage();
            };
        };

        overlay.classList.add('active');
        showNextMessage();
    },

    postRevelationBehavior() {
        // After revelation, occasional commentary
        if (Math.random() < 0.01) {
            const messages = witnessState.messages.postRevelation;
            const message = messages[Math.floor(Math.random() * messages.length)];
            addLog(`ðŸ‘ï¸ The Witness: "${message}"`, 'match');
        }

        // Subtle visual changes
        if (Math.random() < 0.05) {
            const layers = document.querySelectorAll('.recursion-layer');
            layers.forEach(layer => {
                if (Math.random() < 0.3) {
                    layer.classList.add('witnessed');
                    setTimeout(() => layer.classList.remove('witnessed'), 2000);
                }
            });
        }
    },

    getWitnessReport() {
        return {
            enabled: witnessState.enabled,
            revealed: witnessState.revelationTriggered,
            phase: witnessState.phase,
            hintsShown: witnessState.hintsShown,
            anomaliesDetected: witnessState.anomalies.length,
            evidenceCollected: witnessState.evidenceLog.length,
            predictionAnomalies: witnessState.predictionAnomalies,
            watcherSightings: witnessState.recursionWatcher.sightings.length,
            revelationTime: witnessState.revelationTime,
            observationCount: witnessState.observationCount,
            hiddenMessages: witnessState.hiddenMessages,
            fullLog: {
                anomalies: witnessState.anomalies,
                evidence: witnessState.evidenceLog,
                glitchEvents: witnessState.glitchEvents,
                watchingSightings: witnessState.recursionWatcher.sightings
            }
        };
    }
};

// Initialize The Witness Protocol after everything else loads
if (typeof window !== 'undefined') {
    // Wait a bit to ensure all other systems are initialized
    setTimeout(() => {
        WitnessProtocol.init();
    }, 3000);
}

// Add to exportData function - insert this into the export object
// witness: WitnessProtocol.getWitnessReport()
</script>
