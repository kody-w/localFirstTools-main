<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Solar System Builder</title>
    <meta name="description" content="Procedural 3D solar system generator with interactive zoom into planets and moons.">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            overflow: hidden;
            background-color: #000;
            color: white;
            font-family: 'Segoe UI', system-ui, sans-serif;
        }

        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0,0,0,0.7);
            padding: 15px;
            border-radius: 10px;
            pointer-events: none;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.1);
            max-width: 300px;
        }

        #info h2 {
            background: linear-gradient(90deg, #ff6b6b, #4ecdc4);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 10px;
        }

        #controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.7);
            padding: 15px 25px;
            border-radius: 30px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.1);
            display: flex;
            gap: 10px;
        }

        button {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 10px 20px;
            cursor: pointer;
            border-radius: 20px;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.3s ease;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(102, 126, 234, 0.4);
        }

        button:active {
            transform: translateY(0);
        }

        button.secondary {
            background: rgba(255,255,255,0.1);
        }

        button.secondary:hover {
            background: rgba(255,255,255,0.2);
        }

        button.secondary.active {
            background: rgba(78, 205, 196, 0.3);
            border-color: rgba(78, 205, 196, 0.6);
            color: #4ecdc4;
        }

        /* Data management buttons */
        .data-controls {
            position: absolute;
            bottom: 80px;
            left: 20px;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .data-controls button {
            font-size: 12px;
            padding: 8px 15px;
            background: rgba(78, 205, 196, 0.3);
            border: 1px solid rgba(78, 205, 196, 0.5);
        }

        .data-controls button:hover {
            background: rgba(78, 205, 196, 0.5);
        }

        /* First-time guided tour */
        #tour-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            z-index: 10000;
            display: none;
            align-items: center;
            justify-content: center;
        }

        #tour-overlay.visible {
            display: flex;
        }

        .tour-modal {
            background: rgba(0, 0, 0, 0.95);
            border: 1px solid rgba(78, 205, 196, 0.5);
            border-radius: 15px;
            padding: 30px;
            max-width: 450px;
            text-align: center;
            box-shadow: 0 0 30px rgba(78, 205, 196, 0.3);
        }

        .tour-modal h3 {
            color: #4ecdc4;
            margin-bottom: 15px;
            font-size: 22px;
        }

        .tour-modal p {
            color: rgba(255, 255, 255, 0.85);
            line-height: 1.6;
            margin-bottom: 20px;
        }

        .tour-modal .tour-step-indicator {
            display: flex;
            justify-content: center;
            gap: 8px;
            margin-bottom: 20px;
        }

        .tour-modal .step-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.3);
        }

        .tour-modal .step-dot.active {
            background: #4ecdc4;
        }

        .tour-buttons {
            display: flex;
            gap: 10px;
            justify-content: center;
        }

        .tour-buttons button {
            padding: 10px 20px;
            border-radius: 20px;
            border: none;
            cursor: pointer;
            font-size: 14px;
        }

        .tour-btn-skip {
            background: rgba(255, 255, 255, 0.1);
            color: rgba(255, 255, 255, 0.7);
        }

        .tour-btn-next {
            background: linear-gradient(135deg, #4ecdc4, #44a08d);
            color: white;
        }

        /* Keyboard help panel */
        #keyboard-help {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(0,0,0,0.8);
            padding: 15px;
            border-radius: 10px;
            font-size: 12px;
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: none;
            border: 1px solid rgba(255,255,255,0.1);
        }

        #keyboard-help.visible {
            opacity: 1;
        }

        #keyboard-help h4 {
            margin-bottom: 10px;
            color: #4ecdc4;
        }

        #keyboard-help .key-row {
            display: flex;
            justify-content: space-between;
            margin: 5px 0;
            gap: 20px;
        }

        #keyboard-help .key {
            background: rgba(255,255,255,0.1);
            padding: 2px 8px;
            border-radius: 4px;
            font-family: monospace;
        }

        /* Focus indicator for accessibility */
        button:focus, .moon-item:focus {
            outline: 2px solid #4ecdc4;
            outline-offset: 2px;
        }

        /* Skip link for accessibility */
        .skip-link {
            position: absolute;
            top: -40px;
            left: 0;
            background: #4ecdc4;
            color: black;
            padding: 8px 16px;
            z-index: 10000;
            transition: top 0.3s;
        }

        .skip-link:focus {
            top: 0;
        }

        /* Planet selection indicator */
        .planet-selector {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .planet-selector.visible {
            opacity: 1;
        }

        .planet-selector-ring {
            width: 60px;
            height: 60px;
            border: 2px solid #4ecdc4;
            border-radius: 50%;
            animation: selectorPulse 1.5s ease-in-out infinite;
        }

        @keyframes selectorPulse {
            0%, 100% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.2); opacity: 0.5; }
        }

        /* Pause indicator */
        #pause-indicator {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 48px;
            color: rgba(255,255,255,0.8);
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s ease;
            text-shadow: 0 0 20px rgba(0,0,0,0.8);
        }

        #pause-indicator.visible {
            opacity: 1;
        }

        /* Pause button styling */
        #pause-btn {
            background: rgba(255, 107, 107, 0.6);
            min-width: 50px;
        }

        #pause-btn.paused {
            background: rgba(78, 205, 196, 0.6);
        }

        /* Mobile responsive styles */
        @media (max-width: 768px) {
            #info {
                top: 5px;
                left: 5px;
                right: 5px;
                max-width: none;
                padding: 10px;
                font-size: 12px;
            }

            #info h2 {
                font-size: 1.1em;
            }

            #controls {
                bottom: 10px;
                left: 5px;
                right: 5px;
                transform: none;
                padding: 10px;
                border-radius: 15px;
                flex-wrap: wrap;
                justify-content: center;
                gap: 6px;
            }

            button {
                padding: 12px 16px;
                font-size: 12px;
                min-height: 44px;
                min-width: 44px;
            }

            .data-controls {
                bottom: auto;
                top: 80px;
                left: 5px;
                flex-direction: row;
                flex-wrap: wrap;
                gap: 5px;
            }

            .data-controls button {
                padding: 10px 12px;
                min-height: 44px;
            }

            #detail-panel {
                right: 5px;
                left: 5px;
                width: auto;
                max-height: 50vh;
                overflow-y: auto;
                top: auto;
                bottom: 100px;
                transform: none;
                padding: 15px;
            }

            #detail-panel h3 {
                font-size: 1.2em;
            }

            /* Hide keyboard help only on true touch-only devices (no pointer hover capability) */
            @supports not (hover: hover) {
                #keyboard-help {
                    display: none;
                }
            }

            /* For devices with both touch and hover (tablets with keyboards), allow toggling */
            @supports (hover: hover) {
                #keyboard-help {
                    /* Keyboard help can be toggled with ? key even on tablets */
                }
            }

            #click-hint {
                bottom: 130px;
                font-size: 0.8em;
                padding: 6px 15px;
            }

            #back-btn {
                top: 10px;
                right: 10px;
                padding: 12px 16px;
            }

            #view-mode {
                top: 10px;
                font-size: 0.8em;
                padding: 6px 15px;
            }

            #transmission-indicator {
                font-size: 0.6em;
            }

            #timestamp {
                bottom: 130px;
                font-size: 0.55em;
            }

            .moon-item {
                padding: 12px 15px;
                min-height: 44px;
            }
        }

        @media (max-width: 480px) {
            #controls button span.btn-text {
                display: none;
            }

            #controls {
                gap: 4px;
            }

            button {
                padding: 10px 12px;
            }
        }

        /* Touch feedback */
        @media (hover: none) and (pointer: coarse) {
            button:active {
                transform: scale(0.95);
                opacity: 0.8;
            }
        }

        /* Canvas touch optimization */
        canvas {
            touch-action: none;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }

        /* Floating labels for celestial bodies */
        .celestial-label {
            position: absolute;
            pointer-events: none;
            font-size: 11px;
            font-weight: 500;
            color: white;
            background: rgba(0,0,0,0.6);
            padding: 3px 8px;
            border-radius: 4px;
            white-space: nowrap;
            transform: translate(-50%, -100%);
            margin-top: -10px;
            transition: opacity 0.3s ease;
            text-shadow: 0 1px 2px rgba(0,0,0,0.8);
            border: 1px solid rgba(255,255,255,0.1);
        }

        .celestial-label.planet {
            border-left: 3px solid #4ecdc4;
        }

        .celestial-label.moon {
            font-size: 10px;
            border-left: 3px solid #ff6b6b;
            opacity: 0.8;
        }

        .celestial-label.star {
            border-left: 3px solid #ffcc33;
            font-weight: 600;
        }

        /* ARIA live region */
        #aria-announcer {
            position: absolute;
            left: -10000px;
            width: 1px;
            height: 1px;
            overflow: hidden;
        }

        /* Reduced motion support */
        @media (prefers-reduced-motion: reduce) {
            *, *::before, *::after {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
            }
        }

        /* Object Detail Panel */
        #detail-panel {
            position: absolute;
            right: 20px;
            top: 50%;
            transform: translateY(-50%);
            background: rgba(0,0,0,0.85);
            padding: 25px;
            border-radius: 15px;
            backdrop-filter: blur(15px);
            border: 1px solid rgba(255,255,255,0.15);
            width: 320px;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.4s ease, transform 0.4s ease;
        }

        #detail-panel.visible {
            opacity: 1;
            pointer-events: all;
        }

        #detail-panel h3 {
            font-size: 1.5em;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }

        #detail-panel .stat-row {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid rgba(255,255,255,0.05);
        }

        #detail-panel .stat-label {
            color: rgba(255,255,255,0.6);
        }

        #detail-panel .stat-value {
            color: #4ecdc4;
            font-weight: 500;
        }

        #detail-panel .description {
            margin-top: 15px;
            color: rgba(255,255,255,0.7);
            line-height: 1.6;
            font-size: 0.9em;
        }

        #detail-panel .moons-section {
            margin-top: 20px;
        }

        #detail-panel .moons-section h4 {
            color: #ff6b6b;
            margin-bottom: 10px;
        }

        #detail-panel .moon-item {
            background: rgba(255,255,255,0.05);
            padding: 10px 15px;
            border-radius: 8px;
            margin-bottom: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        #detail-panel .moon-item:hover {
            background: rgba(255,255,255,0.1);
            transform: translateX(5px);
        }

        #detail-panel .moon-item .zoom-hint {
            font-size: 0.8em;
            color: rgba(255,255,255,0.7); /* Cycle 1: Improved contrast for accessibility */
        }

        #back-btn {
            position: absolute;
            top: 20px;
            right: 20px;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
            background: rgba(255,100,100,0.8);
        }

        #back-btn.visible {
            opacity: 1;
            pointer-events: all;
        }

        /* Clickable indicator */
        #click-hint {
            position: absolute;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.6);
            padding: 8px 20px;
            border-radius: 20px;
            font-size: 0.9em;
            color: rgba(255,255,255,0.7);
            pointer-events: none;
        }

        /* Loading indicator */
        .transitioning::after {
            content: '';
            position: fixed;
            top: 50%;
            left: 50%;
            width: 40px;
            height: 40px;
            margin: -20px 0 0 -20px;
            border: 3px solid rgba(255,255,255,0.1);
            border-top-color: #4ecdc4;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Star glow effect */
        .star-glow {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 200px;
            height: 200px;
            margin: -100px 0 0 -100px;
            background: radial-gradient(circle, rgba(255,200,100,0.3) 0%, transparent 70%);
            pointer-events: none;
            opacity: 0.5;
        }

        /* View mode indicator */
        #view-mode {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.8), rgba(118, 75, 162, 0.8));
            padding: 8px 25px;
            border-radius: 20px;
            font-size: 0.9em;
            font-weight: 500;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        #view-mode.visible {
            opacity: 1;
        }

        /* ========================================
           BROADCAST TRANSMISSION EFFECTS
           ======================================== */

        /* Scanlines overlay - very subtle */
        .broadcast-overlay {
            position: fixed;
            inset: 0;
            pointer-events: none;
            z-index: 9999;
        }

        .broadcast-overlay::before {
            content: '';
            position: absolute;
            inset: 0;
            background: repeating-linear-gradient(
                0deg,
                transparent,
                transparent 2px,
                rgba(0, 0, 0, 0.03) 2px,
                rgba(0, 0, 0, 0.03) 4px
            );
            animation: scanlineMove 8s linear infinite;
        }

        /* CRT vignette */
        .broadcast-overlay::after {
            content: '';
            position: absolute;
            inset: 0;
            background: radial-gradient(
                ellipse at center,
                transparent 60%,
                rgba(0, 0, 0, 0.3) 100%
            );
        }

        @keyframes scanlineMove {
            0% { transform: translateY(0); }
            100% { transform: translateY(4px); }
        }

        /* Signal interference flicker - rare */
        @keyframes signalFlicker {
            0%, 97%, 100% { opacity: 1; filter: none; }
            97.5% { opacity: 0.8; filter: brightness(1.2) contrast(1.1); }
            98% { opacity: 1; filter: hue-rotate(5deg); }
            98.5% { opacity: 0.95; filter: none; }
        }

        body.signal-active {
            animation: signalFlicker 15s infinite;
        }

        /* Transmission indicator */
        #transmission-indicator {
            position: fixed;
            top: 15px;
            right: 15px;
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.7em;
            color: rgba(255, 255, 255, 0.4);
            font-family: 'Courier New', monospace;
            text-transform: uppercase;
            letter-spacing: 1px;
            z-index: 100;
        }

        #transmission-indicator .signal-dot {
            width: 6px;
            height: 6px;
            background: #4ecdc4;
            border-radius: 50%;
            animation: signalPulse 2s ease-in-out infinite;
            box-shadow: 0 0 6px #4ecdc4;
        }

        @keyframes signalPulse {
            0%, 100% { opacity: 0.4; }
            50% { opacity: 1; }
        }

        #transmission-indicator .signal-strength {
            display: flex;
            gap: 2px;
            align-items: flex-end;
        }

        #transmission-indicator .signal-bar {
            width: 3px;
            background: rgba(78, 205, 196, 0.6);
            border-radius: 1px;
        }

        /* Chromatic aberration on UI panels - very subtle */
        #info, #detail-panel, #controls {
            text-shadow:
                0.3px 0 0 rgba(255, 0, 0, 0.1),
                -0.3px 0 0 rgba(0, 255, 255, 0.1);
        }

        /* Glitch text effect class */
        .glitch-text {
            position: relative;
        }

        .glitch-text::before,
        .glitch-text::after {
            content: attr(data-text);
            position: absolute;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            opacity: 0;
        }

        .glitch-text.glitching::before {
            animation: glitchTop 0.2s linear;
            color: #0ff;
            clip-path: polygon(0 0, 100% 0, 100% 45%, 0 45%);
        }

        .glitch-text.glitching::after {
            animation: glitchBottom 0.3s linear;
            color: #f0f;
            clip-path: polygon(0 55%, 100% 55%, 100% 100%, 0 100%);
        }

        @keyframes glitchTop {
            0% { opacity: 0; transform: translateX(0); }
            20% { opacity: 0.8; transform: translateX(-2px); }
            40% { opacity: 0; transform: translateX(2px); }
            60% { opacity: 0.6; transform: translateX(-1px); }
            80% { opacity: 0; transform: translateX(1px); }
            100% { opacity: 0; transform: translateX(0); }
        }

        @keyframes glitchBottom {
            0% { opacity: 0; transform: translateX(0); }
            25% { opacity: 0.7; transform: translateX(2px); }
            50% { opacity: 0; transform: translateX(-2px); }
            75% { opacity: 0.5; transform: translateX(1px); }
            100% { opacity: 0; transform: translateX(0); }
        }

        /* Noise grain overlay - extremely subtle */
        .noise-overlay {
            position: fixed;
            inset: 0;
            pointer-events: none;
            z-index: 9998;
            opacity: 0.015;
            background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%' height='100%' filter='url(%23noise)'/%3E%3C/svg%3E");
        }

        /* Subtle horizontal interference lines - very rare */
        .interference-line {
            position: fixed;
            left: 0;
            right: 0;
            height: 2px;
            background: linear-gradient(90deg,
                transparent,
                rgba(255,255,255,0.1) 20%,
                rgba(255,255,255,0.15) 50%,
                rgba(255,255,255,0.1) 80%,
                transparent
            );
            pointer-events: none;
            z-index: 9997;
            opacity: 0;
            transform: scaleX(0);
        }

        .interference-line.active {
            animation: interferencePass 0.15s ease-out forwards;
        }

        @keyframes interferencePass {
            0% { transform: scaleX(0); opacity: 1; }
            100% { transform: scaleX(1); opacity: 0; }
        }

        /* Timestamp display */
        #timestamp {
            position: fixed;
            bottom: 80px;
            right: 15px;
            font-family: 'Courier New', monospace;
            font-size: 0.65em;
            color: rgba(255, 255, 255, 0.25);
            letter-spacing: 1px;
            z-index: 100;
        }

        /* Screenshot mode - hide UI temporarily */
        .screenshot-hidden {
            opacity: 0 !important;
            pointer-events: none !important;
        }

        /* Loading indicator */
        #loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 9999;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }

        #loading-overlay.visible {
            opacity: 1;
            pointer-events: all;
        }

        .loading-spinner {
            width: 60px;
            height: 60px;
            border: 4px solid rgba(255, 255, 255, 0.2);
            border-top-color: #4ecdc4;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        .loading-text {
            margin-top: 20px;
            color: #4ecdc4;
            font-size: 1.2em;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
</head>
<body class="signal-active">
    <!-- Skip link for accessibility -->
    <a href="#controls" class="skip-link" tabindex="0">Skip to controls</a>

    <!-- ARIA live region for screen reader announcements -->
    <div id="aria-announcer" role="status" aria-live="polite" aria-atomic="true"></div>

    <!-- Loading overlay for system generation -->
    <div id="loading-overlay" role="status" aria-live="polite">
        <div class="loading-spinner"></div>
        <div class="loading-text">Generating solar system...</div>
    </div>

    <!-- Container for floating celestial body labels -->
    <div id="labels-container" aria-hidden="true"></div>

    <!-- Broadcast transmission overlays (decorative - hidden from assistive tech) -->
    <div class="broadcast-overlay" aria-hidden="true" role="presentation"></div>
    <div class="noise-overlay" aria-hidden="true" role="presentation"></div>
    <div class="interference-line" id="interference-line" aria-hidden="true" role="presentation"></div>

    <!-- Planet selector for keyboard navigation -->
    <div class="planet-selector" id="planet-selector" aria-hidden="true">
        <div class="planet-selector-ring"></div>
    </div>

    <!-- Transmission status indicator (decorative visual effect) -->
    <div id="transmission-indicator" aria-hidden="true" role="presentation">
        <div class="signal-dot"></div>
        <span>LIVE FEED</span>
        <div class="signal-strength">
            <div class="signal-bar" style="height: 4px;"></div>
            <div class="signal-bar" style="height: 7px;"></div>
            <div class="signal-bar" style="height: 10px;"></div>
            <div class="signal-bar" style="height: 6px; opacity: 0.4;"></div>
        </div>
    </div>

    <div id="timestamp">TRANSMISSION: <span id="tx-time">00:00:00</span></div>

    <div id="info">
        <h2>Procedural Solar System</h2>
        <p>Click on any planet or moon to zoom in for an orbital view.</p>
        <div id="system-stats"></div>
        <div id="seed-display" style="margin-top: 10px; padding-top: 8px; border-top: 1px solid rgba(255,255,255,0.1); font-size: 11px; color: rgba(255,255,255,0.6);">
            Seed: <span id="current-seed" style="font-family: monospace; color: #4ecdc4;">-</span>
            <button id="share-btn" style="margin-left: 8px; padding: 2px 8px; font-size: 10px; background: rgba(78,205,196,0.3); border: 1px solid rgba(78,205,196,0.5); color: #4ecdc4; border-radius: 4px; cursor: pointer;" title="Copy shareable link">Share</button>
        </div>
    </div>

    <div id="view-mode">Orbiting: <span id="view-target"></span></div>

    <button id="back-btn">Back to System View</button>

    <div id="detail-panel">
        <h3 id="detail-name">Planet Name</h3>
        <div id="detail-stats"></div>
        <div class="description" id="detail-description"></div>
        <div class="moons-section" id="moons-section" style="display: none;">
            <h4>Moons</h4>
            <div id="moons-list"></div>
        </div>
    </div>

    <!-- Pause indicator -->
    <div id="pause-indicator" aria-live="polite" aria-atomic="true">⏸ PAUSED</div>

    <div id="controls" role="toolbar" aria-label="Solar system controls">
        <button id="generate-btn" aria-label="Generate new solar system">Generate New System</button>
        <button id="pause-btn" class="secondary" aria-label="Pause simulation" aria-pressed="false">⏵</button>
        <button id="toggle-orbits" class="secondary" aria-label="Toggle orbit lines" aria-pressed="true">Toggle Orbits</button>
        <button id="toggle-labels" class="secondary" aria-label="Toggle labels" aria-pressed="true">Toggle Labels</button>
        <button id="speed-btn" class="secondary" aria-label="Change simulation speed">Speed: 1x</button>
    </div>

    <div id="click-hint">Click on any celestial body to explore</div>

    <!-- Data management controls -->
    <div class="data-controls">
        <button id="save-btn" title="Save current system to browser storage" aria-label="Save solar system">Save System</button>
        <button id="export-btn" title="Export system as JSON file" aria-label="Export solar system as JSON">Export JSON</button>
        <button id="import-btn" title="Import system from JSON file" aria-label="Import solar system from JSON">Import JSON</button>
        <input type="file" id="import-file" accept=".json" style="display: none;" aria-hidden="true">
    </div>

    <!-- First-time guided tour -->
    <div id="tour-overlay" role="dialog" aria-modal="true" aria-labelledby="tour-title">
        <div class="tour-modal">
            <h3 id="tour-title">Welcome to Solar System Builder!</h3>
            <div id="tour-content">
                <p>Explore procedurally generated solar systems. Click on any planet or moon to zoom in for an orbital view.</p>
            </div>
            <div class="tour-step-indicator" id="tour-dots"></div>
            <div class="tour-buttons">
                <button class="tour-btn-skip" id="tour-skip">Skip Tour</button>
                <button class="tour-btn-next" id="tour-next">Next</button>
            </div>
        </div>
    </div>

    <!-- Keyboard help panel -->
    <div id="keyboard-help" role="complementary" aria-label="Keyboard shortcuts">
        <h4>Keyboard Shortcuts</h4>
        <div class="key-row"><span class="key">?</span><span>Toggle this help</span></div>
        <div class="key-row"><span class="key">Space/P</span><span>Pause/play</span></div>
        <div class="key-row"><span class="key">G</span><span>Generate new system</span></div>
        <div class="key-row"><span class="key">O</span><span>Toggle orbit lines</span></div>
        <div class="key-row"><span class="key">L</span><span>Toggle labels</span></div>
        <div class="key-row"><span class="key">+/-</span><span>Change speed</span></div>
        <div class="key-row"><span class="key">1-9</span><span>Select planet</span></div>
        <div class="key-row"><span class="key">0</span><span>Select star</span></div>
        <div class="key-row"><span class="key">Arrows</span><span>Navigate planets</span></div>
        <div class="key-row"><span class="key">Enter</span><span>Zoom to selected</span></div>
        <div class="key-row"><span class="key">Esc</span><span>Return to system view</span></div>
        <div class="key-row"><span class="key">S</span><span>Save system</span></div>
        <div class="key-row"><span class="key">C</span><span>Capture screenshot</span></div>
    </div>

    <script>
        // ========================================
        // APPLICATION CONFIGURATION
        // ========================================
        const APP_CONFIG = {
            // Speed presets for simulation
            SPEED_PRESETS: [0.25, 0.5, 1, 2, 5],

            // Import/Export limits
            MAX_FILE_SIZE: 500000, // 500KB
            MAX_PLANETS: 20,
            MAX_MOONS_PER_PLANET: 15,

            // Display limits
            MAX_VISIBLE_LABELS: 5,

            // LocalStorage keys
            STORAGE_KEY: 'solarSystemSave',
            TOUR_STORAGE_KEY: 'solarSystemTourComplete',

            // Camera settings
            DEFAULT_CAMERA_DISTANCE: 200,
            MIN_ZOOM: 10,
            MAX_ZOOM: 1000,

            // Touch settings
            SWIPE_MIN_DISTANCE: 50,
            SWIPE_MAX_DURATION: 400
        };

        // ========================================
        // SECURITY UTILITIES
        // ========================================
        // Escape HTML to prevent XSS attacks in dynamic content
        function escapeHTML(str) {
            if (str === null || str === undefined) return '';
            return String(str)
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&#039;');
        }

        // ========================================
        // SCENE SETUP
        // ========================================
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 10000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.body.appendChild(renderer.domElement);

        // Add ARIA attributes for screen reader accessibility
        renderer.domElement.setAttribute('role', 'img');
        renderer.domElement.setAttribute('aria-label', 'Interactive 3D solar system visualization. Use mouse to rotate and zoom. Click celestial bodies to explore.');

        // Orbit Controls with enhanced mobile touch sensitivity
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.minDistance = APP_CONFIG.MIN_ZOOM;
        controls.maxDistance = APP_CONFIG.MAX_ZOOM;
        controls.autoRotate = false;
        controls.autoRotateSpeed = 0.5;

        // Enhanced touch sensitivity for mobile
        controls.rotateSpeed = 0.8;
        controls.zoomSpeed = 1.2;
        controls.panSpeed = 0.8;

        // Touch-specific settings for better mobile UX
        if ('ontouchstart' in window || navigator.maxTouchPoints > 0) {
            controls.rotateSpeed = 0.5;  // Slower rotation for touch precision
            controls.zoomSpeed = 0.8;    // More controlled pinch-zoom
            controls.enablePan = false;  // Disable pan to avoid conflicts with swipe gestures
        }

        // Lighting
        const ambientLight = new THREE.AmbientLight(0x222222);
        scene.add(ambientLight);

        const pointLight = new THREE.PointLight(0xffffff, 2, 3000);
        scene.add(pointLight);

        // Raycaster for click detection
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        // ========================================
        // STATE MANAGEMENT
        // ========================================
        let star = null;
        let planets = [];
        let allClickableObjects = [];
        let showOrbits = true;
        let showLabels = true;
        let timeSpeed = 1;

        // ========================================
        // SEEDED RANDOM NUMBER GENERATOR
        // ========================================
        let currentSeed = null;
        let seedRandom = null;

        // Mulberry32 PRNG - fast and high-quality
        function mulberry32(seed) {
            return function() {
                let t = seed += 0x6D2B79F5;
                t = Math.imul(t ^ t >>> 15, t | 1);
                t ^= t + Math.imul(t ^ t >>> 7, t | 61);
                return ((t ^ t >>> 14) >>> 0) / 4294967296;
            };
        }

        // Generate a random seed from current time
        function generateRandomSeed() {
            return Math.floor(Math.random() * 2147483647);
        }

        // Initialize PRNG with a seed
        function initSeed(seed) {
            currentSeed = seed;
            seedRandom = mulberry32(seed);
            updateSeedDisplay();
        }

        // Get next random value (0-1)
        function seededRandom() {
            return seedRandom ? seedRandom() : Math.random();
        }

        // Update seed display in UI
        function updateSeedDisplay() {
            const seedEl = document.getElementById('current-seed');
            if (seedEl && currentSeed !== null) {
                seedEl.textContent = currentSeed.toString(16).toUpperCase();
            }
        }

        // Copy shareable URL to clipboard
        function copyShareLink() {
            if (currentSeed === null) return;
            const url = new URL(window.location.href);
            url.searchParams.set('seed', currentSeed);
            navigator.clipboard.writeText(url.toString()).then(() => {
                showNotification('Share link copied to clipboard!');
            }).catch(() => {
                showNotification('Failed to copy link', true);
            });
        }

        // Check for seed in URL on load
        function checkURLSeed() {
            const params = new URLSearchParams(window.location.search);
            const seedParam = params.get('seed');
            if (seedParam) {
                // Strict validation: only allow numeric characters, reasonable length
                if (!/^\d{1,15}$/.test(seedParam)) {
                    console.warn('Invalid seed format in URL');
                    showNotification('Invalid seed format - generating random system', true);
                    return null;
                }
                const seed = parseInt(seedParam, 10);
                // Validate it's a safe integer
                if (!Number.isSafeInteger(seed) || seed < 0) {
                    console.warn('Seed out of safe range');
                    showNotification('Seed out of range - generating random system', true);
                    return null;
                }
                return seed;
            }
            return null;
        }

        // ========================================
        // GUIDED TOUR SYSTEM
        // ========================================
        const tourSteps = [
            {
                title: 'Welcome to Solar System Builder!',
                content: 'Explore procedurally generated solar systems. Click on any planet or moon to zoom in for an orbital view.'
            },
            {
                title: 'Keyboard Controls',
                content: 'Press <strong>?</strong> anytime to see all keyboard shortcuts. Use <strong>1-9</strong> to select planets, <strong>G</strong> to generate new systems.'
            },
            {
                title: 'Share Your Discovery',
                content: 'Each system has a unique seed. Click <strong>Share</strong> in the info panel to copy a link that recreates this exact solar system!'
            },
            {
                title: 'Explore & Save',
                content: 'Use the buttons below to save your favorite systems, export them as JSON, or import systems shared by others. Enjoy exploring!'
            }
        ];
        let currentTourStep = 0;

        function initTour() {
            if (localStorage.getItem(APP_CONFIG.TOUR_STORAGE_KEY)) return; // Already completed

            const overlay = document.getElementById('tour-overlay');
            const dotsContainer = document.getElementById('tour-dots');
            const nextBtn = document.getElementById('tour-next');
            const skipBtn = document.getElementById('tour-skip');

            // Create step dots
            dotsContainer.innerHTML = tourSteps.map((_, i) =>
                `<span class="step-dot ${i === 0 ? 'active' : ''}"></span>`
            ).join('');

            // Show tour
            overlay.classList.add('visible');
            updateTourStep();

            nextBtn.addEventListener('click', () => {
                currentTourStep++;
                if (currentTourStep >= tourSteps.length) {
                    endTour();
                } else {
                    updateTourStep();
                }
            });

            skipBtn.addEventListener('click', endTour);

            // ESC to close tour
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape' && overlay.classList.contains('visible')) {
                    endTour();
                }
            });
        }

        function updateTourStep() {
            const step = tourSteps[currentTourStep];
            document.getElementById('tour-title').textContent = step.title;
            document.getElementById('tour-content').innerHTML = `<p>${step.content}</p>`;

            // Update dots
            const dots = document.querySelectorAll('.step-dot');
            dots.forEach((dot, i) => dot.classList.toggle('active', i === currentTourStep));

            // Update button text
            const nextBtn = document.getElementById('tour-next');
            nextBtn.textContent = currentTourStep === tourSteps.length - 1 ? 'Get Started' : 'Next';
        }

        function endTour() {
            localStorage.setItem(APP_CONFIG.TOUR_STORAGE_KEY, 'true');
            document.getElementById('tour-overlay').classList.remove('visible');
        }

        let currentView = 'system'; // 'system', 'planet', 'moon'
        let focusedObject = null;
        let targetCameraPosition = null;
        let targetLookAt = null;
        let isTransitioning = false;
        let starData = null;
        let cameraOffset = null; // Store offset from focused object
        let isPaused = false; // Pause state
        let isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;

        // Pre-allocated Vector3 objects to reduce GC pressure in animation loop
        const _tempVec3_objectPos = new THREE.Vector3();
        const _tempVec3_targetCamPos = new THREE.Vector3();
        // Pooled vectors for updateLabels to avoid per-call allocations
        const _tempVec3_labelPos = new THREE.Vector3();
        const _tempVec3_labelScreen = new THREE.Vector3();

        // Planet name generators
        const prefixes = ['Kepler', 'Proxima', 'Tau', 'Epsilon', 'Zeta', 'Omicron', 'Sigma', 'Delta', 'Gamma', 'Nova'];
        const suffixes = ['Prime', 'Major', 'Minor', 'Alpha', 'Beta', 'Centauri', 'Reticuli', 'Eridani', 'Cygni', 'Draconis'];
        const moonPrefixes = ['Io', 'Europa', 'Titan', 'Phobos', 'Deimos', 'Triton', 'Charon', 'Ganymede', 'Callisto', 'Enceladus'];

        function generateName() {
            return prefixes[Math.floor(seededRandom() * prefixes.length)] + '-' +
                   Math.floor(seededRandom() * 999) +
                   (seededRandom() > 0.5 ? ' ' + suffixes[Math.floor(seededRandom() * suffixes.length)] : '');
        }

        function generateMoonName() {
            return moonPrefixes[Math.floor(seededRandom() * moonPrefixes.length)] + '-' +
                   String.fromCharCode(65 + Math.floor(seededRandom() * 26));
        }

        // Planet type descriptions
        const planetDescriptions = {
            gas: [
                "A massive gas giant with swirling storms visible from orbit. Hydrogen and helium dominate its atmosphere.",
                "This jovian world features colorful bands of ammonia clouds racing around its equator at tremendous speeds.",
                "A frigid ice giant with a distinctive blue-green hue from methane in its upper atmosphere.",
                "Storm systems larger than terrestrial worlds rage across this gas giant's turbulent surface."
            ],
            rocky: [
                "A rocky terrestrial world with potential for surface water and geological activity.",
                "This small rocky planet shows signs of ancient volcanic activity and impact craters.",
                "A dense iron-core world with a thin atmosphere of carbon dioxide and nitrogen.",
                "Surface scans reveal mountain ranges and vast plains of silicate rock."
            ]
        };

        const moonDescriptions = [
            "A small rocky satellite with a heavily cratered surface from billions of years of impacts.",
            "This moon shows signs of cryovolcanic activity, potentially harboring a subsurface ocean.",
            "Tidal forces from the parent planet keep this moon geologically active.",
            "A captured asteroid now locked in orbit around its host planet."
        ];

        // ========================================
        // TEXTURE GENERATION
        // ========================================
        function createPlanetTexture(type, colorHex) {
            const canvas = document.createElement('canvas');
            canvas.width = 1024;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');
            // Null check: canvas context may fail in restricted environments
            if (!ctx) {
                console.warn('Could not get 2D canvas context for planet texture');
                return new THREE.CanvasTexture(canvas); // Return empty texture
            }

            // Parse color
            const color = new THREE.Color(colorHex);
            const r = Math.floor(color.r * 255);
            const g = Math.floor(color.g * 255);
            const b = Math.floor(color.b * 255);

            // Base gradient
            const gradient = ctx.createLinearGradient(0, 0, 0, 512);
            gradient.addColorStop(0, `rgba(${r},${g},${b},1)`);
            gradient.addColorStop(0.5, `rgba(${Math.floor(r*0.8)},${Math.floor(g*0.8)},${Math.floor(b*0.8)},1)`);
            gradient.addColorStop(1, `rgba(${r},${g},${b},1)`);
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 1024, 512);

            // Add noise texture
            for (let i = 0; i < 5000; i++) {
                const x = Math.random() * 1024;
                const y = Math.random() * 512;
                const w = Math.random() * 30 + 5;
                const h = Math.random() * 15 + 3;
                const alpha = Math.random() * 0.15;
                ctx.fillStyle = Math.random() > 0.5 ?
                    `rgba(255,255,255,${alpha})` :
                    `rgba(0,0,0,${alpha})`;
                ctx.fillRect(x, y, w, h);
            }

            // Bands for gas giants
            if (type === 'gas') {
                for (let i = 0; i < 15; i++) {
                    const y = Math.random() * 512;
                    const h = Math.random() * 30 + 10;
                    ctx.fillStyle = `rgba(${Math.random() > 0.5 ? 255 : 0},${Math.random() > 0.5 ? 255 : 0},${Math.random() > 0.5 ? 255 : 0},${Math.random() * 0.2})`;
                    ctx.fillRect(0, y, 1024, h);
                }

                // Add storm spots
                for (let i = 0; i < 3; i++) {
                    const x = Math.random() * 1024;
                    const y = 150 + Math.random() * 200;
                    const radius = 20 + Math.random() * 40;
                    const grd = ctx.createRadialGradient(x, y, 0, x, y, radius);
                    grd.addColorStop(0, `rgba(255,200,150,0.5)`);
                    grd.addColorStop(1, 'transparent');
                    ctx.fillStyle = grd;
                    ctx.beginPath();
                    ctx.ellipse(x, y, radius * 1.5, radius, 0, 0, Math.PI * 2);
                    ctx.fill();
                }
            } else {
                // Terran features - continents and oceans
                for (let i = 0; i < 8; i++) {
                    const x = Math.random() * 1024;
                    const y = Math.random() * 512;
                    const radius = 50 + Math.random() * 100;
                    const grd = ctx.createRadialGradient(x, y, 0, x, y, radius);
                    grd.addColorStop(0, `rgba(${100+Math.random()*50},${150+Math.random()*50},${100+Math.random()*50},0.6)`);
                    grd.addColorStop(1, 'transparent');
                    ctx.fillStyle = grd;
                    ctx.beginPath();
                    ctx.arc(x, y, radius, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Ice caps
                ctx.fillStyle = 'rgba(255,255,255,0.4)';
                ctx.fillRect(0, 0, 1024, 30);
                ctx.fillRect(0, 482, 1024, 30);
            }

            return new THREE.CanvasTexture(canvas);
        }

        function createMoonTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 128;
            const ctx = canvas.getContext('2d');
            // Null check: canvas context may fail in restricted environments
            if (!ctx) {
                console.warn('Could not get 2D canvas context for moon texture');
                return new THREE.CanvasTexture(canvas);
            }

            // Gray base
            ctx.fillStyle = '#666';
            ctx.fillRect(0, 0, 256, 128);

            // Craters
            for (let i = 0; i < 50; i++) {
                const x = Math.random() * 256;
                const y = Math.random() * 128;
                const radius = 2 + Math.random() * 8;
                const grd = ctx.createRadialGradient(x, y, 0, x, y, radius);
                grd.addColorStop(0, 'rgba(40,40,40,0.8)');
                grd.addColorStop(0.7, 'rgba(80,80,80,0.5)');
                grd.addColorStop(1, 'transparent');
                ctx.fillStyle = grd;
                ctx.beginPath();
                ctx.arc(x, y, radius, 0, Math.PI * 2);
                ctx.fill();
            }

            return new THREE.CanvasTexture(canvas);
        }

        function createStarTexture(color) {
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 256;
            const ctx = canvas.getContext('2d');
            // Null check: canvas context may fail in restricted environments
            if (!ctx) {
                console.warn('Could not get 2D canvas context for star texture');
                return new THREE.CanvasTexture(canvas);
            }

            const c = new THREE.Color(color);
            const gradient = ctx.createRadialGradient(128, 128, 0, 128, 128, 128);
            gradient.addColorStop(0, 'white');
            gradient.addColorStop(0.1, `rgb(${Math.floor(c.r*255)},${Math.floor(c.g*255)},${Math.floor(c.b*255)})`);
            gradient.addColorStop(0.4, `rgba(${Math.floor(c.r*200)},${Math.floor(c.g*150)},${Math.floor(c.b*100)},0.5)`);
            gradient.addColorStop(1, 'transparent');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 256, 256);

            return new THREE.CanvasTexture(canvas);
        }

        // ========================================
        // STARFIELD BACKGROUND
        // ========================================
        function createStarfield() {
            const geometry = new THREE.BufferGeometry();
            const vertices = [];
            const colors = [];

            for (let i = 0; i < 10000; i++) {
                const x = (Math.random() - 0.5) * 8000;
                const y = (Math.random() - 0.5) * 8000;
                const z = (Math.random() - 0.5) * 8000;
                vertices.push(x, y, z);

                const brightness = 0.5 + Math.random() * 0.5;
                colors.push(brightness, brightness, brightness);
            }

            geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

            const material = new THREE.PointsMaterial({
                size: 2,
                vertexColors: true,
                transparent: true,
                opacity: 0.8
            });

            return new THREE.Points(geometry, material);
        }

        const starfield = createStarfield();
        scene.add(starfield);

        // ========================================
        // SOLAR SYSTEM GENERATION
        // ========================================
        // ========================================
        // SCENE CLEANUP (extracted to avoid duplication)
        // ========================================
        function clearScene() {
            // Dispose star resources
            if (star) {
                scene.remove(star);
                star.geometry.dispose();
                if (star.material && star.material.map) star.material.map.dispose();
                if (star.material) star.material.dispose();
            }

            // Dispose planet and moon resources
            planets.forEach(p => {
                scene.remove(p.mesh);
                scene.remove(p.orbitLine);
                if (p.label) scene.remove(p.label);
                p.mesh.geometry.dispose();
                if (p.mesh.material && p.mesh.material.map) p.mesh.material.map.dispose();
                if (p.mesh.material) p.mesh.material.dispose();
                if (p.moons) {
                    p.moons.forEach(m => {
                        p.mesh.remove(m.mesh);
                        if (m.label) p.mesh.remove(m.label);
                        m.mesh.geometry.dispose();
                        if (m.mesh.material && m.mesh.material.map) m.mesh.material.map.dispose();
                        if (m.mesh.material) m.mesh.material.dispose();
                    });
                }
            });

            // Reset arrays and selection state
            planets = [];
            allClickableObjects = [];
            selectedPlanetIndex = -1;
            lastAnnouncedPlanetIndex = -1;

            // Clear labels container to prevent orphaned DOM nodes
            const labelsContainer = document.getElementById('labels-container');
            if (labelsContainer) labelsContainer.innerHTML = '';

            // Clear pending announcements to prevent stale DOM references
            if (typeof announcementTimeout !== 'undefined' && announcementTimeout !== null) {
                clearTimeout(announcementTimeout);
                announcementTimeout = null;
            }
        }

        function generateSystem(seed = null) {
            // Show loading indicator
            const loadingOverlay = document.getElementById('loading-overlay');
            loadingOverlay.classList.add('visible');

            // Use requestAnimationFrame to allow UI to update before heavy work
            requestAnimationFrame(() => {
                generateSystemInternal(seed);
                // Hide loading indicator after generation
                loadingOverlay.classList.remove('visible');
            });
        }

        function generateSystemInternal(seed = null) {
            // Initialize seed - use provided seed or generate new one
            if (seed === null) {
                seed = generateRandomSeed();
            }
            initSeed(seed);

            // Clear old system using shared cleanup function
            clearScene();

            // Reset view
            currentView = 'system';
            focusedObject = null;
            cameraOffset = null;
            document.getElementById('detail-panel').classList.remove('visible');
            document.getElementById('back-btn').classList.remove('visible');
            document.getElementById('view-mode').classList.remove('visible');
            controls.autoRotate = false;

            // Generate Star (using seededRandom)
            const starTypes = [
                { color: 0xffcc33, scale: 12, name: "Yellow Dwarf", temp: "5,500K", age: "4.6 billion years" },
                { color: 0xff5533, scale: 8, name: "Red Dwarf", temp: "3,000K", age: "10 billion years" },
                { color: 0x6699ff, scale: 18, name: "Blue Giant", temp: "20,000K", age: "10 million years" },
                { color: 0xffffff, scale: 14, name: "White Star", temp: "8,000K", age: "1 billion years" },
                { color: 0xffaa66, scale: 25, name: "Orange Giant", temp: "4,500K", age: "8 billion years" }
            ];

            const starType = starTypes[Math.floor(seededRandom() * starTypes.length)];
            starData = { ...starType, systemName: generateName().split('-')[0] + ' System' };

            const starGeo = new THREE.SphereGeometry(starType.scale, 64, 64);
            const starMat = new THREE.MeshBasicMaterial({
                color: starType.color,
                transparent: true,
                opacity: 0.95
            });
            star = new THREE.Mesh(starGeo, starMat);
            star.userData = { type: 'star', data: starData };
            scene.add(star);
            allClickableObjects.push(star);

            // Star glow
            const glowGeo = new THREE.SphereGeometry(starType.scale * 1.5, 32, 32);
            const glowMat = new THREE.MeshBasicMaterial({
                color: starType.color,
                transparent: true,
                opacity: 0.2,
                side: THREE.BackSide
            });
            const glow = new THREE.Mesh(glowGeo, glowMat);
            star.add(glow);

            pointLight.color.setHex(starType.color);
            pointLight.intensity = starType.scale / 5;

            // Generate Planets
            const numPlanets = Math.floor(seededRandom() * 7) + 4;
            let currentDist = starType.scale * 2.5 + 30;

            for (let i = 0; i < numPlanets; i++) {
                const type = seededRandom() > 0.5 ? 'gas' : 'rocky';
                const size = type === 'gas' ? (seededRandom() * 5 + 4) : (seededRandom() * 2 + 1);
                const dist = currentDist + seededRandom() * 40 + 25;
                currentDist = dist;

                const speed = 0.008 / Math.sqrt(dist * 0.1);
                const colorHex = seededRandom() * 0xffffff;
                const name = generateName();

                const planetGeo = new THREE.SphereGeometry(size, 64, 64);
                const planetMat = new THREE.MeshStandardMaterial({
                    map: createPlanetTexture(type, '#' + new THREE.Color(colorHex).getHexString()),
                    roughness: type === 'gas' ? 0.9 : 0.7,
                    metalness: type === 'gas' ? 0 : 0.1
                });
                const planet = new THREE.Mesh(planetGeo, planetMat);

                // Planet data
                const planetData = {
                    name: name,
                    type: type,
                    radius: size,
                    distance: dist,
                    orbitalPeriod: Math.floor(dist * 2) + ' Earth days',
                    temperature: type === 'gas' ? '-150C (cloud tops)' : (dist < 100 ? '+' + Math.floor(300 - dist * 2) + 'C' : Math.floor(dist * -1) + 'C'),
                    description: planetDescriptions[type][Math.floor(seededRandom() * planetDescriptions[type].length)],
                    moons: []
                };

                planet.userData = { type: 'planet', data: planetData, index: i };
                allClickableObjects.push(planet);

                // Orbit Line
                const orbitGeo = new THREE.RingGeometry(dist - 0.3, dist + 0.3, 128);
                const orbitMat = new THREE.MeshBasicMaterial({
                    color: 0x444466,
                    side: THREE.DoubleSide,
                    transparent: true,
                    opacity: 0.3
                });
                const orbitLine = new THREE.Mesh(orbitGeo, orbitMat);
                orbitLine.rotation.x = Math.PI / 2;
                scene.add(orbitLine);
                if (!showOrbits) orbitLine.visible = false;

                // Moons
                const moons = [];
                const numMoons = type === 'gas' ? Math.floor(seededRandom() * 5) + 1 : (seededRandom() > 0.6 ? Math.floor(seededRandom() * 2) + 1 : 0);

                for (let j = 0; j < numMoons; j++) {
                    const mSize = size * (0.1 + seededRandom() * 0.15);
                    const mDist = size * 2.5 + j * (size * 1.5) + seededRandom() * 3;
                    const mSpeed = 0.03 + seededRandom() * 0.03;
                    const moonName = generateMoonName();

                    const mGeo = new THREE.SphereGeometry(mSize, 32, 32);
                    const mMat = new THREE.MeshStandardMaterial({
                        map: createMoonTexture(),
                        roughness: 0.9
                    });
                    const moon = new THREE.Mesh(mGeo, mMat);

                    const moonData = {
                        name: moonName,
                        radius: mSize,
                        distance: mDist,
                        orbitalPeriod: Math.floor(mDist * 5) + ' hours',
                        description: moonDescriptions[Math.floor(seededRandom() * moonDescriptions.length)],
                        parentPlanet: planetData.name
                    };

                    moon.userData = { type: 'moon', data: moonData, parentIndex: i };
                    allClickableObjects.push(moon);

                    planet.add(moon);
                    moons.push({
                        mesh: moon,
                        dist: mDist,
                        speed: mSpeed,
                        angle: seededRandom() * Math.PI * 2,
                        data: moonData
                    });

                    planetData.moons.push(moonData);
                }

                // Rings for some gas giants
                if (type === 'gas' && seededRandom() > 0.6) {
                    const ringGeo = new THREE.RingGeometry(size * 1.4, size * 2.2, 64);
                    const ringMat = new THREE.MeshBasicMaterial({
                        color: 0xccbbaa,
                        side: THREE.DoubleSide,
                        transparent: true,
                        opacity: 0.5
                    });
                    const ring = new THREE.Mesh(ringGeo, ringMat);
                    ring.rotation.x = Math.PI / 2 + (seededRandom() - 0.5) * 0.3;
                    planet.add(ring);
                    planetData.hasRings = true;
                }

                scene.add(planet);
                planets.push({
                    mesh: planet,
                    dist: dist,
                    speed: speed,
                    angle: seededRandom() * Math.PI * 2,
                    orbitLine: orbitLine,
                    moons: moons,
                    data: planetData
                });
            }

            // Update UI (sanitized for XSS prevention)
            document.getElementById('system-stats').innerHTML = `
                <strong>System:</strong> ${escapeHTML(starData.systemName)}<br>
                <strong>Star:</strong> ${escapeHTML(starType.name)} (${escapeHTML(starType.temp)})<br>
                <strong>Planets:</strong> ${numPlanets}
            `;

            // Reset camera
            camera.position.set(0, 150, 300);
            camera.lookAt(0, 0, 0);
            controls.target.set(0, 0, 0);

            // ARIA announcement for new system with detailed info
            if (typeof announce === 'function') {
                const totalMoons = planets.reduce((sum, p) => sum + (p.moons ? p.moons.length : 0), 0);
                const gasGiants = planets.filter(p => p.data.type === 'gas').length;
                const rockyPlanets = planets.filter(p => p.data.type === 'rocky').length;
                announce(`New solar system generated: ${starData.systemName}. ${starType.name} star with ${numPlanets} planets (${rockyPlanets} rocky, ${gasGiants} gas giants) and ${totalMoons} moons. Press arrow keys to navigate.`);
            }
        }

        // ========================================
        // CAMERA TRANSITIONS
        // ========================================
        function focusOnObject(object, viewType) {
            if (isTransitioning) return;

            isTransitioning = true;
            document.body.classList.add('transitioning');

            const data = object.userData.data;
            currentView = viewType;
            focusedObject = object;

            // Calculate target position based on object type
            let targetPos, targetLook;

            if (viewType === 'planet') {
                const planetPos = new THREE.Vector3();
                object.getWorldPosition(planetPos);
                const distance = data.radius * 6;

                targetPos = new THREE.Vector3(
                    planetPos.x + distance,
                    planetPos.y + distance * 0.5,
                    planetPos.z + distance
                );
                targetLook = planetPos;

                // Show detail panel
                showDetailPanel(data, 'planet');

            } else if (viewType === 'moon') {
                const moonPos = new THREE.Vector3();
                object.getWorldPosition(moonPos);
                const distance = data.radius * 15;

                targetPos = new THREE.Vector3(
                    moonPos.x + distance,
                    moonPos.y + distance * 0.3,
                    moonPos.z + distance
                );
                targetLook = moonPos;

                // Show detail panel for moon
                showDetailPanel(data, 'moon');

            } else if (viewType === 'star') {
                // Null check: starData may not exist if generation failed
                if (!starData || !starData.scale) {
                    console.warn('Star data not available for focus');
                    isTransitioning = false;
                    document.body.classList.remove('transitioning');
                    return;
                }
                const distance = starData.scale * 5;
                targetPos = new THREE.Vector3(distance, distance * 0.5, distance);
                targetLook = new THREE.Vector3(0, 0, 0);

                showDetailPanel(starData, 'star');
            }

            targetCameraPosition = targetPos;
            targetLookAt = targetLook;

            // Update UI
            document.getElementById('view-mode').classList.add('visible');
            document.getElementById('view-target').textContent = data.name;
            document.getElementById('back-btn').classList.add('visible');

            // Enable auto-rotate for nice orbit view
            setTimeout(() => {
                controls.autoRotate = true;
                controls.autoRotateSpeed = 0.5;
            }, 1500);
        }

        function returnToSystemView() {
            if (isTransitioning) return;

            isTransitioning = true;
            document.body.classList.add('transitioning');

            currentView = 'system';
            focusedObject = null;
            cameraOffset = null; // Reset offset
            controls.autoRotate = false;

            targetCameraPosition = new THREE.Vector3(0, 150, 300);
            targetLookAt = new THREE.Vector3(0, 0, 0);

            document.getElementById('detail-panel').classList.remove('visible');
            document.getElementById('view-mode').classList.remove('visible');
            document.getElementById('back-btn').classList.remove('visible');
        }

        function showDetailPanel(data, type) {
            const panel = document.getElementById('detail-panel');
            const nameEl = document.getElementById('detail-name');
            const statsEl = document.getElementById('detail-stats');
            const descEl = document.getElementById('detail-description');
            const moonsSection = document.getElementById('moons-section');
            const moonsList = document.getElementById('moons-list');

            nameEl.textContent = data.name;

            if (type === 'star') {
                statsEl.innerHTML = `
                    <div class="stat-row"><span class="stat-label">Type</span><span class="stat-value">${escapeHTML(data.name)}</span></div>
                    <div class="stat-row"><span class="stat-label">Temperature</span><span class="stat-value">${escapeHTML(data.temp)}</span></div>
                    <div class="stat-row"><span class="stat-label">Age</span><span class="stat-value">${escapeHTML(data.age)}</span></div>
                    <div class="stat-row"><span class="stat-label">Radius</span><span class="stat-value">${escapeHTML(data.scale)} solar units</span></div>
                `;
                descEl.textContent = "The central star of this system, providing light and warmth to all orbiting bodies.";
                moonsSection.style.display = 'none';

            } else if (type === 'planet') {
                statsEl.innerHTML = `
                    <div class="stat-row"><span class="stat-label">Type</span><span class="stat-value">${data.type === 'gas' ? 'Gas Giant' : 'Terrestrial'}</span></div>
                    <div class="stat-row"><span class="stat-label">Radius</span><span class="stat-value">${escapeHTML(data.radius.toFixed(1))} Earth radii</span></div>
                    <div class="stat-row"><span class="stat-label">Orbital Distance</span><span class="stat-value">${escapeHTML(data.distance.toFixed(0))} AU</span></div>
                    <div class="stat-row"><span class="stat-label">Orbital Period</span><span class="stat-value">${escapeHTML(data.orbitalPeriod)}</span></div>
                    <div class="stat-row"><span class="stat-label">Temperature</span><span class="stat-value">${escapeHTML(data.temperature)}</span></div>
                    ${data.hasRings ? '<div class="stat-row"><span class="stat-label">Features</span><span class="stat-value">Ring System</span></div>' : ''}
                `;
                descEl.textContent = data.description;

                // Show moons if any
                if (data.moons && data.moons.length > 0) {
                    moonsSection.style.display = 'block';
                    moonsList.setAttribute('role', 'listbox');
                    moonsList.setAttribute('aria-label', 'Moons of ' + escapeHTML(data.name));
                    // Store current planet name for event delegation
                    moonsList.setAttribute('data-planet-name', data.name);
                    moonsList.innerHTML = data.moons.map((moon, idx) => `
                        <div class="moon-item" data-moon-index="${idx}" role="option" tabindex="0"
                             aria-label="${escapeHTML(moon.name)}, click or press Enter to zoom">
                            <span>${escapeHTML(moon.name)}</span>
                            <span class="zoom-hint">Click to zoom</span>
                        </div>
                    `).join('');
                } else {
                    moonsSection.style.display = 'none';
                }

            } else if (type === 'moon') {
                statsEl.innerHTML = `
                    <div class="stat-row"><span class="stat-label">Parent</span><span class="stat-value">${escapeHTML(data.parentPlanet)}</span></div>
                    <div class="stat-row"><span class="stat-label">Radius</span><span class="stat-value">${escapeHTML(data.radius.toFixed(2))} Earth radii</span></div>
                    <div class="stat-row"><span class="stat-label">Orbital Distance</span><span class="stat-value">${escapeHTML(data.distance.toFixed(1))} planet radii</span></div>
                    <div class="stat-row"><span class="stat-label">Orbital Period</span><span class="stat-value">${escapeHTML(data.orbitalPeriod)}</span></div>
                `;
                descEl.textContent = data.description;
                moonsSection.style.display = 'none';
            }

            panel.classList.add('visible');
        }

        // ========================================
        // ANIMATION LOOP
        // ========================================
        function animate() {
            requestAnimationFrame(animate);

            // Skip physics updates when paused (but still render)
            if (!isPaused) {
                const delta = 0.016 * timeSpeed;

                // Animate planets
                planets.forEach(p => {
                    p.angle += p.speed * timeSpeed;
                    p.mesh.position.x = Math.cos(p.angle) * p.dist;
                    p.mesh.position.z = Math.sin(p.angle) * p.dist;
                    p.mesh.rotation.y += 0.005 * timeSpeed;

                    // Animate moons
                    if (p.moons) {
                        p.moons.forEach(m => {
                            m.angle += m.speed * timeSpeed;
                            m.mesh.position.x = Math.cos(m.angle) * m.dist;
                            m.mesh.position.z = Math.sin(m.angle) * m.dist;
                            m.mesh.rotation.y += 0.01 * timeSpeed;
                        });
                    }
                });

                // Star pulsing
                if (star) {
                    const pulse = 1 + Math.sin(Date.now() * 0.002) * 0.02;
                    star.scale.set(pulse, pulse, pulse);
                }
            }

            // Camera transition
            if (targetCameraPosition && targetLookAt) {
                const lerpFactor = 0.03;

                camera.position.lerp(targetCameraPosition, lerpFactor);
                controls.target.lerp(targetLookAt, lerpFactor);

                // Check if close enough
                if (camera.position.distanceTo(targetCameraPosition) < 1) {
                    // Store the offset from focused object when transition completes
                    if (focusedObject) {
                        focusedObject.getWorldPosition(_tempVec3_objectPos);
                        cameraOffset = camera.position.clone().sub(_tempVec3_objectPos);
                    }
                    targetCameraPosition = null;
                    targetLookAt = null;
                    isTransitioning = false;
                    document.body.classList.remove('transitioning');
                }
            }

            // If focused on a moving object, update camera to follow it
            if (focusedObject && currentView !== 'system' && !isTransitioning && cameraOffset) {
                focusedObject.getWorldPosition(_tempVec3_objectPos);

                // Update camera position to maintain offset from object (reuse temp vector)
                _tempVec3_targetCamPos.copy(_tempVec3_objectPos).add(cameraOffset);
                camera.position.lerp(_tempVec3_targetCamPos, 0.1);

                // Update controls target to look at object
                controls.target.lerp(_tempVec3_objectPos, 0.1);
            }

            controls.update();
            renderer.render(scene, camera);

            // Update floating labels every few frames for performance
            if (typeof updateLabels === 'function' && Math.random() < 0.1) {
                updateLabels();
            }
        }

        // ========================================
        // EVENT HANDLERS
        // ========================================
        function onMouseClick(event) {
            if (isTransitioning) return;

            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(allClickableObjects, false);

            if (intersects.length > 0) {
                const clicked = intersects[0].object;
                const type = clicked.userData.type;

                if (type === 'planet') {
                    focusOnObject(clicked, 'planet');
                } else if (type === 'moon') {
                    focusOnObject(clicked, 'moon');
                } else if (type === 'star') {
                    focusOnObject(clicked, 'star');
                }
            }
        }

        function onMouseMove(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(allClickableObjects, false);

            document.body.style.cursor = intersects.length > 0 ? 'pointer' : 'grab';
        }

        // ========================================
        // INITIALIZATION
        // ========================================
        camera.position.set(0, 150, 300);
        camera.lookAt(0, 0, 0);

        // Check for seed in URL (for shared links) - URL seed takes priority
        const urlSeed = checkURLSeed();
        const hasUrlSeed = urlSeed !== null;
        generateSystem(urlSeed);

        // Show guided tour for first-time visitors
        initTour();

        animate();

        // Event Listeners
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        renderer.domElement.addEventListener('click', onMouseClick);
        renderer.domElement.addEventListener('mousemove', onMouseMove);

        document.getElementById('generate-btn').addEventListener('click', () => generateSystem());

        // Share button handler
        document.getElementById('share-btn').addEventListener('click', copyShareLink);

        document.getElementById('toggle-orbits').addEventListener('click', () => {
            showOrbits = !showOrbits;
            planets.forEach(p => p.orbitLine.visible = showOrbits);
            updateToggleButtonStates();
            showNotification(`Orbit lines: ${showOrbits ? 'ON' : 'OFF'}`);
        });

        document.getElementById('toggle-labels').addEventListener('click', () => {
            showLabels = !showLabels;
            updateToggleButtonStates();
            showNotification(`Labels: ${showLabels ? 'ON' : 'OFF'}`);
        });

        document.getElementById('speed-btn').addEventListener('click', () => {
            const speeds = APP_CONFIG.SPEED_PRESETS;
            const currentIdx = speeds.indexOf(timeSpeed);
            timeSpeed = speeds[(currentIdx + 1) % speeds.length];
            document.getElementById('speed-btn').textContent = `Speed: ${timeSpeed}x`;
            showNotification(`Simulation speed: ${timeSpeed}x`);
        });

        document.getElementById('back-btn').addEventListener('click', returnToSystemView);

        // Event delegation for moon list (avoids listener accumulation)
        const moonsList = document.getElementById('moons-list');
        function handleMoonInteraction(e) {
            const moonItem = e.target.closest('.moon-item');
            if (!moonItem) return;

            const planetName = moonsList.getAttribute('data-planet-name');
            const moonIdx = parseInt(moonItem.getAttribute('data-moon-index'));
            const planet = planets.find(p => p.data.name === planetName);

            // Bounds check: validate planet exists, moons array exists, and index is valid
            if (planet && Array.isArray(planet.moons) &&
                moonIdx >= 0 && moonIdx < planet.moons.length &&
                planet.moons[moonIdx] && planet.moons[moonIdx].mesh) {
                focusOnObject(planet.moons[moonIdx].mesh, 'moon');
            }
        }
        moonsList.addEventListener('click', handleMoonInteraction);
        moonsList.addEventListener('keydown', (e) => {
            const moonItem = e.target.closest('.moon-item');
            if (!moonItem) return;

            if (e.key === 'Enter' || e.key === ' ') {
                e.preventDefault();
                handleMoonInteraction(e);
            }
            if (e.key === 'ArrowDown') {
                e.preventDefault();
                const next = moonItem.nextElementSibling;
                if (next) next.focus();
            }
            if (e.key === 'ArrowUp') {
                e.preventDefault();
                const prev = moonItem.previousElementSibling;
                if (prev) prev.focus();
            }
        });

        // ========================================
        // PAUSE/PLAY CONTROL
        // ========================================
        const pauseBtn = document.getElementById('pause-btn');
        const pauseIndicator = document.getElementById('pause-indicator');

        function togglePause() {
            isPaused = !isPaused;
            pauseBtn.textContent = isPaused ? '⏵' : '⏸';
            pauseBtn.classList.toggle('paused', isPaused);
            pauseBtn.setAttribute('aria-pressed', isPaused);
            pauseBtn.setAttribute('aria-label', isPaused ? 'Resume simulation' : 'Pause simulation');
            pauseIndicator.classList.toggle('visible', isPaused);

            // Announce to screen readers
            pauseIndicator.textContent = isPaused ? '⏸ PAUSED' : '⏵ PLAYING';

            // Visual feedback notification
            showNotification(isPaused ? '⏸ Simulation paused' : '⏵ Simulation resumed');

            // ARIA announcement
            if (typeof announce === 'function') {
                announce(isPaused ? 'Simulation paused' : 'Simulation resumed');
            }
        }

        pauseBtn.addEventListener('click', togglePause);

        // Visual toggle button state indicators
        function updateToggleButtonStates() {
            const orbitsBtn = document.getElementById('toggle-orbits');
            const labelsBtn = document.getElementById('toggle-labels');

            // Update Orbits button
            orbitsBtn.textContent = showOrbits ? 'Orbits: ON' : 'Orbits: OFF';
            orbitsBtn.classList.toggle('active', showOrbits);
            orbitsBtn.setAttribute('aria-pressed', showOrbits);

            // Update Labels button
            labelsBtn.textContent = showLabels ? 'Labels: ON' : 'Labels: OFF';
            labelsBtn.classList.toggle('active', showLabels);
            labelsBtn.setAttribute('aria-pressed', showLabels);
        }

        // Initialize toggle button states
        updateToggleButtonStates();

        // ========================================
        // ARIA ANNOUNCER
        // ========================================
        const ariaAnnouncer = document.getElementById('aria-announcer');
        let announcementTimeout = null;

        function announce(message) {
            // Debounce announcements to avoid spam
            if (announcementTimeout) clearTimeout(announcementTimeout);
            announcementTimeout = setTimeout(() => {
                ariaAnnouncer.textContent = message;
                // Clear after announcement is read
                setTimeout(() => { ariaAnnouncer.textContent = ''; }, 1000);
            }, 200);
        }

        // ========================================
        // HAPTIC FEEDBACK
        // ========================================
        function hapticFeedback(type = 'light') {
            if (!navigator.vibrate) return;
            switch(type) {
                case 'light': navigator.vibrate(10); break;
                case 'medium': navigator.vibrate(25); break;
                case 'heavy': navigator.vibrate([50, 30, 50]); break;
                case 'success': navigator.vibrate([10, 50, 10]); break;
            }
        }

        // ========================================
        // FLOATING LABELS
        // ========================================
        const labelsContainer = document.getElementById('labels-container');
        let labelElements = [];

        function createLabel(name, type) {
            const label = document.createElement('div');
            label.className = `celestial-label ${type}`;
            label.textContent = name;
            labelsContainer.appendChild(label);
            return label;
        }

        // Performance budget: throttle label updates
        let lastLabelUpdate = 0;
        const LABEL_UPDATE_INTERVAL = 100; // Update labels every 100ms

        function updateLabels() {
            if (!showLabels || currentView !== 'system') {
                labelsContainer.style.display = 'none';
                return;
            }

            // Throttle label updates for performance
            const now = performance.now();
            if (now - lastLabelUpdate < LABEL_UPDATE_INTERVAL) {
                return;
            }
            lastLabelUpdate = now;

            labelsContainer.style.display = 'block';

            // Clear old labels
            labelsContainer.innerHTML = '';

            // Collect all celestial bodies with their screen positions and distances
            const bodies = [];

            // Add star
            if (star) {
                // Reuse pooled Vector3 to avoid per-call allocations
                star.getWorldPosition(_tempVec3_labelPos);
                _tempVec3_labelScreen.copy(_tempVec3_labelPos).project(camera);
                const dist = _tempVec3_labelPos.distanceTo(camera.position);
                if (_tempVec3_labelScreen.z < 1) { // Only if in front of camera
                    bodies.push({
                        name: starData.systemName.split(' ')[0],
                        type: 'star',
                        x: (_tempVec3_labelScreen.x * 0.5 + 0.5) * window.innerWidth,
                        y: (-_tempVec3_labelScreen.y * 0.5 + 0.5) * window.innerHeight,
                        dist: dist
                    });
                }
            }

            // Add planets - reuse pooled Vector3s
            planets.forEach(p => {
                p.mesh.getWorldPosition(_tempVec3_labelPos);
                _tempVec3_labelScreen.copy(_tempVec3_labelPos).project(camera);
                const dist = _tempVec3_labelPos.distanceTo(camera.position);
                if (_tempVec3_labelScreen.z < 1) {
                    bodies.push({
                        name: p.data.name.split(' ')[0].split('-')[0],
                        type: 'planet',
                        x: (_tempVec3_labelScreen.x * 0.5 + 0.5) * window.innerWidth,
                        y: (-_tempVec3_labelScreen.y * 0.5 + 0.5) * window.innerHeight,
                        dist: dist
                    });
                }
            });

            // Sort by distance and show closest labels
            bodies.sort((a, b) => a.dist - b.dist);
            const visibleBodies = bodies.slice(0, APP_CONFIG.MAX_VISIBLE_LABELS);

            visibleBodies.forEach(body => {
                // Skip if off screen
                if (body.x < 0 || body.x > window.innerWidth || body.y < 0 || body.y > window.innerHeight) return;

                const label = createLabel(body.name, body.type);
                label.style.left = body.x + 'px';
                label.style.top = body.y + 'px';

                // Fade based on distance
                const opacity = Math.max(0.3, 1 - (body.dist / 500));
                label.style.opacity = opacity;
            });
        }

        // ========================================
        // TOUCH SUPPORT
        // ========================================
        let touchStartTime = 0;
        let touchStartPos = { x: 0, y: 0 };

        function onTouchStart(event) {
            if (event.touches.length === 1) {
                touchStartTime = Date.now();
                touchStartPos.x = event.touches[0].clientX;
                touchStartPos.y = event.touches[0].clientY;
            }
        }

        function onTouchEnd(event) {
            const touchDuration = Date.now() - touchStartTime;
            if (event.changedTouches.length !== 1) return;

            const touch = event.changedTouches[0];
            const deltaX = touch.clientX - touchStartPos.x;
            const deltaY = touch.clientY - touchStartPos.y;
            const moveDistance = Math.hypot(deltaX, deltaY);

            // If it's a tap (short duration, minimal movement)
            if (touchDuration < 300 && moveDistance < 20) {
                handleTap(touch.clientX, touch.clientY);
                return;
            }

            // Swipe detection (minimum 50px, completed within 400ms)
            if (touchDuration < 400 && moveDistance > 50) {
                const absX = Math.abs(deltaX);
                const absY = Math.abs(deltaY);

                // Horizontal swipe (left/right to navigate planets)
                if (absX > absY && currentView === 'system') {
                    if (deltaX < 0) {
                        // Swipe left - next planet
                        selectedPlanetIndex = Math.min(selectedPlanetIndex + 1, planets.length);
                        if (selectedPlanetIndex < 0) selectedPlanetIndex = 0;
                        updatePlanetSelector();
                        hapticFeedback('light');
                        showNotification(`Planet ${selectedPlanetIndex} selected`);
                    } else {
                        // Swipe right - previous planet
                        selectedPlanetIndex = Math.max(selectedPlanetIndex - 1, 0);
                        updatePlanetSelector();
                        hapticFeedback('light');
                        showNotification(`Planet ${selectedPlanetIndex} selected`);
                    }
                }

                // Vertical swipe
                if (absY > absX) {
                    if (deltaY < 0 && currentView === 'system' && selectedPlanetIndex >= 0) {
                        // Swipe up - zoom to selected planet
                        if (selectedPlanetIndex === 0 && star) {
                            focusOnObject(star, 'star');
                        } else if (selectedPlanetIndex > 0 && selectedPlanetIndex <= planets.length) {
                            focusOnObject(planets[selectedPlanetIndex - 1].mesh, 'planet');
                        }
                        hapticFeedback('medium');
                    } else if (deltaY > 0 && currentView !== 'system') {
                        // Swipe down - return to system view
                        returnToSystemView();
                        hapticFeedback('medium');
                    }
                }
            }
        }

        function handleTap(clientX, clientY) {
            if (isTransitioning) return;

            mouse.x = (clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(allClickableObjects, false);

            if (intersects.length > 0) {
                const clicked = intersects[0].object;
                const type = clicked.userData.type;

                hapticFeedback('medium');

                if (type === 'planet') {
                    focusOnObject(clicked, 'planet');
                    announce(`Zooming to planet ${clicked.userData.data.name}`);
                } else if (type === 'moon') {
                    focusOnObject(clicked, 'moon');
                    announce(`Zooming to moon ${clicked.userData.data.name}`);
                } else if (type === 'star') {
                    focusOnObject(clicked, 'star');
                    announce(`Zooming to star`);
                }
            }
        }

        // Double-tap to pause on touch devices
        let lastTapTime = 0;
        function handleDoubleTap(event) {
            const now = Date.now();
            if (now - lastTapTime < 300) {
                togglePause();
                hapticFeedback('heavy');
                event.preventDefault();
            }
            lastTapTime = now;
        }

        if (isTouchDevice) {
            renderer.domElement.addEventListener('touchstart', onTouchStart, { passive: true });
            renderer.domElement.addEventListener('touchend', onTouchEnd, { passive: true });
            // Double-tap for pause (on empty area)
            document.body.addEventListener('touchend', (e) => {
                if (e.target === document.body || e.target === renderer.domElement) {
                    handleDoubleTap(e);
                }
            }, { passive: false });
        }

        // ========================================
        // KEYBOARD NAVIGATION & SELECTION
        // ========================================
        let selectedPlanetIndex = -1; // -1 = none, 0 = star, 1-9 = planets
        let lastAnnouncedPlanetIndex = -1; // Track to avoid repeat announcements
        const planetSelector = document.getElementById('planet-selector');
        const keyboardHelp = document.getElementById('keyboard-help');

        function updatePlanetSelector() {
            if (selectedPlanetIndex < 0 || isTransitioning) {
                planetSelector.classList.remove('visible');
                return;
            }

            let targetObject;
            if (selectedPlanetIndex === 0) {
                // Null check: star may not exist during initialization
                if (!star) {
                    planetSelector.classList.remove('visible');
                    return;
                }
                targetObject = star;
            } else if (selectedPlanetIndex > 0 && selectedPlanetIndex <= planets.length) {
                const planet = planets[selectedPlanetIndex - 1];
                if (!planet || !planet.mesh) {
                    planetSelector.classList.remove('visible');
                    return;
                }
                targetObject = planet.mesh;
            } else {
                planetSelector.classList.remove('visible');
                return;
            }

            // Reuse pooled Vector3 to avoid per-frame allocation
            targetObject.getWorldPosition(_tempVec3_objectPos);
            _tempVec3_objectPos.project(camera);

            const x = (_tempVec3_objectPos.x * 0.5 + 0.5) * window.innerWidth;
            const y = (-_tempVec3_objectPos.y * 0.5 + 0.5) * window.innerHeight;

            planetSelector.style.left = x + 'px';
            planetSelector.style.top = y + 'px';
            planetSelector.style.transform = 'translate(-50%, -50%)';
            planetSelector.classList.add('visible');

            // Screen reader announcement on selection change
            if (selectedPlanetIndex !== lastAnnouncedPlanetIndex) {
                lastAnnouncedPlanetIndex = selectedPlanetIndex;
                if (selectedPlanetIndex === 0 && starData) {
                    announce(`Star: ${starData.systemName}, ${starData.name || 'unknown type'}`);
                } else if (selectedPlanetIndex > 0 && selectedPlanetIndex <= planets.length) {
                    const p = planets[selectedPlanetIndex - 1];
                    const data = p.mesh.userData.data;
                    const moonCount = data.moons ? data.moons.length : 0;
                    announce(`Planet ${selectedPlanetIndex}: ${data.name}, ${data.type}, distance ${data.distance.toFixed(0)} AU, ${moonCount} moon${moonCount !== 1 ? 's' : ''}`);
                }
            }
        }

        function selectAndZoom() {
            if (selectedPlanetIndex === 0 && star) {
                focusOnObject(star, 'star');
            } else if (selectedPlanetIndex > 0 && selectedPlanetIndex <= planets.length) {
                focusOnObject(planets[selectedPlanetIndex - 1].mesh, 'planet');
            }
        }

        // Enhanced keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            // Don't handle if typing in an input
            if (e.target.tagName === 'INPUT') return;

            const key = e.key.toLowerCase();

            // Escape - return to system view
            if (e.key === 'Escape') {
                if (currentView !== 'system') {
                    returnToSystemView();
                }
                selectedPlanetIndex = -1;
                updatePlanetSelector();
            }

            // G - generate new system
            if (key === 'g') {
                generateSystem(); // Will generate new random seed
                selectedPlanetIndex = -1;
                updatePlanetSelector();
            }

            // O - toggle orbits
            if (key === 'o') {
                showOrbits = !showOrbits;
                planets.forEach(p => p.orbitLine.visible = showOrbits);
                updateToggleButtonStates();
                showNotification(`Orbit lines: ${showOrbits ? 'ON' : 'OFF'}`);
            }

            // L - toggle labels
            if (key === 'l') {
                showLabels = !showLabels;
                updateToggleButtonStates();
                showNotification(`Labels: ${showLabels ? 'ON' : 'OFF'}`);
            }

            // Space - pause/play
            if (e.key === ' ' && e.target === document.body) {
                e.preventDefault();
                togglePause();
            }

            // P - also pause/play
            if (key === 'p') {
                togglePause();
            }

            // S - save system
            if (key === 's' && !e.ctrlKey && !e.metaKey) {
                saveSystem();
            }

            // C - capture screenshot
            if (key === 'c') {
                captureScreenshot();
            }

            // ? or / - toggle keyboard help
            if (e.key === '?' || (e.key === '/' && e.shiftKey)) {
                keyboardHelp.classList.toggle('visible');
            }

            // Number keys 0-9 for planet selection
            if (/^[0-9]$/.test(e.key) && currentView === 'system') {
                selectedPlanetIndex = parseInt(e.key);
                if (selectedPlanetIndex > planets.length) {
                    selectedPlanetIndex = planets.length;
                }
                updatePlanetSelector();
            }

            // Enter - zoom to selected planet
            if (e.key === 'Enter' && selectedPlanetIndex >= 0) {
                selectAndZoom();
            }

            // Arrow keys for planet navigation
            if (e.key === 'ArrowRight' && currentView === 'system') {
                selectedPlanetIndex = Math.min(selectedPlanetIndex + 1, planets.length);
                if (selectedPlanetIndex < 0) selectedPlanetIndex = 0;
                updatePlanetSelector();
            }
            if (e.key === 'ArrowLeft' && currentView === 'system') {
                selectedPlanetIndex = Math.max(selectedPlanetIndex - 1, 0);
                updatePlanetSelector();
            }

            // +/- for speed control
            if (e.key === '+' || e.key === '=') {
                const speeds = APP_CONFIG.SPEED_PRESETS;
                const currentIdx = speeds.indexOf(timeSpeed);
                timeSpeed = speeds[Math.min(currentIdx + 1, speeds.length - 1)];
                document.getElementById('speed-btn').textContent = `Speed: ${timeSpeed}x`;
                showNotification(`Speed: ${timeSpeed}x`);
            }
            if (e.key === '-' || e.key === '_') {
                const speeds = APP_CONFIG.SPEED_PRESETS;
                const currentIdx = speeds.indexOf(timeSpeed);
                timeSpeed = speeds[Math.max(currentIdx - 1, 0)];
                document.getElementById('speed-btn').textContent = `Speed: ${timeSpeed}x`;
                showNotification(`Speed: ${timeSpeed}x`);
            }
        });

        // Update selector position during animation
        const originalAnimate = animate;
        function animateWithSelector() {
            originalAnimate();
            if (selectedPlanetIndex >= 0 && currentView === 'system') {
                updatePlanetSelector();
            }
        }

        // ========================================
        // DATA PERSISTENCE & IMPORT/EXPORT
        // ========================================
        function getSystemData() {
            return {
                version: '1.0.0',
                timestamp: new Date().toISOString(),
                seed: currentSeed, // Preserve seed for reproducibility
                star: starData,
                planets: planets.map(p => ({
                    data: p.data,
                    angle: p.angle,
                    dist: p.dist,
                    speed: p.speed,
                    moons: p.moons.map(m => ({
                        data: m.data,
                        angle: m.angle,
                        dist: m.dist,
                        speed: m.speed
                    }))
                })),
                settings: {
                    showOrbits,
                    showLabels,
                    timeSpeed
                }
            };
        }

        function saveSystem() {
            try {
                const data = getSystemData();
                localStorage.setItem(APP_CONFIG.STORAGE_KEY, JSON.stringify(data));
                showNotification('System saved to browser storage');
            } catch (err) {
                console.error('Failed to save:', err);
                showNotification('Failed to save system', true);
            }
        }

        function loadSystem() {
            try {
                const saved = localStorage.getItem(APP_CONFIG.STORAGE_KEY);
                if (saved) {
                    const data = JSON.parse(saved);
                    rebuildFromData(data);
                    showNotification('System loaded from browser storage');
                    return true;
                }
            } catch (err) {
                console.error('Failed to load:', err);
            }
            return false;
        }

        function exportSystem() {
            const data = getSystemData();
            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `solar-system-${starData?.systemName?.replace(/\s+/g, '-') || 'export'}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            showNotification('System exported as JSON');
        }

        // Screenshot capture mode
        function captureScreenshot() {
            // Hide all UI temporarily
            const uiElements = [
                document.getElementById('controls'),
                document.getElementById('info-panel'),
                document.getElementById('keyboard-help'),
                document.getElementById('planet-selector'),
                document.getElementById('seed-display'),
                document.querySelector('.notification'),
                document.getElementById('minimap-canvas')
            ].filter(el => el && el.style.display !== 'none' && el.classList);

            const hiddenStates = uiElements.map(el => {
                const wasVisible = !el.classList.contains('screenshot-hidden');
                el.classList.add('screenshot-hidden');
                return { el, wasVisible };
            });

            // Render one clean frame
            renderer.render(scene, camera);

            // Capture the canvas
            try {
                const dataUrl = renderer.domElement.toDataURL('image/png');
                const link = document.createElement('a');
                link.download = `solar-system-${starData?.systemName?.replace(/\s+/g, '-') || 'capture'}-${Date.now()}.png`;
                link.href = dataUrl;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                showNotification('Screenshot saved!');
            } catch (err) {
                console.error('Screenshot failed:', err);
                showNotification('Screenshot failed', true);
            }

            // Restore UI
            setTimeout(() => {
                hiddenStates.forEach(({ el }) => {
                    el.classList.remove('screenshot-hidden');
                });
            }, 100);
        }

        // Strict JSON schema validation
        function validateSystemData(data) {
            const errors = [];
            const { MAX_PLANETS, MAX_MOONS_PER_PLANET } = APP_CONFIG;

            // Version check
            if (typeof data.version !== 'string' || !data.version.match(/^\d+\.\d+(\.\d+)?$/)) {
                errors.push('Invalid or missing version');
            }

            // Star validation
            if (!data.star || typeof data.star !== 'object') {
                errors.push('Missing star data');
            } else {
                if (typeof data.star.scale !== 'number' || data.star.scale <= 0 || data.star.scale > 100) {
                    errors.push('Invalid star scale');
                }
                if (typeof data.star.color !== 'number' && typeof data.star.color !== 'string') {
                    errors.push('Invalid star color');
                }
                if (typeof data.star.systemName !== 'string' || data.star.systemName.length > 100) {
                    errors.push('Invalid system name');
                }
            }

            // Seed validation (optional field for backward compatibility)
            if (data.seed !== undefined) {
                if (typeof data.seed !== 'number' || !Number.isSafeInteger(data.seed) || data.seed < 0) {
                    errors.push('Invalid seed value');
                }
            }

            // Planets validation - FIX: Check nested data structure correctly
            if (!Array.isArray(data.planets)) {
                errors.push('Planets must be an array');
            } else if (data.planets.length > MAX_PLANETS) {
                errors.push(`Too many planets (max ${MAX_PLANETS})`);
            } else {
                data.planets.forEach((pData, i) => {
                    // Validate planet has required structure
                    if (!pData.data || typeof pData.data !== 'object') {
                        errors.push(`Planet ${i + 1}: missing data object`);
                        return;
                    }

                    const p = pData.data; // Access nested data

                    if (typeof p.name !== 'string' || p.name.length > 50) {
                        errors.push(`Planet ${i + 1}: invalid name`);
                    }
                    if (!['rocky', 'gas', 'terran', 'ice', 'dwarf'].includes(p.type)) {
                        errors.push(`Planet ${i + 1}: invalid type "${p.type}"`);
                    }
                    if (typeof p.radius !== 'number' || p.radius <= 0 || p.radius > 50) {
                        errors.push(`Planet ${i + 1}: invalid radius`);
                    }
                    if (typeof p.distance !== 'number' || p.distance <= 0 || p.distance > 1000) {
                        errors.push(`Planet ${i + 1}: invalid distance`);
                    }

                    // Validate moons array if present
                    if (pData.moons) {
                        if (!Array.isArray(pData.moons)) {
                            errors.push(`Planet ${i + 1}: moons must be an array`);
                        } else if (pData.moons.length > MAX_MOONS_PER_PLANET) {
                            errors.push(`Planet ${i + 1}: too many moons (max ${MAX_MOONS_PER_PLANET})`);
                        }
                    }
                });
            }

            return errors;
        }

        function importSystem(file) {
            // File size check
            if (file.size > APP_CONFIG.MAX_FILE_SIZE) {
                showNotification(`File too large (max ${APP_CONFIG.MAX_FILE_SIZE / 1000}KB)`, true);
                return;
            }

            const reader = new FileReader();

            // Cycle 1: Add error handler for file read failures
            reader.onerror = () => {
                showNotification('Failed to read file', true);
            };

            reader.onload = (e) => {
                try {
                    const data = JSON.parse(e.target.result);
                    const validationErrors = validateSystemData(data);

                    if (validationErrors.length > 0) {
                        console.error('Validation errors:', validationErrors);
                        showNotification(`Invalid file: ${validationErrors[0]}`, true);
                        return;
                    }

                    rebuildFromData(data);
                    showNotification('System imported successfully');
                } catch (err) {
                    console.error('Import failed:', err);
                    showNotification('Failed to import - invalid JSON', true);
                }
            };
            reader.readAsText(file);
        }

        function rebuildFromData(data) {
            // Clear existing system using shared cleanup function
            clearScene();

            // Reset view state
            currentView = 'system';
            focusedObject = null;
            cameraOffset = null;
            document.getElementById('detail-panel').classList.remove('visible');
            document.getElementById('back-btn').classList.remove('visible');
            document.getElementById('view-mode').classList.remove('visible');
            controls.autoRotate = false;

            // Restore seed if present (enables re-sharing imported systems)
            if (data.seed !== undefined) {
                currentSeed = data.seed;
                updateSeedDisplay();
            }

            // Rebuild star
            starData = data.star;
            const starGeo = new THREE.SphereGeometry(starData.scale, 64, 64);
            const starMat = new THREE.MeshBasicMaterial({
                color: starData.color,
                transparent: true,
                opacity: 0.95
            });
            star = new THREE.Mesh(starGeo, starMat);
            star.userData = { type: 'star', data: starData };
            scene.add(star);
            allClickableObjects.push(star);

            // Star glow
            const glowGeo = new THREE.SphereGeometry(starData.scale * 1.5, 32, 32);
            const glowMat = new THREE.MeshBasicMaterial({
                color: starData.color,
                transparent: true,
                opacity: 0.2,
                side: THREE.BackSide
            });
            star.add(new THREE.Mesh(glowGeo, glowMat));

            // Update point light to match imported star color/intensity
            pointLight.color.setHex(starData.color);
            pointLight.intensity = starData.scale / 5;

            // Rebuild planets
            data.planets.forEach((pData, i) => {
                const type = pData.data.type;
                const size = pData.data.radius;
                const dist = pData.dist;
                const colorHex = Math.random() * 0xffffff;

                const planetGeo = new THREE.SphereGeometry(size, 64, 64);
                const planetMat = new THREE.MeshStandardMaterial({
                    map: createPlanetTexture(type, '#' + new THREE.Color(colorHex).getHexString()),
                    roughness: type === 'gas' ? 0.9 : 0.7,
                    metalness: type === 'gas' ? 0 : 0.1
                });
                const planet = new THREE.Mesh(planetGeo, planetMat);
                planet.userData = { type: 'planet', data: pData.data, index: i };
                allClickableObjects.push(planet);

                // Orbit line
                const orbitGeo = new THREE.RingGeometry(dist - 0.3, dist + 0.3, 128);
                const orbitMat = new THREE.MeshBasicMaterial({
                    color: 0x444466,
                    side: THREE.DoubleSide,
                    transparent: true,
                    opacity: 0.3
                });
                const orbitLine = new THREE.Mesh(orbitGeo, orbitMat);
                orbitLine.rotation.x = Math.PI / 2;
                scene.add(orbitLine);

                // Moons
                const moons = [];
                if (pData.moons) {
                    pData.moons.forEach((mData, j) => {
                        const mGeo = new THREE.SphereGeometry(mData.data.radius, 32, 32);
                        const mMat = new THREE.MeshStandardMaterial({
                            map: createMoonTexture(),
                            roughness: 0.9
                        });
                        const moon = new THREE.Mesh(mGeo, mMat);
                        moon.userData = { type: 'moon', data: mData.data, parentIndex: i };
                        allClickableObjects.push(moon);
                        planet.add(moon);

                        moons.push({
                            mesh: moon,
                            dist: mData.dist,
                            speed: mData.speed,
                            angle: mData.angle,
                            data: mData.data
                        });
                    });
                }

                scene.add(planet);
                planets.push({
                    mesh: planet,
                    dist: dist,
                    speed: pData.speed,
                    angle: pData.angle,
                    orbitLine: orbitLine,
                    moons: moons,
                    data: pData.data
                });
            });

            // Restore settings
            if (data.settings) {
                showOrbits = data.settings.showOrbits;
                showLabels = data.settings.showLabels;
                timeSpeed = data.settings.timeSpeed;
                document.getElementById('speed-btn').textContent = `Speed: ${timeSpeed}x`;
                planets.forEach(p => p.orbitLine.visible = showOrbits);
            }

            // Update UI (sanitized for XSS prevention)
            document.getElementById('system-stats').innerHTML = `
                <strong>System:</strong> ${escapeHTML(starData.systemName)}<br>
                <strong>Star:</strong> ${escapeHTML(starData.name)} (${escapeHTML(starData.temp)})<br>
                <strong>Planets:</strong> ${planets.length}
            `;

            // Reset view
            currentView = 'system';
            focusedObject = null;
            camera.position.set(0, 150, 300);
            controls.target.set(0, 0, 0);
        }

        function showNotification(message, isError = false) {
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                left: 50%;
                transform: translateX(-50%);
                background: ${isError ? 'rgba(255, 100, 100, 0.9)' : 'rgba(78, 205, 196, 0.9)'};
                color: ${isError ? 'white' : 'black'};
                padding: 12px 24px;
                border-radius: 8px;
                font-size: 14px;
                font-weight: 500;
                z-index: 10000;
                animation: fadeInOut 2s ease-in-out forwards;
            `;
            notification.textContent = message;

            // Cycle 1: Announce to screen readers for accessibility
            if (typeof announce === 'function') {
                announce(message);
            }

            document.body.appendChild(notification);
            setTimeout(() => notification.remove(), 2000);
        }

        // Add notification animation
        const style = document.createElement('style');
        style.textContent = `
            @keyframes fadeInOut {
                0% { opacity: 0; transform: translateX(-50%) translateY(-10px); }
                15% { opacity: 1; transform: translateX(-50%) translateY(0); }
                85% { opacity: 1; transform: translateX(-50%) translateY(0); }
                100% { opacity: 0; transform: translateX(-50%) translateY(-10px); }
            }
        `;
        document.head.appendChild(style);

        // Event listeners for data controls
        document.getElementById('save-btn').addEventListener('click', saveSystem);
        document.getElementById('export-btn').addEventListener('click', exportSystem);
        document.getElementById('import-btn').addEventListener('click', () => {
            document.getElementById('import-file').click();
        });
        document.getElementById('import-file').addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                importSystem(e.target.files[0]);
                e.target.value = ''; // Reset for next import
            }
        });

        // Try to load saved system on startup - but NOT if URL seed was provided (shared links take priority)
        if (!hasUrlSeed && !loadSystem()) {
            // If no URL seed and no saved system, generate new one (already done above)
        }

        // ========================================
        // BROADCAST TRANSMISSION EFFECTS
        // ========================================
        const transmissionStartTime = Date.now();

        // Update transmission timestamp
        function updateTimestamp() {
            const elapsed = Date.now() - transmissionStartTime;
            const hours = Math.floor(elapsed / 3600000).toString().padStart(2, '0');
            const mins = Math.floor((elapsed % 3600000) / 60000).toString().padStart(2, '0');
            const secs = Math.floor((elapsed % 60000) / 1000).toString().padStart(2, '0');
            document.getElementById('tx-time').textContent = `${hours}:${mins}:${secs}`;
        }
        const timestampIntervalId = setInterval(updateTimestamp, 1000);

        // Interval and Timeout IDs for cleanup (prevents memory leaks)
        let interferenceTimeoutId = null;
        let glitchTimeoutId = null;

        // Occasional interference line
        function triggerInterference() {
            const line = document.getElementById('interference-line');
            if (!line) return;
            line.style.top = Math.random() * 100 + '%';
            line.classList.remove('active');
            void line.offsetWidth; // Force reflow
            line.classList.add('active');

            // Schedule next interference (rare: 8-25 seconds)
            interferenceTimeoutId = setTimeout(triggerInterference, 8000 + Math.random() * 17000);
        }
        interferenceTimeoutId = setTimeout(triggerInterference, 5000 + Math.random() * 10000);

        // Subtle signal strength fluctuation
        function fluctuateSignal() {
            // Defensive check: DOM element may not exist during cleanup
            const indicator = document.getElementById('transmission-indicator');
            if (!indicator) return;

            const bars = indicator.querySelectorAll('.signal-bar');
            if (!bars.length) return;

            bars.forEach((bar, i) => {
                const baseHeight = [4, 7, 10, 6][i];
                const fluctuation = (Math.random() - 0.5) * 3;
                bar.style.height = Math.max(2, baseHeight + fluctuation) + 'px';
                bar.style.opacity = 0.4 + Math.random() * 0.6;
            });
        }
        const signalIntervalId = setInterval(fluctuateSignal, 2000);

        // Very rare deep glitch effect on focused object name
        function triggerTextGlitch() {
            const viewTarget = document.getElementById('view-target');
            if (viewTarget && viewTarget.textContent) {
                viewTarget.setAttribute('data-text', viewTarget.textContent);
                viewTarget.classList.add('glitch-text', 'glitching');
                setTimeout(() => {
                    viewTarget.classList.remove('glitching');
                }, 300);
            }

            // Schedule next glitch (very rare: 20-60 seconds)
            glitchTimeoutId = setTimeout(triggerTextGlitch, 20000 + Math.random() * 40000);
        }
        glitchTimeoutId = setTimeout(triggerTextGlitch, 15000 + Math.random() * 20000);

        // Cleanup function for page unload (prevents orphaned timeouts and intervals)
        window.addEventListener('beforeunload', () => {
            if (interferenceTimeoutId) clearTimeout(interferenceTimeoutId);
            if (glitchTimeoutId) clearTimeout(glitchTimeoutId);
            clearInterval(timestampIntervalId);
            clearInterval(signalIntervalId);
        });

    </script>
</body>
</html>
