<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Confluence</title>
    <meta name="description" content="Boundaries dissolve and reform like watercolors, merging and separating in an eternal dance of connection and identity">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background: #0a0810; min-height: 100vh; font-family: 'Georgia', serif; color: #a090a0; overflow: hidden; }
        #canvas { position: fixed; top: 0; left: 0; cursor: crosshair; }
        #controls {
            position: fixed; top: 20px; left: 20px; background: rgba(15,12,20,0.95);
            padding: 20px; border-radius: 10px; border: 1px solid rgba(140,100,160,0.3);
            z-index: 100;
        }
        h3 { margin-bottom: 15px; color: #c0a0d0; font-weight: normal; }
        .control-row { margin: 10px 0; }
        label { display: block; font-size: 11px; margin-bottom: 5px; opacity: 0.8; }
        input[type="range"] { width: 140px; }
        .value { float: right; color: #d0b0e0; font-size: 12px; }
        button {
            display: block; width: 100%; padding: 10px; margin: 6px 0;
            background: rgba(80,60,100,0.4); border: 1px solid rgba(140,100,160,0.4);
            color: #a090b0; cursor: pointer; border-radius: 6px; font-family: inherit;
        }
        #region-count { position: fixed; top: 20px; right: 20px; font-size: 12px; color: #806080; z-index: 100; }
        #info { position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); font-size: 12px; opacity: 0.5; z-index: 100; }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div id="controls">
        <h3>Confluence</h3>
        <div class="control-row">
            <label>Dissolution Rate <span class="value" id="dissolve-val">50</span></label>
            <input type="range" id="dissolve" min="10" max="100" value="50">
        </div>
        <div class="control-row">
            <label>Reformation Speed <span class="value" id="reform-val">40</span></label>
            <input type="range" id="reform" min="10" max="100" value="40">
        </div>
        <button id="merge-btn">Force Merger</button>
        <button id="scatter-btn">Scatter Apart</button>
        <button id="reset-btn">Reset Field</button>
    </div>
    <div id="region-count">Regions: 0</div>
    <div id="info">Click to dissolve boundaries | Drag to sculpt regions | Watch them reform</div>
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        let W, H;
        function resize() { W = canvas.width = innerWidth; H = canvas.height = innerHeight; }
        resize(); window.onresize = resize;
        
        let dissolutionRate = 0.5;
        let reformationSpeed = 0.4;
        let time = 0;
        
        const regions = [];
        const particles = [];
        
        class Region {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.vx = (Math.random() - 0.5) * 0.5;
                this.vy = (Math.random() - 0.5) * 0.5;
                this.radius = 40 + Math.random() * 60;
                this.targetRadius = this.radius;
                this.hue = Math.random() * 360;
                this.saturation = 40 + Math.random() * 30;
                this.lightness = 30 + Math.random() * 20;
                this.opacity = 0;
                this.breathPhase = Math.random() * Math.PI * 2;
                this.dissolving = false;
                this.mergeTarget = null;
            }
            
            update() {
                this.breathPhase += 0.02;
                const breath = 1 + Math.sin(this.breathPhase) * 0.05;
                
                if (this.opacity < 1 && !this.dissolving) {
                    this.opacity += 0.02;
                }
                
                if (this.dissolving) {
                    this.opacity -= 0.02 * dissolutionRate;
                    this.radius *= 0.99;
                    
                    if (this.mergeTarget) {
                        const dx = this.mergeTarget.x - this.x;
                        const dy = this.mergeTarget.y - this.y;
                        this.vx += dx * 0.001;
                        this.vy += dy * 0.001;
                    }
                }
                
                this.radius += (this.targetRadius * breath - this.radius) * 0.05;
                
                this.x += this.vx;
                this.y += this.vy;
                
                this.vx *= 0.99;
                this.vy *= 0.99;
                
                this.vx += (Math.random() - 0.5) * 0.02;
                this.vy += (Math.random() - 0.5) * 0.02;
                
                if (this.x < this.radius) this.vx += 0.1;
                if (this.x > W - this.radius) this.vx -= 0.1;
                if (this.y < this.radius) this.vy += 0.1;
                if (this.y > H - this.radius) this.vy -= 0.1;
                
                return this.opacity > 0 && this.radius > 5;
            }
            
            draw() {
                const gradient = ctx.createRadialGradient(
                    this.x, this.y, 0,
                    this.x, this.y, this.radius * 1.5
                );
                
                const coreColor = "hsla(" + this.hue + ", " + this.saturation + "%, " + this.lightness + "%, " + (this.opacity * 0.8) + ")";
                const midColor = "hsla(" + this.hue + ", " + (this.saturation * 0.7) + "%, " + (this.lightness * 0.8) + "%, " + (this.opacity * 0.4) + ")";
                const edgeColor = "hsla(" + this.hue + ", " + (this.saturation * 0.5) + "%, " + (this.lightness * 0.5) + "%, 0)";
                
                gradient.addColorStop(0, coreColor);
                gradient.addColorStop(0.4, midColor);
                gradient.addColorStop(1, edgeColor);
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius * 1.5, 0, Math.PI * 2);
                ctx.fill();
            }
            
            containsPoint(x, y) {
                return Math.hypot(x - this.x, y - this.y) < this.radius;
            }
            
            distanceTo(other) {
                return Math.hypot(other.x - this.x, other.y - this.y);
            }
        }
        
        function initRegions() {
            regions.length = 0;
            const count = 8 + Math.floor(Math.random() * 5);
            
            for (let i = 0; i < count; i++) {
                regions.push(new Region(
                    100 + Math.random() * (W - 200),
                    100 + Math.random() * (H - 200)
                ));
            }
        }
        
        function checkMergers() {
            for (let i = 0; i < regions.length; i++) {
                for (let j = i + 1; j < regions.length; j++) {
                    const a = regions[i];
                    const b = regions[j];
                    
                    if (a.dissolving || b.dissolving) continue;
                    
                    const dist = a.distanceTo(b);
                    const overlap = (a.radius + b.radius) - dist;
                    
                    if (overlap > a.radius * 0.5 || overlap > b.radius * 0.5) {
                        const smaller = a.radius < b.radius ? a : b;
                        const larger = a.radius < b.radius ? b : a;
                        
                        smaller.dissolving = true;
                        smaller.mergeTarget = larger;
                        
                        larger.targetRadius = Math.sqrt(
                            larger.radius * larger.radius + smaller.radius * smaller.radius
                        );
                        
                        larger.hue = (larger.hue + smaller.hue) / 2;
                        
                        for (let k = 0; k < 10; k++) {
                            particles.push({
                                x: smaller.x + (Math.random() - 0.5) * smaller.radius,
                                y: smaller.y + (Math.random() - 0.5) * smaller.radius,
                                vx: (Math.random() - 0.5) * 2,
                                vy: (Math.random() - 0.5) * 2,
                                size: 3 + Math.random() * 3,
                                hue: smaller.hue,
                                life: 1
                            });
                        }
                    }
                }
            }
        }
        
        function spawnNewRegion() {
            if (regions.length < 15 && Math.random() < 0.002 * reformationSpeed) {
                regions.push(new Region(
                    Math.random() * W,
                    Math.random() * H
                ));
            }
        }
        
        function drawBackground() {
            ctx.fillStyle = '#0a0810';
            ctx.fillRect(0, 0, W, H);
            
            const pressureGradient = ctx.createRadialGradient(W/2, H/2, 0, W/2, H/2, Math.max(W, H) * 0.6);
            pressureGradient.addColorStop(0, 'rgba(30, 20, 40, 0.2)');
            pressureGradient.addColorStop(1, 'transparent');
            ctx.fillStyle = pressureGradient;
            ctx.fillRect(0, 0, W, H);
        }
        
        function drawParticles() {
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.life -= 0.02;
                
                if (p.life <= 0) {
                    particles.splice(i, 1);
                    continue;
                }
                
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size * p.life, 0, Math.PI * 2);
                ctx.fillStyle = "hsla(" + p.hue + ", 60%, 60%, " + p.life + ")";
                ctx.fill();
            }
        }
        
        function animate() {
            time += 0.016;
            
            drawBackground();
            
            checkMergers();
            spawnNewRegion();
            
            for (let i = regions.length - 1; i >= 0; i--) {
                if (!regions[i].update()) {
                    regions.splice(i, 1);
                }
            }
            
            regions.forEach(r => r.draw());
            drawParticles();
            
            document.getElementById('region-count').textContent = 'Regions: ' + regions.length;
            
            requestAnimationFrame(animate);
        }
        
        canvas.onclick = e => {
            if (e.clientX < 200 && e.clientY < 280) return;
            
            let clickedRegion = null;
            regions.forEach(r => {
                if (r.containsPoint(e.clientX, e.clientY)) {
                    clickedRegion = r;
                }
            });
            
            if (clickedRegion) {
                clickedRegion.dissolving = true;
                
                for (let i = 0; i < 15; i++) {
                    particles.push({
                        x: clickedRegion.x + (Math.random() - 0.5) * clickedRegion.radius * 2,
                        y: clickedRegion.y + (Math.random() - 0.5) * clickedRegion.radius * 2,
                        vx: (Math.random() - 0.5) * 3,
                        vy: (Math.random() - 0.5) * 3,
                        size: 4 + Math.random() * 4,
                        hue: clickedRegion.hue,
                        life: 1
                    });
                }
            } else {
                regions.push(new Region(e.clientX, e.clientY));
            }
        };
        
        let isDragging = false;
        let dragX = 0, dragY = 0;
        
        canvas.onmousedown = e => {
            if (e.clientX < 200 && e.clientY < 280) return;
            isDragging = true;
            dragX = e.clientX;
            dragY = e.clientY;
        };
        
        canvas.onmousemove = e => {
            if (!isDragging) return;
            
            const dx = e.clientX - dragX;
            const dy = e.clientY - dragY;
            
            regions.forEach(r => {
                const dist = Math.hypot(e.clientX - r.x, e.clientY - r.y);
                if (dist < r.radius * 2) {
                    const force = 1 - dist / (r.radius * 2);
                    r.vx += dx * 0.05 * force;
                    r.vy += dy * 0.05 * force;
                }
            });
            
            dragX = e.clientX;
            dragY = e.clientY;
        };
        
        canvas.onmouseup = () => { isDragging = false; };
        
        document.getElementById('dissolve').oninput = e => {
            dissolutionRate = e.target.value / 100;
            document.getElementById('dissolve-val').textContent = e.target.value;
        };
        
        document.getElementById('reform').oninput = e => {
            reformationSpeed = e.target.value / 100;
            document.getElementById('reform-val').textContent = e.target.value;
        };
        
        document.getElementById('merge-btn').onclick = () => {
            regions.forEach(r => {
                r.vx += (W/2 - r.x) * 0.01;
                r.vy += (H/2 - r.y) * 0.01;
            });
        };
        
        document.getElementById('scatter-btn').onclick = () => {
            regions.forEach(r => {
                r.vx += (r.x - W/2) * 0.02;
                r.vy += (r.y - H/2) * 0.02;
            });
        };
        
        document.getElementById('reset-btn').onclick = () => {
            initRegions();
            particles.length = 0;
        };
        
        initRegions();
        animate();
    </script>
</body>
</html>