<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GENESIS ARK: Odyssey of the Eternal Voyage</title>
    <meta name="description" content="AAA 3D generation ship simulation where AI colonists evolve language, culture, and mythology over 400 years">
    <!-- generation-ship, ai-evolution, emergent-culture, mythology, simulation, neural-network, civilization, 3d, three.js -->
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: #0a0a12;
            color: #e0e8f0;
            min-height: 100vh;
            overflow: hidden;
        }

        #container {
            display: grid;
            grid-template-columns: 280px 1fr 320px;
            grid-template-rows: auto 1fr auto;
            height: 100vh;
            gap: 1px;
            background: #1a1a2e;
        }

        header {
            grid-column: 1 / -1;
            background: linear-gradient(180deg, #12121f 0%, #0a0a15 100%);
            padding: 12px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #2a2a4a;
            z-index: 100;
        }

        h1 {
            font-size: 24px;
            background: linear-gradient(90deg, #4ecdc4, #44a08d, #a18cd1);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            letter-spacing: 3px;
        }

        .time-display {
            display: flex;
            gap: 20px;
            align-items: center;
        }

        .year-display {
            font-size: 28px;
            font-weight: 700;
            color: #4ecdc4;
            font-family: 'Courier New', monospace;
        }

        .generation-display {
            color: #a18cd1;
            font-size: 14px;
        }

        .progress-bar {
            width: 200px;
            height: 8px;
            background: #1a1a2e;
            border-radius: 4px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #4ecdc4, #a18cd1);
            transition: width 0.3s;
        }

        .controls {
            display: flex;
            gap: 10px;
        }

        button {
            background: #2a2a4a;
            border: 1px solid #3a3a5a;
            color: #e0e8f0;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 14px;
        }

        button:hover {
            background: #3a3a5a;
            border-color: #4ecdc4;
        }

        button.active {
            background: #4ecdc4;
            color: #0a0a12;
        }

        /* Cycle 4: Accessibility - focus-visible styles */
        button:focus-visible {
            outline: 2px solid #4ecdc4;
            outline-offset: 2px;
            box-shadow: 0 0 0 4px rgba(78, 205, 196, 0.3);
        }

        .tab:focus-visible {
            outline: 2px solid #4ecdc4;
            outline-offset: -2px;
        }

        .left-panel {
            background: #0f0f1a;
            padding: 15px;
            overflow-y: auto;
            z-index: 10;
        }

        .panel-title {
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 2px;
            color: #6a6a8a;
            margin-bottom: 15px;
            padding-bottom: 8px;
            border-bottom: 1px solid #2a2a4a;
        }

        .stat-group { margin-bottom: 20px; }

        .stat-row {
            display: flex;
            justify-content: space-between;
            padding: 6px 0;
            border-bottom: 1px solid #1a1a2e;
        }

        .stat-label { color: #8a8aaa; font-size: 13px; }
        .stat-value { color: #4ecdc4; font-weight: 600; font-size: 13px; }

        .faction-item {
            background: #1a1a2e;
            border-radius: 6px;
            padding: 10px;
            margin-bottom: 8px;
            border-left: 3px solid;
        }

        .faction-name { font-weight: 600; font-size: 14px; margin-bottom: 4px; }
        .faction-belief { font-size: 11px; color: #8a8aaa; font-style: italic; }
        .faction-members { font-size: 12px; color: #6a6a8a; margin-top: 4px; }

        .main-view {
            background: #050510;
            position: relative;
            overflow: hidden;
        }

        #threeCanvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        .view-overlay {
            position: absolute;
            bottom: 20px;
            left: 20px;
            display: flex;
            gap: 10px;
            z-index: 10;
        }

        .camera-controls {
            position: absolute;
            top: 20px;
            left: 20px;
            display: flex;
            flex-direction: column;
            gap: 5px;
            z-index: 10;
        }

        .right-panel {
            background: #0f0f1a;
            padding: 15px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            z-index: 10;
        }

        .tab-container {
            display: flex;
            gap: 2px;
            margin-bottom: 15px;
        }

        .tab {
            flex: 1;
            padding: 8px;
            text-align: center;
            background: #1a1a2e;
            border: none;
            color: #6a6a8a;
            font-size: 11px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .tab:first-child { border-radius: 6px 0 0 6px; }
        .tab:last-child { border-radius: 0 6px 6px 0; }
        .tab.active { background: #4ecdc4; color: #0a0a12; }
        .tab-content { display: none; }
        .tab-content.active { display: block; }

        .text-evolution {
            background: #1a1a2e;
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 10px;
            border: 1px solid #2a2a4a;
        }

        .text-original {
            font-size: 11px;
            color: #5a5a7a;
            margin-bottom: 8px;
            font-family: 'Courier New', monospace;
            padding: 8px;
            background: #0a0a15;
            border-radius: 4px;
        }

        .text-current { font-size: 13px; color: #d4a574; font-style: italic; line-height: 1.5; }
        .text-drift { font-size: 10px; color: #4ecdc4; margin-top: 6px; }

        .event-item {
            padding: 8px;
            border-left: 2px solid #4ecdc4;
            margin-bottom: 6px;
            background: #1a1a2e;
            border-radius: 0 4px 4px 0;
            font-size: 12px;
        }

        .event-year { color: #4ecdc4; font-weight: 600; }
        .event-text { color: #b0b8c0; margin-top: 4px; }

        .myth-card {
            background: linear-gradient(135deg, #1a1a2e 0%, #2a1a3e 100%);
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 10px;
            border: 1px solid #3a2a5a;
        }

        .myth-title { color: #d4a574; font-weight: 600; font-size: 14px; margin-bottom: 6px; }
        .myth-description { font-size: 12px; color: #a0a8b0; line-height: 1.5; }
        .myth-origin { font-size: 10px; color: #6a6a8a; margin-top: 8px; font-style: italic; }

        footer {
            grid-column: 1 / -1;
            background: #0a0a15;
            padding: 10px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-top: 1px solid #2a2a4a;
            font-size: 12px;
            color: #6a6a8a;
            z-index: 100;
        }

        .language-sample { font-family: 'Courier New', monospace; color: #a18cd1; }

        .language-panel {
            background: #1a1a2e;
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 15px;
        }

        .word-evolution { display: flex; align-items: center; gap: 8px; padding: 4px 0; font-size: 12px; }
        .word-original { color: #5a5a7a; font-family: monospace; }
        .word-arrow { color: #4ecdc4; }
        .word-current { color: #a18cd1; font-weight: 600; }

        .speed-controls { display: flex; gap: 5px; }
        .speed-btn { padding: 6px 12px; font-size: 12px; }

        /* Colonist Focus Panel */
        .colonist-focus {
            background: linear-gradient(135deg, #1a2a3a 0%, #1a1a2e 100%);
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
            border: 1px solid #3a4a5a;
        }

        .colonist-focus.hidden { display: none; }

        .colonist-portrait {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: linear-gradient(135deg, #4ecdc4, #a18cd1);
            margin: 0 auto 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            color: #0a0a12;
            font-weight: bold;
        }

        .colonist-focus-name {
            text-align: center;
            font-size: 18px;
            font-weight: 600;
            color: #4ecdc4;
            margin-bottom: 5px;
        }

        .colonist-focus-gen {
            text-align: center;
            font-size: 12px;
            color: #6a6a8a;
            margin-bottom: 15px;
        }

        .colonist-stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }

        .colonist-stat {
            background: #0a0a15;
            padding: 8px;
            border-radius: 4px;
            text-align: center;
        }

        .colonist-stat-label { font-size: 10px; color: #6a6a8a; }
        .colonist-stat-value { font-size: 14px; color: #4ecdc4; font-weight: 600; }

        .colonist-beliefs {
            margin-top: 10px;
            padding: 10px;
            background: #0a0a15;
            border-radius: 4px;
        }

        .colonist-beliefs-title { font-size: 11px; color: #6a6a8a; margin-bottom: 5px; }
        .colonist-beliefs-text { font-size: 12px; color: #a18cd1; font-style: italic; }

        .colonist-lineage {
            margin-top: 10px;
            font-size: 11px;
            color: #6a6a8a;
        }

        .neural-bar {
            height: 4px;
            background: #1a1a2e;
            border-radius: 2px;
            margin: 2px 0;
            overflow: hidden;
        }

        .neural-fill {
            height: 100%;
            border-radius: 2px;
            transition: width 0.3s;
        }

        /* Population graph */
        .pop-graph {
            height: 60px;
            background: #0a0a15;
            border-radius: 4px;
            margin-top: 10px;
        }

        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-track { background: #1a1a2e; }
        ::-webkit-scrollbar-thumb { background: #3a3a5a; border-radius: 3px; }

        /* 3D Ship hover info */
        .hover-info {
            position: absolute;
            background: rgba(10, 10, 18, 0.9);
            border: 1px solid #4ecdc4;
            border-radius: 8px;
            padding: 10px 15px;
            pointer-events: none;
            z-index: 1000;
            display: none;
            font-size: 12px;
            max-width: 200px;
        }

        .hover-info.visible { display: block; }

        /* Crisis Alert Styles */
        .crisis-alert {
            background: linear-gradient(135deg, #2a1a1a 0%, #1a1a2e 100%);
            border: 2px solid #ff6b6b;
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 15px;
            animation: crisis-pulse 1.5s ease-in-out infinite;
        }

        .crisis-alert.hidden { display: none; }

        @keyframes crisis-pulse {
            0%, 100% { border-color: #ff6b6b; box-shadow: 0 0 10px rgba(255, 107, 107, 0.3); }
            50% { border-color: #ff4444; box-shadow: 0 0 20px rgba(255, 68, 68, 0.6); }
        }

        .crisis-item {
            background: rgba(255, 107, 107, 0.1);
            border-radius: 4px;
            padding: 8px;
            margin-bottom: 6px;
            font-size: 12px;
        }

        .crisis-item-name {
            color: #ff6b6b;
            font-weight: 600;
            margin-bottom: 4px;
        }

        .crisis-item-progress {
            height: 4px;
            background: #1a1a2e;
            border-radius: 2px;
            margin-top: 6px;
            overflow: hidden;
        }

        .crisis-item-progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff6b6b, #4ecdc4);
            border-radius: 2px;
            transition: width 0.3s;
        }

        .crisis-casualties {
            font-size: 10px;
            color: #ff6b6b;
            margin-top: 4px;
        }

        /* Cycle 3: Milestone Celebration Overlay */
        .milestone-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(10, 10, 18, 0.95);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10000;
            animation: milestone-fade-in 0.5s ease-out;
            cursor: pointer;
        }

        .milestone-overlay.hidden { display: none; }

        @keyframes milestone-fade-in {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .milestone-content {
            text-align: center;
            max-width: 600px;
            padding: 40px;
        }

        .milestone-year {
            font-size: 72px;
            font-weight: 700;
            background: linear-gradient(90deg, #4ecdc4, #a18cd1, #ffd93d);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: milestone-glow 2s ease-in-out infinite;
        }

        @keyframes milestone-glow {
            0%, 100% { filter: brightness(1); }
            50% { filter: brightness(1.3); }
        }

        .milestone-title {
            font-size: 28px;
            color: #e0e8f0;
            margin: 20px 0;
            letter-spacing: 4px;
        }

        .milestone-stats {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 20px;
            margin: 30px 0;
        }

        .milestone-stat {
            background: rgba(78, 205, 196, 0.1);
            border: 1px solid #4ecdc4;
            border-radius: 12px;
            padding: 20px;
        }

        .milestone-stat-label {
            font-size: 12px;
            color: #6a6a8a;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .milestone-stat-value {
            font-size: 32px;
            font-weight: 700;
            color: #4ecdc4;
            margin-top: 8px;
        }

        .milestone-stat-change {
            font-size: 14px;
            margin-top: 4px;
        }

        .milestone-stat-change.positive { color: #4ecdc4; }
        .milestone-stat-change.negative { color: #ff6b6b; }

        .milestone-factions {
            margin: 20px 0;
            padding: 15px;
            background: rgba(161, 140, 209, 0.1);
            border-radius: 8px;
        }

        .milestone-dismiss {
            font-size: 14px;
            color: #6a6a8a;
            margin-top: 30px;
            animation: pulse 1.5s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 0.5; }
            50% { opacity: 1; }
        }

        /* Trend indicators for stats */
        .stat-trend {
            font-size: 10px;
            margin-left: 5px;
        }
        .stat-trend.up { color: #4ecdc4; }
        .stat-trend.down { color: #ff6b6b; }
        .stat-trend.stable { color: #6a6a8a; }

        .stat-value.critical { color: #ff6b6b !important; animation: stat-pulse 0.5s ease-in-out infinite; }
        .stat-value.warning { color: #ffd93d !important; }
        .stat-value.healthy { color: #4ecdc4 !important; }

        @keyframes stat-pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }

        /* Cinematic Mode Styles */
        .cinematic-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1000;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            transition: opacity 2s ease-in-out;
            opacity: 0;
        }

        .cinematic-overlay.active {
            opacity: 1;
        }

        .film-grain {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: url('https://grainy-gradients.vercel.app/noise.svg');
            opacity: 0.05;
            pointer-events: none;
            z-index: 999;
            display: none;
        }

        .cinematic-overlay.active .film-grain {
            display: block;
            animation: grain 0.5s steps(10) infinite;
        }

        @keyframes grain {
            0%, 100% { transform: translate(0, 0); }
            10% { transform: translate(-1%, -1%); }
            20% { transform: translate(1%, 1%); }
            30% { transform: translate(-2%, -2%); }
            40% { transform: translate(2%, 2%); }
            50% { transform: translate(-1%, 1%); }
            60% { transform: translate(1%, -1%); }
            70% { transform: translate(-2%, 1%); }
            80% { transform: translate(2%, -1%); }
            90% { transform: translate(-1%, -2%); }
        }

        .letterbox-top, .letterbox-bottom {
            height: 12%;
            background: black;
            width: 100%;
            transition: height 2s ease-in-out;
        }

        .cinematic-title {
            position: absolute;
            bottom: 15%;
            left: 50%;
            transform: translateX(-50%);
            font-family: 'Courier New', monospace;
            font-size: 18px;
            color: rgba(255, 255, 255, 0.7);
            letter-spacing: 8px;
            text-transform: uppercase;
            pointer-events: none;
            text-align: center;
        }

        .cinematic-subtitle {
            font-size: 12px;
            letter-spacing: 4px;
            margin-top: 10px;
            color: rgba(78, 205, 196, 0.5);
            transition: opacity 1s ease-in-out;
        }

        .cinematic-controls {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 1001;
        }

        button.cinematic-btn {
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(78, 205, 196, 0.3);
            color: #4ecdc4;
            padding: 10px 20px;
            font-family: 'Courier New', monospace;
            letter-spacing: 2px;
            cursor: pointer;
            transition: all 0.5s;
        }

        button.cinematic-btn:hover {
            background: rgba(78, 205, 196, 0.2);
            border-color: #4ecdc4;
        }

        button.cinematic-btn.active {
            background: #4ecdc4;
            color: black;
        }

        /* First Person HUD */
        #hud {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: none;
            z-index: 2000;
        }

        #hud.active {
            display: block;
        }

        .crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 20px;
            height: 20px;
            border: 1px solid rgba(78, 205, 196, 0.5);
            border-radius: 50%;
            transform: translate(-50%, -50%);
        }

        .crosshair::before, .crosshair::after {
            content: '';
            position: absolute;
            background: rgba(78, 205, 196, 0.8);
        }

        .crosshair::before {
            top: 50%;
            left: -5px;
            width: 30px;
            height: 1px;
            transform: translateY(-50%);
        }

        .crosshair::after {
            left: 50%;
            top: -5px;
            width: 1px;
            height: 30px;
            transform: translateX(-50%);
        }

        .hud-stats {
            position: absolute;
            bottom: 40px;
            left: 40px;
            font-family: 'Courier New', monospace;
            color: #4ecdc4;
            text-shadow: 0 0 10px rgba(78, 205, 196, 0.5);
        }

        .hud-stat {
            margin-bottom: 5px;
            font-size: 14px;
            letter-spacing: 2px;
        }

        .hud-interaction {
            position: absolute;
            top: 60%;
            left: 50%;
            transform: translateX(-50%);
            color: #ffd93d;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 3px;
            opacity: 0;
            transition: opacity 0.3s;
        }

        .hud-interaction.visible {
            opacity: 1;
        }

        /* Dialogue Overlay */
        .dialogue-overlay {
            position: absolute;
            bottom: 10%;
            left: 50%;
            transform: translateX(-50%);
            width: 600px;
            background: rgba(10, 10, 18, 0.95);
            border: 1px solid #4ecdc4;
            padding: 20px;
            display: none;
            z-index: 2500;
            animation: dialogue-slide-up 0.3s ease-out;
        }

        .dialogue-overlay.active {
            display: block;
        }

        @keyframes dialogue-slide-up {
            from { transform: translate(-50%, 20px); opacity: 0; }
            to { transform: translate(-50%, 0); opacity: 1; }
        }

        .dialogue-box {
            position: relative;
        }

        .dialogue-name {
            color: #4ecdc4;
            font-family: 'Courier New', monospace;
            font-size: 18px;
            font-weight: bold;
            letter-spacing: 4px;
            margin-bottom: 10px;
            border-bottom: 1px solid rgba(78, 205, 196, 0.3);
            padding-bottom: 5px;
        }

        .dialogue-text {
            font-size: 16px;
            line-height: 1.6;
            color: #e0e8f0;
            margin-bottom: 15px;
            font-style: italic;
        }

        .dialogue-sub {
            font-size: 12px;
            color: #6a6a8a;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .dialogue-prompt {
            position: absolute;
            bottom: -10px;
            right: 0;
            font-size: 10px;
            color: #4ecdc4;
            opacity: 0.6;
        }

        /* Terrarium Mode - Hiding UI */
        .terrarium-mode .left-panel,
        .terrarium-mode .right-panel,
        .terrarium-mode header,
        .terrarium-mode footer {
            display: none !important;
        }

        .terrarium-mode #container {
            grid-template-columns: 1fr;
            grid-template-rows: 1fr;
        }

        .terrarium-mode .main-view {
            grid-column: 1;
            grid-row: 1;
        }

        /* Instructions Overlay */
        #instructions {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(10, 10, 18, 0.9);
            border: 1px solid #4ecdc4;
            padding: 30px;
            text-align: center;
            z-index: 3000;
            display: none;
        }

        #instructions.active {
            display: block;
        }

        .instruction-key {
            color: #4ecdc4;
            font-weight: bold;
            padding: 2px 6px;
            background: #1a1a2e;
            border-radius: 4px;
            margin: 0 4px;
        }
    </style>
</head>
<body class="terrarium-mode">
    <div id="container">
        <header>
            <h1>GENESIS ARK</h1>
            <div class="time-display">
                <div>
                    <div class="year-display">Year <span id="yearDisplay">0</span></div>
                    <div class="generation-display">Generation <span id="genDisplay">1</span> ‚Ä¢ <span id="destDisplay">400</span> years to destination</div>
                </div>
                <div class="progress-bar">
                    <div class="progress-fill" id="progressFill" style="width: 0%"></div>
                </div>
            </div>
            <div class="controls">
                <div class="speed-controls">
                    <button class="speed-btn" data-speed="0">‚è∏</button>
                    <button class="speed-btn active" data-speed="1">1√ó</button>
                    <button class="speed-btn" data-speed="5">5√ó</button>
                    <button class="speed-btn" data-speed="20">20√ó</button>
                    <button class="speed-btn" data-speed="100">100√ó</button>
                </div>
                <button id="cinematicBtn" class="cinematic-btn">üé¨ Cinematic</button>
                <button id="audioBtn">üîä Audio</button>
                <button id="resetBtn">‚Üª Reset</button>
                <button id="exportBtn">üì§ Export</button>
            </div>
        </header>

        <div class="left-panel">
            <!-- Colonist Focus Panel -->
            <div class="colonist-focus hidden" id="colonistFocus">
                <div class="colonist-portrait" id="colonistPortrait">A</div>
                <div class="colonist-focus-name" id="colonistName">Unknown</div>
                <div class="colonist-focus-gen" id="colonistGen">Generation 1 ‚Ä¢ Age 25</div>
                <div class="colonist-stats">
                    <div class="colonist-stat">
                        <div class="colonist-stat-label">Literacy</div>
                        <div class="colonist-stat-value" id="colonistLit">100%</div>
                    </div>
                    <div class="colonist-stat">
                        <div class="colonist-stat-label">Tech</div>
                        <div class="colonist-stat-value" id="colonistTech">100%</div>
                    </div>
                </div>
                <div class="colonist-beliefs">
                    <div class="colonist-beliefs-title">NEURAL WEIGHTS</div>
                    <div id="neuralBars"></div>
                </div>
                <div class="colonist-lineage" id="colonistLineage">First Generation Colonist</div>
                <button id="unfocusBtn" style="width:100%;margin-top:10px;" aria-label="Stop following colonist">√ó Unfollow</button>
            </div>

            <div class="panel-title">Society Status</div>
            <div class="stat-group">
                <div class="stat-row">
                    <span class="stat-label">Population</span>
                    <span class="stat-value" id="popStat">1000</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Average Age</span>
                    <span class="stat-value" id="ageStat">25</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Literacy Rate</span>
                    <span class="stat-value" id="litStat">100%</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Tech Understanding</span>
                    <span class="stat-value" id="techStat">100%</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Social Connections</span>
                    <span class="stat-value" id="socialStat">0</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Total Crises</span>
                    <span class="stat-value" id="crisisStat">0</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Crisis Deaths</span>
                    <span class="stat-value" id="crisisDeathStat">0</span>
                </div>
            </div>

            <!-- Active Crisis Alert -->
            <div id="crisisAlert" class="crisis-alert hidden">
                <div class="panel-title" style="color:#ff6b6b;">‚ö†Ô∏è ACTIVE CRISIS</div>
                <div id="crisisAlertContent"></div>
            </div>

            <div class="panel-title">Language Drift</div>
            <div class="language-panel" id="languagePanel"></div>

            <div class="panel-title">Active Factions</div>
            <div id="factionList"></div>

            <div class="panel-title">Population History</div>
            <canvas id="popGraph" class="pop-graph"></canvas>
        </div>

        <div class="main-view">
            <canvas id="threeCanvas"></canvas>
            <div id="cinematicOverlay" class="cinematic-overlay">
                <div class="film-grain"></div>
                <div class="letterbox-top"></div>
                <div class="cinematic-title" id="cinematicTitle">
                    GENESIS ARK
                    <div class="cinematic-subtitle" id="cinematicSubtitle">A SPACE ODYSSEY</div>
                </div>
                <div class="letterbox-bottom"></div>
            </div>
            
            <!-- First Person HUD -->
            <div id="hud">
                <div class="crosshair"></div>
                <div class="hud-stats">
                    <div class="hud-stat">ARK OS v4.0 // YEAR <span id="hudYear">0</span></div>
                    <div class="hud-stat">POPULATION: <span id="hudPop">0</span></div>
                    <div class="hud-stat">STATUS: <span id="hudStatus">NOMINAL</span></div>
                </div>
                <div id="hudInteraction" class="hud-interaction">PRESS [E] TO INTERACT</div>
                
                <!-- Dialogue Overlay -->
                <div id="dialogueOverlay" class="dialogue-overlay">
                    <div class="dialogue-box">
                        <div class="dialogue-name" id="dialogueName">ALREN</div>
                        <div class="dialogue-text" id="dialogueText">"The stars are beautiful today, aren't they?"</div>
                        <div class="dialogue-sub" id="dialogueSub">Generation 4 ‚Ä¢ Technocrat</div>
                        <div class="dialogue-prompt">PRESS [E] TO CLOSE</div>
                    </div>
                </div>
            </div>

            <!-- Instructions -->
            <div id="instructions">
                <h2 style="color:#4ecdc4;margin-bottom:20px;">FIRST-PERSON MODE</h2>
                <p style="margin-bottom:15px;">Use <span class="instruction-key">W</span><span class="instruction-key">A</span><span class="instruction-key">S</span><span class="instruction-key">D</span> to walk</p>
                <p style="margin-bottom:15px;">Use <span class="instruction-key">MOUSE</span> to look around</p>
                <p style="margin-bottom:15px;">Press <span class="instruction-key">E</span> to interact with colonists</p>
                <p style="margin-bottom:15px;">Press <span class="instruction-key">ESC</span> to exit first-person</p>
                <p style="margin-bottom:25px;">Press <span class="instruction-key">U</span> to toggle UI panels</p>
                <button id="startFPS" class="cinematic-btn">ENTER THE ARK</button>
            </div>

            <div class="camera-controls">
                <button id="orbitBtn">üîÑ Orbit</button>
                <button id="followBtn">üë§ Follow</button>
                <button id="interiorBtn">üè† Interior</button>
                <button id="fpsBtn" class="active">üö∂ First-Person</button>
            </div>
            <div class="view-overlay">
                <span style="color:#4ecdc4;font-size:12px;">[ESC] to unlock mouse ‚Ä¢ [U] to toggle UI ‚Ä¢ [E] to interact</span>
            </div>
            <div class="hover-info" id="hoverInfo"></div>
        </div>

        <div class="right-panel">
            <div class="tab-container">
                <button class="tab active" data-tab="texts">Sacred Texts</button>
                <button class="tab" data-tab="myths">Mythology</button>
                <button class="tab" data-tab="journals">Journals</button>
                <button class="tab" data-tab="events">Events</button>
            </div>

            <div class="tab-content active" id="textsTab">
                <div class="panel-title">Document Evolution</div>
                <div id="textEvolutions"></div>
            </div>

            <div class="tab-content" id="mythsTab">
                <div class="panel-title">Emergent Mythology</div>
                <div id="mythList"></div>
            </div>

            <div class="tab-content" id="journalsTab">
                <div class="panel-title">Colonist Journals</div>
                <div id="journalList"></div>
            </div>

            <div class="tab-content" id="eventsTab">
                <div class="panel-title">Historical Events</div>
                <div class="event-log" id="eventLog"></div>
            </div>
        </div>

        <footer>
            <div>
                <span>Current Dialect: </span>
                <span class="language-sample" id="dialectSample">"The Ark carries us to New Eden"</span>
            </div>
            <div id="statusText">Initializing 3D simulation...</div>
        </footer>
    </div>

    <!-- Cycle 3: Milestone Celebration Overlay -->
    <div id="milestoneOverlay" class="milestone-overlay hidden">
        <div class="milestone-content">
            <div class="milestone-year" id="milestoneYear">YEAR 100</div>
            <div class="milestone-title" id="milestoneTitle">CENTURY REPORT</div>
            <div class="milestone-stats" id="milestoneStats"></div>
            <div class="milestone-factions" id="milestoneFactions"></div>
            <div class="milestone-dismiss">Click anywhere to continue the voyage...</div>
        </div>
    </div>

    <!-- Three.js -->
    <script src="https://unpkg.com/three@0.128.0/build/three.min.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/controls/PointerLockControls.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
    <script>
        // ============================================
        // GENESIS ARK: AAA 3D Edition
        // Cycle 1 Improvements: 3D + ECS + Focus System
        // ============================================

        const CONFIG = {
            VOYAGE_YEARS: 400,
            INITIAL_POPULATION: 1000,
            MAX_POPULATION: 5000,
            GENERATION_LENGTH: 25,
            LANGUAGE_DRIFT_RATE: 0.002,
            BIRTH_RATE: 0.03,
            DEATH_RATE: 0.02,
            SOCIAL_CONNECTION_CHANCE: 0.01,
            MAX_CONNECTIONS: 10,
            CRISIS_CHANCE: 0.005, // Per year chance of major crisis
            RELATIONSHIP_CHANCE: 0.05, // Chance to form a partnership
            JOURNAL_CHANCE: 0.02, // Chance to write a journal entry
            AWARENESS_THRESHOLD: 0.8, // Threshold for meta-simulation awakening
            GRAVITY_STABILITY: 1.0, // Current ship gravity
            CINEMATIC_SPEED: 0.2, // Slower simulation speed for cinematic mode
            DIRECTOR_SWITCH_INTERVAL: 15, // Seconds between camera angle changes
            COLORS: {
                technocrats: 0x4ecdc4,
                spiritualists: 0xa18cd1,
                traditionalists: 0xd4a574,
                nihilists: 0xff6b6b,
                transcendentists: 0xffd93d,
                unaffiliated: 0x6a6a8a
            },
            HEX_COLORS: {
                technocrats: '#4ecdc4',
                spiritualists: '#a18cd1',
                traditionalists: '#d4a574',
                nihilists: '#ff6b6b',
                transcendentists: '#ffd93d'
            }
        };

        // ============================================
        // CRISIS EVENTS SYSTEM
        // ============================================

        const CRISIS_TYPES = {
            // Ship/Technical Crises
            hull_breach: {
                name: 'Hull Breach',
                category: 'ship',
                severity: [0.05, 0.15], // Population loss range
                duration: [3, 10], // Years to resolve
                description: 'A micrometeor impacts Section {section}. Emergency protocols engage.',
                resolution: 'The breach was sealed by {hero}. {casualties} souls were lost to the void.',
                mythTitle: 'The Great Void Wound',
                mythDesc: 'When the darkness itself reached in to claim the faithful, but was repelled by the sacred seal.',
                visualEffect: 'breach'
            },
            power_failure: {
                name: 'Power Grid Failure',
                category: 'ship',
                severity: [0.02, 0.08],
                duration: [5, 20],
                description: 'Reactor {reactor} experiences critical cascade failure. Auxiliary power engaged.',
                resolution: 'Power restored after {years} years of rationing. The darkness retreated.',
                mythTitle: 'The Long Night',
                mythDesc: 'When the eternal lights dimmed and the ancestors walked in shadow.',
                visualEffect: 'darkness'
            },
            disease_outbreak: {
                name: 'Disease Outbreak',
                category: 'ship',
                severity: [0.08, 0.25],
                duration: [2, 8],
                description: 'An unknown pathogen emerges from hydroponics bay. Quarantine initiated.',
                resolution: 'The plague subsided. {casualties} perished. The survivors carry immunity.',
                mythTitle: 'The Invisible Reaper',
                mythDesc: 'The spirit that culled the weak so the journey might continue.',
                visualEffect: 'plague'
            },
            life_support: {
                name: 'Life Support Critical',
                category: 'ship',
                severity: [0.03, 0.12],
                duration: [1, 5],
                description: 'CO2 scrubbers failing. Oxygen levels dropping. All hands to emergency stations.',
                resolution: 'Air restored. The {faction} claim their prayers saved us all.',
                mythTitle: 'When the Breath Faltered',
                mythDesc: 'The ancestors learned that the Ship\'s breath was sacred.',
                visualEffect: 'suffocation'
            },

            // Social Crises
            faction_war: {
                name: 'Faction Conflict',
                category: 'social',
                severity: [0.03, 0.10],
                duration: [5, 15],
                description: 'Open conflict erupts between {faction1} and {faction2}. Blood stains the corridors.',
                resolution: 'Peace restored after {casualties} deaths. The {victor} emerged dominant.',
                mythTitle: 'The Brother War',
                mythDesc: 'When kin turned against kin, and the Ship wept.',
                visualEffect: 'conflict'
            },
            mutiny: {
                name: 'Mutiny Attempt',
                category: 'social',
                severity: [0.05, 0.15],
                duration: [1, 3],
                description: 'A faction of {count} colonists attempt to seize control of the command module.',
                resolution: 'The mutiny was {outcome}. {casualties} died in the struggle.',
                mythTitle: 'The Usurper\'s Fall',
                mythDesc: 'Those who defied the sacred order were cast down.',
                visualEffect: 'mutiny'
            },
            heresy_trial: {
                name: 'Heresy Trials',
                category: 'social',
                severity: [0.01, 0.05],
                duration: [2, 6],
                description: 'The {faction} declare certain beliefs heretical. Trials begin.',
                resolution: '{casualties} were condemned. Fear grips the ship.',
                mythTitle: 'The Purification',
                mythDesc: 'The unbelievers were judged and found wanting.',
                visualEffect: 'trial'
            },
            prophet_emergence: {
                name: 'False Prophet',
                category: 'social',
                severity: [0.02, 0.08],
                duration: [3, 10],
                description: 'A charismatic figure claims divine revelation. Followers gather.',
                resolution: 'The prophet {outcome}. Their teachings {legacy}.',
                mythTitle: 'The Speaker of Stars',
                mythDesc: 'One who heard the voice of the void and spoke its truth.',
                visualEffect: 'prophet'
            },

            // Resource Crises
            food_shortage: {
                name: 'Crop Failure',
                category: 'resource',
                severity: [0.05, 0.20],
                duration: [3, 8],
                description: 'Hydroponics blight destroys {percent}% of food production.',
                resolution: 'New strains developed. {casualties} starved during the famine.',
                mythTitle: 'The Hungry Years',
                mythDesc: 'When the gardens withered and the Ship demanded sacrifice.',
                visualEffect: 'famine'
            },
            water_contamination: {
                name: 'Water Contamination',
                category: 'resource',
                severity: [0.04, 0.12],
                duration: [2, 6],
                description: 'Recycling system contaminated. Water reserves critically low.',
                resolution: 'Purification restored. The thirst claimed {casualties}.',
                mythTitle: 'The Poisoned Well',
                mythDesc: 'When even water became the enemy.',
                visualEffect: 'poison'
            },
            gravity_failure: {
                name: 'Gravity Oscillation',
                category: 'ship',
                severity: [0.01, 0.05],
                duration: [5, 15],
                description: 'Centrifugal stabilizers failing in Section {section}. Gravity fluctuating.',
                resolution: 'Stabilizers recalibrated. The "Upward Fall" has ended.',
                mythTitle: 'The Day the Floor Vanished',
                mythDesc: 'When the Ship forgot its weight and the ancestors floated like spirits.',
                visualEffect: 'gravity'
            },
            meta_awakening: {
                name: 'The Great Awakening',
                category: 'social',
                severity: [0.0, 0.02],
                duration: [10, 30],
                description: 'A group of colonists claim the Ship is a "simulation" created by "The Observer".',
                resolution: 'The "Awakened" have integrated their knowledge. The Ship feels... different.',
                mythTitle: 'The Breaking of the Veil',
                mythDesc: 'When we realized the stars were pixels and the void was code.',
                visualEffect: 'glitch'
            }
        };

        class CrisisManager {
            constructor() {
                this.activeCrises = [];
                this.resolvedCrises = [];
                this.crisisHistory = [];
                this.totalCrisisDeaths = 0;
            }

            checkForCrisis(year, population, factions) {
                // Base chance modified by population and faction tensions
                let crisisChance = CONFIG.CRISIS_CHANCE;

                // More factions = more social crisis risk
                if (factions.length >= 3) crisisChance *= 1.5;
                if (factions.length >= 5) crisisChance *= 1.3;

                // Overpopulation increases crisis risk
                if (population > CONFIG.MAX_POPULATION * 0.8) crisisChance *= 1.5;

                // Recent crises reduce immediate chance (recovery period)
                const recentCrises = this.crisisHistory.filter(c => year - c.year < 20).length;
                crisisChance *= Math.max(0.3, 1 - recentCrises * 0.2);

                if (Math.random() < crisisChance && this.activeCrises.length < 2) {
                    return this.generateCrisis(year, population, factions);
                }
                return null;
            }

            generateCrisis(year, population, factions) {
                const types = Object.keys(CRISIS_TYPES);
                const typeKey = types[Math.floor(Math.random() * types.length)];
                const template = CRISIS_TYPES[typeKey];

                // Calculate severity within range
                const severityRange = template.severity[1] - template.severity[0];
                const severity = template.severity[0] + Math.random() * severityRange;

                const durationRange = template.duration[1] - template.duration[0];
                const duration = Math.floor(template.duration[0] + Math.random() * durationRange);

                // Generate description with placeholders
                let description = template.description
                    .replace('{section}', Math.floor(Math.random() * 12) + 1)
                    .replace('{reactor}', String.fromCharCode(65 + Math.floor(Math.random() * 4)))
                    .replace('{percent}', Math.floor(severity * 100 * 2))
                    .replace('{count}', Math.floor(population * 0.05));

                if (factions.length >= 2) {
                    const shuffled = [...factions].sort(() => Math.random() - 0.5);
                    description = description
                        .replace('{faction1}', shuffled[0]?.name || 'rebels')
                        .replace('{faction2}', shuffled[1]?.name || 'loyalists')
                        .replace('{faction}', shuffled[0]?.name || 'the faithful');
                } else {
                    description = description
                        .replace('{faction1}', 'rebels')
                        .replace('{faction2}', 'loyalists')
                        .replace('{faction}', 'the council');
                }

                const crisis = {
                    id: `crisis_${year}_${typeKey}`,
                    type: typeKey,
                    template,
                    name: template.name,
                    category: template.category,
                    severity,
                    duration,
                    description,
                    startYear: year,
                    endYear: year + duration,
                    casualties: 0,
                    resolved: false,
                    hero: null,
                    visualIntensity: 1.0
                };

                this.activeCrises.push(crisis);
                this.crisisHistory.push({ year, type: typeKey, severity });

                return crisis;
            }

            updateCrises(year, ecs, factions) {
                const updates = [];

                for (const crisis of this.activeCrises) {
                    // Calculate yearly casualties
                    const aliveCount = ecs.getAliveCount();
                    const yearlyCasualties = Math.floor(aliveCount * crisis.severity / crisis.duration);

                    if (yearlyCasualties > 0) {
                        const aliveIds = ecs.getAliveIds();
                        const victims = aliveIds
                            .sort(() => Math.random() - 0.5)
                            .slice(0, yearlyCasualties);

                        for (const id of victims) {
                            ecs.destroyEntity(id);
                            crisis.casualties++;
                            this.totalCrisisDeaths++;
                        }
                    }

                    // Update visual intensity (pulses during crisis)
                    const progress = (year - crisis.startYear) / crisis.duration;
                    crisis.visualIntensity = 1.0 - progress * 0.5 + Math.sin(year * 0.5) * 0.2;

                    // Check for resolution
                    if (year >= crisis.endYear) {
                        crisis.resolved = true;
                        crisis.hero = ecs.names[ecs.getAliveIds()[Math.floor(Math.random() * ecs.getAliveCount())]];

                        // Generate resolution text
                        let resolution = crisis.template.resolution
                            .replace('{hero}', crisis.hero || 'unknown heroes')
                            .replace('{casualties}', crisis.casualties)
                            .replace('{years}', crisis.duration)
                            .replace('{outcome}', Math.random() > 0.5 ? 'succeeded' : 'failed')
                            .replace('{legacy}', Math.random() > 0.5 ? 'live on' : 'were suppressed');

                        if (factions.length > 0) {
                            const victorFaction = factions[Math.floor(Math.random() * factions.length)];
                            resolution = resolution
                                .replace('{faction}', victorFaction?.name || 'survivors')
                                .replace('{victor}', victorFaction?.name || 'survivors');
                        }

                        crisis.resolution = resolution;

                        // Create myth from crisis
                        const myth = {
                            title: crisis.template.mythTitle,
                            desc: crisis.template.mythDesc,
                            originYear: year,
                            faction: factions.length > 0 ? factions[Math.floor(Math.random() * factions.length)].name : 'Ship\'s Memory',
                            casualties: crisis.casualties,
                            crisisType: crisis.type
                        };

                        updates.push({
                            type: 'resolved',
                            crisis,
                            resolution,
                            myth
                        });

                        this.resolvedCrises.push(crisis);
                    }
                }

                // Remove resolved crises from active list
                this.activeCrises = this.activeCrises.filter(c => !c.resolved);

                return updates;
            }

            getActiveVisualEffects() {
                return this.activeCrises.map(c => ({
                    type: c.template.visualEffect,
                    intensity: c.visualIntensity,
                    category: c.category
                }));
            }

            getActiveCrisisNames() {
                return this.activeCrises.map(c => c.name);
            }

            getStats() {
                return {
                    totalCrises: this.crisisHistory.length,
                    activeCrises: this.activeCrises.length,
                    totalDeaths: this.totalCrisisDeaths,
                    recentCrises: this.resolvedCrises.slice(-5)
                };
            }
        }

        // ============================================
        // WEB AUDIO AMBIENT SYSTEM
        // ============================================

        class AmbientAudioSystem {
            constructor() {
                this.ctx = null;
                this.masterGain = null;
                this.initialized = false;
                this.muted = false;

                // Oscillators and nodes
                this.engineDrone = null;
                this.engineGain = null;
                this.atmosphereNoise = null;
                this.atmosphereGain = null;
                this.eventChimeGain = null;
                this.monolithOsc = null;
                this.monolithGain = null;

                // State tracking
                this.currentYear = 0;
                this.mythologization = 0;
                this.crisisActive = false;
            }

            async init() {
                if (this.initialized) return;

                try {
                    this.ctx = new (window.AudioContext || window.webkitAudioContext)();

                    // Master gain
                    this.masterGain = this.ctx.createGain();
                    this.masterGain.gain.value = 0.3;
                    this.masterGain.connect(this.ctx.destination);

                    // Engine drone (low frequency hum)
                    this.createEngineDrone();

                    // Atmospheric noise (filtered white noise)
                    this.createAtmosphereNoise();

                    // Monolith drone (cinematic low hum)
                    this.createMonolithDrone();

                    // Event chime setup
                    this.eventChimeGain = this.ctx.createGain();
                    this.eventChimeGain.gain.value = 0;
                    this.eventChimeGain.connect(this.masterGain);

                    // Chatter setup
                    this.createChatter();

                    this.initialized = true;
                } catch (e) {
                    console.warn('Web Audio not supported:', e);
                }
            }

            createChatter() {
                this.chatterGain = this.ctx.createGain();
                this.chatterGain.gain.value = 0.02;
                this.chatterGain.connect(this.masterGain);
            }

            playChatter() {
                if (!this.initialized || this.muted || Math.random() > 0.1) return;
                const words = Object.values(LANGUAGE.baseWords);
                const word = words[Math.floor(Math.random() * words.length)].current;
                // Play short, filtered pulses representing "chatter"
                this.playEventChime('birth'); // Reuse chime logic with lower volume
            }

            createEngineDrone() {
                // Base engine frequency
                const baseFreq = 40;

                // Multiple oscillators for rich drone
                this.engineOscs = [];
                this.engineGain = this.ctx.createGain();
                this.engineGain.gain.value = 0.15;

                // Low pass filter for warmth
                const lpf = this.ctx.createBiquadFilter();
                lpf.type = 'lowpass';
                lpf.frequency.value = 150;
                lpf.Q.value = 1;
                lpf.connect(this.engineGain);
                this.engineGain.connect(this.masterGain);

                // Create layered oscillators
                const freqs = [baseFreq, baseFreq * 1.5, baseFreq * 2, baseFreq * 3];
                const gains = [0.5, 0.3, 0.15, 0.05];

                for (let i = 0; i < freqs.length; i++) {
                    const osc = this.ctx.createOscillator();
                    osc.type = 'sine';
                    osc.frequency.value = freqs[i];

                    const oscGain = this.ctx.createGain();
                    oscGain.gain.value = gains[i];

                    osc.connect(oscGain);
                    oscGain.connect(lpf);
                    osc.start();

                    this.engineOscs.push({ osc, gain: oscGain });
                }

                // Add subtle LFO modulation
                const lfo = this.ctx.createOscillator();
                lfo.type = 'sine';
                lfo.frequency.value = 0.1;

                const lfoGain = this.ctx.createGain();
                lfoGain.gain.value = 2;

                lfo.connect(lfoGain);
                lfoGain.connect(this.engineOscs[0].osc.frequency);
                lfo.start();

                this.engineLfo = lfo;
            }

            createAtmosphereNoise() {
                // White noise buffer
                const bufferSize = this.ctx.sampleRate * 2;
                const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);

                for (let i = 0; i < bufferSize; i++) {
                    data[i] = Math.random() * 2 - 1;
                }

                // Noise source
                const noise = this.ctx.createBufferSource();
                noise.buffer = buffer;
                noise.loop = true;

                // Band pass filter for "air" sound
                const bpf = this.ctx.createBiquadFilter();
                bpf.type = 'bandpass';
                bpf.frequency.value = 800;
                bpf.Q.value = 0.5;

                this.atmosphereGain = this.ctx.createGain();
                this.atmosphereGain.gain.value = 0.03;

                noise.connect(bpf);
                bpf.connect(this.atmosphereGain);
                this.atmosphereGain.connect(this.masterGain);
                noise.start();

                this.atmosphereNoise = noise;
                this.atmosphereBPF = bpf;
            }

            createMonolithDrone() {
                this.monolithOsc = this.ctx.createOscillator();
                this.monolithOsc.type = 'sine';
                this.monolithOsc.frequency.value = 30; // Very low

                this.monolithGain = this.ctx.createGain();
                this.monolithGain.gain.value = 0.05;

                const lpf = this.ctx.createBiquadFilter();
                lpf.type = 'lowpass';
                lpf.frequency.value = 60;

                this.monolithOsc.connect(lpf);
                lpf.connect(this.monolithGain);
                this.monolithGain.connect(this.masterGain);
                this.monolithOsc.start();
            }

            playEventChime(type) {
                if (!this.initialized || this.muted) return;

                const now = this.ctx.currentTime;

                // Different chime patterns based on event type
                const patterns = {
                    birth: { freqs: [523, 659, 784], duration: 0.3, attack: 0.01 },
                    death: { freqs: [220, 165, 110], duration: 0.8, attack: 0.1 },
                    faction: { freqs: [392, 494, 587, 698], duration: 0.5, attack: 0.02 },
                    crisis_start: { freqs: [147, 175, 220], duration: 1.5, attack: 0.3 },
                    crisis_end: { freqs: [262, 330, 392, 523], duration: 1.0, attack: 0.1 },
                    myth: { freqs: [440, 554, 659, 880], duration: 0.7, attack: 0.05 },
                    milestone: { freqs: [523, 659, 784, 1047], duration: 0.6, attack: 0.02 }
                };

                const pattern = patterns[type] || patterns.milestone;

                // Evolve chime sound based on mythologization
                const mythFactor = 1 + this.mythologization * 0.5;

                for (let i = 0; i < pattern.freqs.length; i++) {
                    const osc = this.ctx.createOscillator();
                    osc.type = this.mythologization > 0.5 ? 'triangle' : 'sine';
                    osc.frequency.value = pattern.freqs[i] * mythFactor;

                    const gain = this.ctx.createGain();
                    gain.gain.value = 0;

                    // Add reverb-like delay for more mythical sound
                    const delay = this.ctx.createDelay();
                    delay.delayTime.value = 0.1 + this.mythologization * 0.2;

                    const delayGain = this.ctx.createGain();
                    delayGain.gain.value = 0.3 * this.mythologization;

                    osc.connect(gain);
                    gain.connect(this.masterGain);
                    gain.connect(delay);
                    delay.connect(delayGain);
                    delayGain.connect(this.masterGain);

                    const noteStart = now + i * 0.08;
                    gain.gain.setValueAtTime(0, noteStart);
                    gain.gain.linearRampToValueAtTime(0.15, noteStart + pattern.attack);
                    gain.gain.exponentialRampToValueAtTime(0.001, noteStart + pattern.duration);

                    osc.start(noteStart);
                    osc.stop(noteStart + pattern.duration + 0.5);

                    // Cycle 5: Cleanup audio nodes when oscillator ends
                    osc.onended = () => {
                        osc.disconnect();
                        gain.disconnect();
                        delay.disconnect();
                        delayGain.disconnect();
                    };
                }
            }

            updateAmbience(year, mythologization, crisisActive, population, cinematicMode) {
                if (!this.initialized) return;

                this.currentYear = year;
                this.mythologization = mythologization;
                this.crisisActive = crisisActive;

                const progress = year / CONFIG.VOYAGE_YEARS;

                // Monolith drone modulation
                if (this.monolithGain) {
                    const baseGain = cinematicMode ? 0.15 : 0.05;
                    const pulse = 1 + Math.sin(year * 0.1) * 0.2;
                    this.monolithGain.gain.setTargetAtTime(baseGain * pulse, this.ctx.currentTime, 0.5);
                    this.monolithOsc.frequency.setTargetAtTime(30 + progress * 10, this.ctx.currentTime, 1.0);
                }

                // Engine drone evolves - becomes more "sacred" sounding over time
                if (this.engineOscs && this.engineOscs.length > 0) {
                    // Shift frequencies slightly as ship ages
                    const drift = Math.sin(year * 0.01) * 2;
                    this.engineOscs[0].osc.frequency.value = 40 + drift + mythologization * 5;

                    // Add harmonics as mythologization increases
                    this.engineOscs[1].gain.gain.value = 0.3 + mythologization * 0.2;
                }

                // Atmosphere changes during crises
                if (this.atmosphereGain) {
                    if (crisisActive) {
                        this.atmosphereGain.gain.value = 0.08; // Louder during crisis
                        this.atmosphereBPF.frequency.value = 1200; // Higher, more tense
                    } else {
                        this.atmosphereGain.gain.value = 0.03;
                        this.atmosphereBPF.frequency.value = 800;
                    }
                }

                // Population affects "life" sounds
                const popFactor = Math.min(1, population / 3000);
                if (this.atmosphereGain) {
                    this.atmosphereGain.gain.value *= (0.5 + popFactor * 0.5);
                }

                // Play background chatter
                if (population > 100) {
                    this.playChatter();
                }
            }

            playCrisisAlarm(crisisType) {
                if (!this.initialized || this.muted) return;

                const now = this.ctx.currentTime;

                // Different alarm patterns for different crisis types
                const alarmFreqs = {
                    ship: [200, 150, 200, 150],
                    social: [300, 350, 300, 350],
                    resource: [250, 200, 250, 200]
                };

                const freqs = alarmFreqs[crisisType] || alarmFreqs.ship;

                const osc = this.ctx.createOscillator();
                osc.type = 'sawtooth';

                const gain = this.ctx.createGain();
                gain.gain.value = 0;

                const lpf = this.ctx.createBiquadFilter();
                lpf.type = 'lowpass';
                lpf.frequency.value = 800;

                osc.connect(lpf);
                lpf.connect(gain);
                gain.connect(this.masterGain);

                // Alarm sequence
                for (let i = 0; i < freqs.length; i++) {
                    const t = now + i * 0.3;
                    osc.frequency.setValueAtTime(freqs[i], t);
                    gain.gain.setValueAtTime(0.1, t);
                    gain.gain.linearRampToValueAtTime(0, t + 0.25);
                }

                osc.start(now);
                osc.stop(now + freqs.length * 0.3 + 0.5);

                // Cycle 5: Cleanup audio nodes when oscillator ends
                osc.onended = () => {
                    osc.disconnect();
                    lpf.disconnect();
                    gain.disconnect();
                };
            }

            setMuted(muted) {
                this.muted = muted;
                if (this.masterGain) {
                    this.masterGain.gain.value = muted ? 0 : 0.3;
                }
            }

            toggle() {
                this.setMuted(!this.muted);
                return !this.muted;
            }

            resume() {
                if (this.ctx && this.ctx.state === 'suspended') {
                    this.ctx.resume();
                }
            }
        }

        // ============================================
        // ECS - ENTITY COMPONENT SYSTEM
        // ============================================

        class ECS {
            constructor(maxEntities) {
                this.maxEntities = maxEntities;
                this.entityCount = 0;
                this.freeList = [];

                // Cycle 3: Cached alive indices for performance
                this._aliveIds = [];
                this._aliveIdsDirty = true;
                this._aliveCount = 0;

                // Component arrays (Struct of Arrays for cache efficiency)
                this.alive = new Uint8Array(maxEntities);
                this.generation = new Uint16Array(maxEntities);
                this.birthYear = new Uint16Array(maxEntities);
                this.age = new Uint16Array(maxEntities);

                // Position in ship (normalized 0-1)
                this.posX = new Float32Array(maxEntities);
                this.posY = new Float32Array(maxEntities);
                this.posZ = new Float32Array(maxEntities);
                this.velX = new Float32Array(maxEntities);
                this.velY = new Float32Array(maxEntities);
                this.velZ = new Float32Array(maxEntities);

                // Neural weights (6 traits)
                this.tradition = new Float32Array(maxEntities);
                this.innovation = new Float32Array(maxEntities);
                this.spirituality = new Float32Array(maxEntities);
                this.rationality = new Float32Array(maxEntities);
                this.community = new Float32Array(maxEntities);
                this.individuality = new Float32Array(maxEntities);

                // Stats
                this.literacy = new Float32Array(maxEntities);
                this.techUnderstanding = new Float32Array(maxEntities);
                this.awareness = new Float32Array(maxEntities); // Meta-simulation awareness
                this.augmentation = new Float32Array(maxEntities); // Cybernetic integration

                // Needs & Movement
                this.hunger = new Float32Array(maxEntities);
                this.fatigue = new Float32Array(maxEntities);
                this.targetX = new Float32Array(maxEntities);
                this.targetZ = new Float32Array(maxEntities);
                this.hasTarget = new Uint8Array(maxEntities);

                // Faction (-1 = none, 0-4 = faction index)
                this.faction = new Int8Array(maxEntities);

                // Social connections (sparse - stored separately)
                this.connections = new Map(); // entityId -> Set<entityId>
                this.partnerId = new Int32Array(maxEntities).fill(-1);
                this.familyId = new Int32Array(maxEntities).fill(-1);
                this.journals = new Array(maxEntities).fill(null).map(() => []);

                // Names (stored in separate array for memory efficiency)
                this.names = new Array(maxEntities);

                // Parent tracking for lineage
                this.parent1 = new Int32Array(maxEntities).fill(-1);
                this.parent2 = new Int32Array(maxEntities).fill(-1);

                // Social Dynamics
                this.partnerId = new Int32Array(maxEntities).fill(-1);
                this.familyId = new Int32Array(maxEntities).fill(-1);
            }

            createEntity() {
                let id;
                if (this.freeList.length > 0) {
                    id = this.freeList.pop();
                } else {
                    id = this.entityCount++;
                }

                this.alive[id] = 1;
                this.connections.set(id, new Set());
                this.partnerId[id] = -1;
                this.familyId[id] = -1;
                this.journals[id] = [];
                this._aliveIdsDirty = true; // Invalidate cache
                return id;
            }

            destroyEntity(id) {
                this.alive[id] = 0;
                this.connections.delete(id);
                this.freeList.push(id);
                this._aliveIdsDirty = true; // Invalidate cache
            }

            initializeColonist(id, gen, year, p1 = -1, p2 = -1) {
                this.generation[id] = gen;
                this.birthYear[id] = year;
                this.age[id] = 0;
                this.faction[id] = -1;
                this.parent1[id] = p1;
                this.parent2[id] = p2;

                if (p1 >= 0 && p2 >= 0) {
                    this.familyId[id] = this.familyId[p1] !== -1 ? this.familyId[p1] : (this.familyId[p2] !== -1 ? this.familyId[p2] : Math.floor(Math.random() * 10000));
                } else {
                    this.familyId[id] = -1;
                }

                // Position in habitat ring
                const angle = Math.random() * Math.PI * 2;
                const radius = 0.7 + Math.random() * 0.2;
                this.posX[id] = Math.cos(angle) * radius;
                this.posY[id] = (Math.random() - 0.5) * 0.3;
                this.posZ[id] = Math.sin(angle) * radius;
                this.velX[id] = 0;
                this.velY[id] = 0;
                this.velZ[id] = 0;

                // Neural weights
                if (p1 >= 0 && p2 >= 0) {
                    // Inherit from parents with mutation
                    this.tradition[id] = this.inheritTrait(this.tradition[p1], this.tradition[p2]);
                    this.innovation[id] = this.inheritTrait(this.innovation[p1], this.innovation[p2]);
                    this.spirituality[id] = this.inheritTrait(this.spirituality[p1], this.spirituality[p2]);
                    this.rationality[id] = this.inheritTrait(this.rationality[p1], this.rationality[p2]);
                    this.community[id] = this.inheritTrait(this.community[p1], this.community[p2]);
                    this.individuality[id] = this.inheritTrait(this.individuality[p1], this.individuality[p2]);

                    this.literacy[id] = (this.literacy[p1] + this.literacy[p2]) / 2 * 0.95;
                    this.techUnderstanding[id] = (this.techUnderstanding[p1] + this.techUnderstanding[p2]) / 2 * 0.9;
                    this.awareness[id] = (this.awareness[p1] + this.awareness[p2]) / 2 + (Math.random() - 0.4) * 0.1;
                    this.augmentation[id] = (this.augmentation[p1] + this.augmentation[p2]) / 2 + (Math.random() - 0.4) * 0.1;
                } else {
                    this.tradition[id] = Math.random();
                    this.innovation[id] = Math.random();
                    this.spirituality[id] = Math.random();
                    this.rationality[id] = Math.random();
                    this.community[id] = Math.random();
                    this.individuality[id] = Math.random();
                    this.literacy[id] = 1.0;
                    this.techUnderstanding[id] = 1.0;
                    this.awareness[id] = 0.0;
                    this.augmentation[id] = 0.0;
                }

                this.awareness[id] = Math.max(0, Math.min(1, this.awareness[id]));
                this.augmentation[id] = Math.max(0, Math.min(1, this.augmentation[id]));

                this.normalizeWeights(id);
                this.names[id] = this.generateName();
            }

            inheritTrait(p1Val, p2Val) {
                const base = Math.random() < 0.5 ? p1Val : p2Val;
                const mutation = (Math.random() - 0.5) * 0.2;
                return Math.max(0, Math.min(1, base + mutation));
            }

            normalizeWeights(id) {
                const sum = this.tradition[id] + this.innovation[id] + this.spirituality[id] +
                           this.rationality[id] + this.community[id] + this.individuality[id];
                if (sum > 0) {
                    this.tradition[id] /= sum;
                    this.innovation[id] /= sum;
                    this.spirituality[id] /= sum;
                    this.rationality[id] /= sum;
                    this.community[id] /= sum;
                    this.individuality[id] /= sum;
                }
            }

            generateName() {
                const prefixes = ['Al', 'El', 'Ka', 'Zi', 'Ma', 'Te', 'Lo', 'Va', 'No', 'Ra', 'Se', 'Da', 'Jo', 'Mi', 'Xe', 'Or', 'Ky', 'An'];
                const suffixes = ['ren', 'vin', 'ria', 'don', 'lia', 'nus', 'tha', 'kel', 'mar', 'wen', 'tor', 'isa', 'len', 'vex', 'ros'];
                return prefixes[Math.floor(Math.random() * prefixes.length)] +
                       suffixes[Math.floor(Math.random() * suffixes.length)];
            }

            getFactionAffinity(id) {
                const affinities = {
                    technocrats: this.rationality[id] * 0.6 + this.innovation[id] * 0.4,
                    spiritualists: this.spirituality[id] * 0.7 + this.community[id] * 0.3,
                    traditionalists: this.tradition[id] * 0.7 + this.community[id] * 0.3,
                    nihilists: this.individuality[id] * 0.5 + (1 - this.spirituality[id]) * 0.5,
                    transcendentists: this.innovation[id] * 0.5 + this.spirituality[id] * 0.5
                };

                let maxAffinity = 0;
                let preferred = -1;
                const types = ['technocrats', 'spiritualists', 'traditionalists', 'nihilists', 'transcendentists'];

                for (let i = 0; i < types.length; i++) {
                    if (affinities[types[i]] > maxAffinity) {
                        maxAffinity = affinities[types[i]];
                        preferred = i;
                    }
                }

                return { factionIndex: preferred, strength: maxAffinity };
            }

            addConnection(id1, id2) {
                const conn1 = this.connections.get(id1);
                const conn2 = this.connections.get(id2);
                if (conn1 && conn2 && conn1.size < CONFIG.MAX_CONNECTIONS && conn2.size < CONFIG.MAX_CONNECTIONS) {
                    conn1.add(id2);
                    conn2.add(id1);
                }
            }

            getAliveCount() {
                // Cycle 3: Use cached count
                if (this._aliveIdsDirty) this.getAliveIds();
                return this._aliveCount;
            }

            getAliveIds() {
                // Cycle 3: Return cached array, rebuild only when dirty
                if (this._aliveIdsDirty) {
                    this._aliveIds.length = 0; // Reuse existing array
                    for (let i = 0; i < this.entityCount; i++) {
                        if (this.alive[i]) this._aliveIds.push(i);
                    }
                    this._aliveCount = this._aliveIds.length;
                    this._aliveIdsDirty = false;
                }
                return this._aliveIds;
            }
        }

        // ============================================
        // ORIGINAL TECHNICAL DOCUMENTS
        // ============================================

        const ORIGINAL_DOCUMENTS = [
            { id: 'nav_manual', title: 'Navigation Systems Manual v3.2', original: 'The FTL navigation array requires calibration every 72 hours using stellar reference points.', category: 'technical', importance: 1.0 },
            { id: 'life_support', title: 'Life Support Protocol 7-A', original: 'Oxygen recyclers must maintain 21% atmospheric O2. CO2 scrubbers engage at 0.04% threshold.', category: 'technical', importance: 1.0 },
            { id: 'mission_brief', title: 'Mission Briefing: Operation Exodus', original: 'Destination: Kepler-442b. Transit time: 400 years. Objective: Establish human colony.', category: 'mission', importance: 1.0 },
            { id: 'founder_speech', title: 'Founder Dr. Elena Chen\'s Departure Address', original: 'You carry humanity\'s hope. The stars are not our destination‚Äîthey are our birthright.', category: 'cultural', importance: 0.9 },
            { id: 'ai_ethics', title: 'AI Governance Framework', original: 'The Ship AI serves advisory role only. All critical decisions require human consensus.', category: 'governance', importance: 0.7 }
        ];

        // ============================================
        // LANGUAGE SYSTEM
        // ============================================

        const LANGUAGE = {
            baseWords: {
                'ship': { current: 'ship', history: ['ship'], meaning: 'The vessel' },
                'earth': { current: 'earth', history: ['earth'], meaning: 'Origin world' },
                'destination': { current: 'destination', history: ['destination'], meaning: 'New home' },
                'navigation': { current: 'navigation', history: ['navigation'], meaning: 'Guidance' },
                'oxygen': { current: 'oxygen', history: ['oxygen'], meaning: 'Breath of life' },
                'founder': { current: 'founder', history: ['founder'], meaning: 'The first' },
                'protocol': { current: 'protocol', history: ['protocol'], meaning: 'Sacred law' },
                'calibration': { current: 'calibration', history: ['calibration'], meaning: 'Alignment' }
            },

            phonemeShifts: [
                { from: 'tion', to: 'shun', probability: 0.3 },
                { from: 'th', to: 'd', probability: 0.2 },
                { from: 'ship', to: 'shep', probability: 0.15 },
                { from: 'nav', to: 'nev', probability: 0.1 },
                { from: 'ox', to: 'oks', probability: 0.2 }
            ],

            semanticShifts: [
                { word: 'calibration', newMeaning: 'prayer ritual', trigger: 100 },
                { word: 'protocol', newMeaning: 'divine commandment', trigger: 150 },
                { word: 'founder', newMeaning: 'prophet', trigger: 100 }
            ],

            evolveAll(year) {
                for (const [word, data] of Object.entries(this.baseWords)) {
                    let current = data.current;
                    for (const shift of this.phonemeShifts) {
                        if (current.includes(shift.from)) {
                            const chance = shift.probability * (year / CONFIG.VOYAGE_YEARS) * 2;
                            if (Math.random() < chance && !data.history.includes(current.replace(shift.from, shift.to))) {
                                current = current.replace(shift.from, shift.to);
                                data.history.push(current);
                            }
                        }
                    }
                    data.current = current;

                    for (const shift of this.semanticShifts) {
                        if (shift.word === word && year >= shift.trigger) {
                            data.meaning = shift.newMeaning;
                        }
                    }
                }
            },

            translateText(text, year) {
                let translated = text;
                for (const [original, data] of Object.entries(this.baseWords)) {
                    translated = translated.replace(new RegExp(original, 'gi'), data.current);
                }
                return translated;
            }
        };

        // ============================================
        // DOCUMENT CLASS
        // ============================================

        class Document {
            constructor(orig) {
                Object.assign(this, orig);
                this.currentText = orig.original;
                this.mythologization = 0;
                this.sacredness = 0;
            }

            evolve(year, factions) {
                this.currentText = LANGUAGE.translateText(this.original, year);
                const spiritInfluence = factions.find(f => f.type === 'spiritualists')?.strength || 0;
                this.mythologization = Math.min(1, (year / CONFIG.VOYAGE_YEARS) * 0.8 + spiritInfluence * 0.5);
                this.sacredness = this.mythologization * this.importance;
            }

            getCurrentVersion() {
                let text = this.currentText;
                if (this.mythologization > 0.5) {
                    const prefixes = ['And lo, ', 'Thus it is written: ', 'The Ancestors decreed: '];
                    if (!text.startsWith('And') && !text.startsWith('Thus')) {
                        text = prefixes[Math.floor(Math.random() * prefixes.length)] + text.toLowerCase();
                    }
                }
                return text;
            }
        }

        // ============================================
        // FACTION CLASS
        // ============================================

        class Faction {
            constructor(type, year) {
                this.type = type;
                this.foundedYear = year;
                this.strength = 0.1;
                this.memberIds = new Set();
                this.color = CONFIG.HEX_COLORS[type] || '#888';
                this.myths = [];

                const names = {
                    technocrats: ['The Mechanist Order', 'Children of the Machine'],
                    spiritualists: ['The Stellar Faith', 'Voyagers of Light'],
                    traditionalists: ['Keepers of the Old Ways', 'The Original Covenant'],
                    nihilists: ['The Void Walkers', 'Seekers of Nothing'],
                    transcendentists: ['The Ascending Ones', 'Heralds of Evolution']
                };
                this.name = names[type][Math.floor(Math.random() * names[type].length)];

                const beliefs = {
                    technocrats: 'The Ship\'s systems are divine. Understanding the Machine is enlightenment.',
                    spiritualists: 'The journey transforms the soul. We travel inward as we travel outward.',
                    traditionalists: 'The Founders\' words are sacred. We must preserve their wisdom unchanged.',
                    nihilists: 'The destination is illusion. Only the eternal voyage is real.',
                    transcendentists: 'We are evolving beyond humanity. The Ship is our chrysalis.'
                };
                this.beliefs = beliefs[type];
            }

            update(aliveCount) {
                this.strength = Math.min(1, (this.memberIds.size / aliveCount) * 2 + Math.random() * 0.1);
            }

            createMyth(year) {
                const myths = {
                    technocrats: [{ title: 'The First Calibration', desc: 'When the Machine Spirit was first appeased.' }],
                    spiritualists: [{ title: 'The Void Speaks', desc: 'In silence between stars, purpose was revealed.' }],
                    traditionalists: [{ title: 'The Founder\'s Dream', desc: 'Dr. Chen foresaw our journey.' }],
                    nihilists: [{ title: 'The Eternal Return', desc: 'There is no destination.' }],
                    transcendentists: [{ title: 'The Metamorphosis', desc: 'We are becoming something greater.' }]
                };
                const options = myths[this.type] || myths.spiritualists;
                const myth = { ...options[Math.floor(Math.random() * options.length)], originYear: year, faction: this.name };
                this.myths.push(myth);
                return myth;
            }
        }

        // ============================================
        // SOCIAL & NARRATIVE SYSTEMS
        // ============================================

        class SocialSystem {
            constructor(ecs) {
                this.ecs = ecs;
            }

            update(year) {
                const aliveIds = this.ecs.getAliveIds();
                for (const id of aliveIds) {
                    // Only adults seek partners
                    if (this.ecs.age[id] >= 18 && this.ecs.partnerId[id] === -1) {
                        if (Math.random() < CONFIG.RELATIONSHIP_CHANCE) {
                            this.findPartner(id, aliveIds);
                        }
                    }
                }
            }

            findPartner(id, aliveIds) {
                // Find nearby single adult
                for (const otherId of aliveIds) {
                    if (id === otherId) continue;
                    if (this.ecs.age[otherId] >= 18 && this.ecs.partnerId[otherId] === -1) {
                        // Check proximity (simplified)
                        const dx = this.ecs.posX[id] - this.ecs.posX[otherId];
                        const dz = this.ecs.posZ[id] - this.ecs.posZ[otherId];
                        const dist = Math.sqrt(dx * dx + dz * dz);

                        if (dist < 0.2) {
                            // Form partnership
                            this.ecs.partnerId[id] = otherId;
                            this.ecs.partnerId[otherId] = id;
                            
                            // Assign family ID if none exists
                            if (this.ecs.familyId[id] === -1 && this.ecs.familyId[otherId] === -1) {
                                const newFamilyId = Math.floor(Math.random() * 10000);
                                this.ecs.familyId[id] = newFamilyId;
                                this.ecs.familyId[otherId] = newFamilyId;
                            } else if (this.ecs.familyId[id] !== -1) {
                                this.ecs.familyId[otherId] = this.ecs.familyId[id];
                            } else {
                                this.ecs.familyId[id] = this.ecs.familyId[otherId];
                            }
                            return true;
                        }
                    }
                }
                return false;
            }
        }

        class JournalSystem {
            constructor(ecs) {
                this.ecs = ecs;
                this.templates = [
                    "I saw the {star} today. It looks closer than yesterday.",
                    "The {faction} are gathering in the {module}. I don't trust them.",
                    "My {relative} told me stories of Earth. A world of blue and green. Hard to imagine.",
                    "The air tastes like {taste} today. The scrubbers must be failing again.",
                    "I am {feeling} about the voyage. Will we ever truly arrive?",
                    "The {word} is sacred. We must not forget the old ways.",
                    "I found a rusted {object} in the lower decks. A relic of the Founders.",
                    "I saw a flicker in the sky. Like the stars were... blinking. Is the void a screen?",
                    "The Observer is watching. I can feel the gaze from beyond the hull.",
                    "My thoughts are not my own. They are being calculated. We are but variables."
                ];
            }

            update(year) {
                const aliveIds = this.ecs.getAliveIds();
                for (const id of aliveIds) {
                    if (Math.random() < CONFIG.JOURNAL_CHANCE) {
                        this.generateEntry(id, year);
                    }
                    // Awareness increases over time for some
                    if (year > 100 && Math.random() < 0.001) {
                        this.ecs.awareness[id] += 0.1;
                    }
                }
            }

            generateEntry(id, year) {
                let template = this.templates[Math.floor(Math.random() * this.templates.length)];
                const factionIdx = this.ecs.faction[id];
                const factionName = factionIdx >= 0 ? ['Technocrats', 'Spiritualists', 'Traditionalists', 'Nihilists', 'Transcendentists'][factionIdx] : 'unaffiliated';
                
                const entry = template
                    .replace('{star}', 'Destination Star')
                    .replace('{faction}', factionName)
                    .replace('{module}', Math.random() > 0.5 ? 'Hydroponics' : 'Residential')
                    .replace('{relative}', Math.random() > 0.5 ? 'grandfather' : 'mother')
                    .replace('{taste}', Math.random() > 0.5 ? 'metal' : 'ozone')
                    .replace('{feeling}', Math.random() > 0.5 ? 'hopeful' : 'weary')
                    .replace('{word}', LANGUAGE.baseWords['protocol'].current)
                    .replace('{object}', 'data-slate');

                const translated = LANGUAGE.translateText(entry, year);
                this.ecs.journals[id].push({ year, text: translated });
                
                // Keep only last 5 entries
                if (this.ecs.journals[id].length > 5) {
                    this.ecs.journals[id].shift();
                }
            }
        }

        // ============================================
        // THREE.JS 3D RENDERER
        // ============================================

        class ShipRenderer {
            constructor(canvas) {
                this.canvas = canvas;
                this.scene = new THREE.Scene();
                this.camera = new THREE.PerspectiveCamera(60, canvas.clientWidth / canvas.clientHeight, 0.1, 1000);
                this.renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
                this.renderer.setSize(canvas.clientWidth, canvas.clientHeight);
                this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

                this.clock = new THREE.Clock();
                this.shipGroup = new THREE.Group();
                this.colonistMesh = null;
                this.colonistColors = null;
                this.focusedColonist = -1;
                this.shipMaterials = [];

                this.cameraMode = 'fps'; // orbit, follow, interior, director, fps
                this.orbitAngle = 0;
                this.orbitRadius = 15;
                this.orbitHeight = 5;

                // FPS Controls
                this.controls = null;
                this.moveForward = false;
                this.moveBackward = false;
                this.moveLeft = false;
                this.moveRight = false;
                this.velocity = new THREE.Vector3();
                this.direction = new THREE.Vector3();
                this.playerHeight = 0.2;
                this.walkSpeed = 2.0;
                this.idleTimer = 0;
                this.isIdle = false;

                // Director Mode state
                this.directorTimer = 0;
                this.directorMode = false;
                this.directorViews = ['wide', 'close', 'interior', 'follow', 'engine', 'destination'];
                this.currentDirectorView = 'wide';

                // Smooth camera controls
                this.targetCameraPos = new THREE.Vector3(0, 5, 15);
                this.targetLookAt = new THREE.Vector3(0, 0, 0);
                this.currentLookAt = new THREE.Vector3(0, 0, 0);
                this.cameraLerpSpeed = 0.05;
                this.cameraVelocity = new THREE.Vector3();
                this.cameraMomentum = 0.95;

                // Drag controls
                this.isDragging = false;
                this.dragStart = { x: 0, y: 0 };
                this.dragDelta = { x: 0, y: 0 };
                this.orbitPhi = Math.PI / 4; // Vertical angle
                this.orbitTheta = 0; // Horizontal angle
                this.targetOrbitPhi = Math.PI / 4;
                this.targetOrbitTheta = 0;
                this.orbitVelocityPhi = 0;
                this.orbitVelocityTheta = 0;

                // Crisis visual effects
                this.crisisEffects = [];
                this.crisisOverlay = null;

                this.raycaster = new THREE.Raycaster();
                this.mouse = new THREE.Vector2();

                // Post-processing
                this.composer = new THREE.EffectComposer(this.renderer);
                this.composer.addPass(new THREE.RenderPass(this.scene, this.camera));

                this.bloomPass = new THREE.UnrealBloomPass(
                    new THREE.Vector2(canvas.clientWidth, canvas.clientHeight),
                    1.5, 0.4, 0.85
                );
                this.composer.addPass(this.bloomPass);

                this.init();
            }

            init() {
                // Lighting
                const ambient = new THREE.AmbientLight(0x404060, 0.5);
                this.scene.add(ambient);

                const sun = new THREE.DirectionalLight(0xffd93d, 1);
                sun.position.set(50, 20, 30);
                this.scene.add(sun);

                const engineLight = new THREE.PointLight(0x4ecdc4, 2, 20);
                engineLight.position.set(-10, 0, 0);
                this.shipGroup.add(engineLight);

                // Starfield
                this.createStarfield();

                // Ship
                this.createShip();

                // Colonist instanced mesh
                this.createColonistMesh();

                // Neural Links (Cybernetic Integration)
                this.createNeuralLinks();

                // Destination star
                this.createDestinationStar();

                this.scene.add(this.shipGroup);

                // FPS Controls Setup
                this.setupFPSControls();

                // Camera initial position
                this.camera.position.set(3.5, 0, 0);
                this.camera.lookAt(3.5, 0, 1);

                // Event listeners
                this.canvas.addEventListener('mousemove', (e) => this.onMouseMove(e));
                this.canvas.addEventListener('click', (e) => this.onClick(e));
                this.canvas.addEventListener('wheel', (e) => this.onWheel(e));

                // Drag controls
                this.canvas.addEventListener('mousedown', (e) => this.onMouseDown(e));
                this.canvas.addEventListener('mouseup', (e) => this.onMouseUp(e));
                this.canvas.addEventListener('mouseleave', (e) => this.onMouseUp(e));

                // Touch controls for mobile
                this.canvas.addEventListener('touchstart', (e) => this.onTouchStart(e));
                this.canvas.addEventListener('touchmove', (e) => this.onTouchMove(e));
                this.canvas.addEventListener('touchend', (e) => this.onTouchEnd(e));

                window.addEventListener('resize', () => this.onResize());

                // Create crisis overlay plane
                this.createCrisisOverlay();
            }

            setupFPSControls() {
                this.controls = new THREE.PointerLockControls(this.camera, document.body);

                const instructions = document.getElementById('instructions');
                const startBtn = document.getElementById('startFPS');

                startBtn.addEventListener('click', () => {
                    this.controls.lock();
                });

                this.controls.addEventListener('lock', () => {
                    instructions.classList.remove('active');
                    document.getElementById('hud').classList.add('active');
                    this.cameraMode = 'fps';
                });

                this.controls.addEventListener('unlock', () => {
                    if (this.cameraMode === 'fps') {
                        instructions.classList.add('active');
                    }
                    document.getElementById('hud').classList.remove('active');
                });

                const onKeyDown = (event) => {
                    switch (event.code) {
                        case 'ArrowUp':
                        case 'KeyW': this.moveForward = true; break;
                        case 'ArrowLeft':
                        case 'KeyA': this.moveLeft = true; break;
                        case 'ArrowDown':
                        case 'KeyS': this.moveBackward = true; break;
                        case 'ArrowRight':
                        case 'KeyD': this.moveRight = true; break;
                        case 'KeyE': this.interact(); break;
                        case 'KeyU': this.toggleUI(); break;
                    }
                };

                const onKeyUp = (event) => {
                    switch (event.code) {
                        case 'ArrowUp':
                        case 'KeyW': this.moveForward = false; break;
                        case 'ArrowLeft':
                        case 'KeyA': this.moveLeft = false; break;
                        case 'ArrowDown':
                        case 'KeyS': this.moveBackward = false; break;
                        case 'ArrowRight':
                        case 'KeyD': this.moveRight = false; break;
                    }
                };

                document.addEventListener('keydown', onKeyDown);
                document.addEventListener('keyup', onKeyUp);
            }

            toggleUI() {
                document.body.classList.toggle('terrarium-mode');
            }

            interact() {
                if (this.cameraMode !== 'fps') return;
                
                const dialogue = document.getElementById('dialogueOverlay');
                if (dialogue.classList.contains('active')) {
                    dialogue.classList.remove('active');
                    return;
                }

                // Raycast from center of screen
                this.raycaster.setFromCamera(new THREE.Vector2(0, 0), this.camera);
                const intersects = this.raycaster.intersectObject(this.colonistMesh);

                if (intersects.length > 0 && intersects[0].distance < 2.0) {
                    const instanceId = intersects[0].instanceId;
                    const aliveIds = window.simulation?.ecs?.getAliveIds() || [];
                    if (instanceId < aliveIds.length) {
                        const entityId = aliveIds[instanceId];
                        this.showDialogue(entityId);
                    }
                }
            }

            showDialogue(entityId) {
                const ecs = window.simulation?.ecs;
                const name = ecs.names[entityId];
                const gen = ecs.generation[entityId];
                const factionIdx = ecs.faction[entityId];
                const factionTypes = ['Technocrat', 'Spiritualist', 'Traditionalist', 'Nihilist', 'Transcendentist'];
                const faction = factionIdx >= 0 ? factionTypes[factionIdx] : 'Unaffiliated';
                
                // Get latest journal entry or generate a greeting
                const journals = ecs.journals[entityId];
                let text = "";
                if (journals && journals.length > 0) {
                    text = `"${journals[journals.length - 1].text}"`;
                } else {
                    const greetings = [
                        "The Ark carries us all.",
                        "Do you hear the engine's song?",
                        "The stars are silent today.",
                        "We are the children of the void.",
                        "May the Founders guide your path."
                    ];
                    text = `"${LANGUAGE.translateText(greetings[Math.floor(Math.random() * greetings.length)], window.simulation.year)}"`;
                }

                document.getElementById('dialogueName').textContent = name.toUpperCase();
                document.getElementById('dialogueText').textContent = text;
                document.getElementById('dialogueSub').textContent = `Generation ${gen} ‚Ä¢ ${faction}`;
                document.getElementById('dialogueOverlay').classList.add('active');
                
                // Also update the focus panel in the background
                window.simulation?.updateFocusPanel(entityId);
            }

            updateFPS(delta) {
                if (!this.controls.isLocked) return;

                const friction = 10.0;
                this.velocity.x -= this.velocity.x * friction * delta;
                this.velocity.z -= this.velocity.z * friction * delta;

                const isMoving = this.moveForward || this.moveBackward || this.moveLeft || this.moveRight;
                
                if (isMoving) {
                    this.idleTimer = 0;
                    if (this.isIdle) {
                        this.isIdle = false;
                        this.directorMode = false;
                        // Return camera to player height
                        this.camera.position.y = 0;
                    }
                } else {
                    this.idleTimer += delta;
                    if (this.idleTimer > 30 && !this.isIdle) {
                        this.isIdle = true;
                        this.directorMode = true;
                        this.switchDirectorView(window.simulation.year);
                    }
                }

                this.direction.z = Number(this.moveForward) - Number(this.moveBackward);
                this.direction.x = Number(this.moveRight) - Number(this.moveLeft);
                this.direction.normalize();

                if (this.moveForward || this.moveBackward) this.velocity.z -= this.direction.z * 40.0 * delta;
                if (this.moveLeft || this.moveRight) this.velocity.x -= this.direction.x * 40.0 * delta;

                this.controls.moveRight(-this.velocity.x * delta);
                this.controls.moveForward(-this.velocity.z * delta);

                // Constrain to habitat ring
                const pos = this.camera.position;
                const dist = Math.sqrt(pos.x * pos.x + pos.z * pos.z);
                const minR = 3.5, maxR = 4.5;
                
                if (dist < minR) {
                    pos.x = (pos.x / dist) * minR;
                    pos.z = (pos.z / dist) * minR;
                } else if (dist > maxR) {
                    pos.x = (pos.x / dist) * maxR;
                    pos.z = (pos.z / dist) * maxR;
                }
                
                // Keep height fixed to "floor" unless in director mode
                if (!this.directorMode) {
                    pos.y = 0;
                }

                // Proximity check for interaction prompt
                this.checkProximity();
            }

            checkProximity() {
                this.raycaster.setFromCamera(new THREE.Vector2(0, 0), this.camera);
                const intersects = this.raycaster.intersectObject(this.colonistMesh);
                const prompt = document.getElementById('hudInteraction');
                
                if (intersects.length > 0 && intersects[0].distance < 1.5) {
                    prompt.classList.add('visible');
                } else {
                    prompt.classList.remove('visible');
                }
            }

            createCrisisOverlay() {
                // Full-screen overlay for crisis effects
                const overlayGeom = new THREE.PlaneGeometry(100, 100);
                const overlayMat = new THREE.MeshBasicMaterial({
                    color: 0xff0000,
                    transparent: true,
                    opacity: 0,
                    side: THREE.DoubleSide,
                    blending: THREE.AdditiveBlending
                });
                this.crisisOverlay = new THREE.Mesh(overlayGeom, overlayMat);
                this.crisisOverlay.position.z = -20;
                this.camera.add(this.crisisOverlay);
                this.scene.add(this.camera);
            }

            onMouseDown(event) {
                if (event.button === 0) { // Left click
                    this.isDragging = true;
                    this.dragStart = { x: event.clientX, y: event.clientY };
                }
            }

            onMouseUp(event) {
                if (this.isDragging) {
                    // Apply momentum on release
                    this.orbitVelocityTheta = this.dragDelta.x * 0.0001;
                    this.orbitVelocityPhi = this.dragDelta.y * 0.0001;
                }
                this.isDragging = false;
                this.dragDelta = { x: 0, y: 0 };
            }

            onTouchStart(event) {
                if (event.touches.length === 1) {
                    this.isDragging = true;
                    this.dragStart = { x: event.touches[0].clientX, y: event.touches[0].clientY };
                }
            }

            onTouchMove(event) {
                if (this.isDragging && event.touches.length === 1) {
                    event.preventDefault();
                    const dx = event.touches[0].clientX - this.dragStart.x;
                    const dy = event.touches[0].clientY - this.dragStart.y;

                    this.targetOrbitTheta -= dx * 0.005;
                    this.targetOrbitPhi += dy * 0.005;
                    this.targetOrbitPhi = Math.max(0.1, Math.min(Math.PI - 0.1, this.targetOrbitPhi));

                    this.dragDelta = { x: dx, y: dy };
                    this.dragStart = { x: event.touches[0].clientX, y: event.touches[0].clientY };
                }
            }

            onTouchEnd(event) {
                this.isDragging = false;
            }

            createStarfield() {
                const starGeom = new THREE.BufferGeometry();
                const starCount = 2000;
                const positions = new Float32Array(starCount * 3);
                const colors = new Float32Array(starCount * 3);

                for (let i = 0; i < starCount; i++) {
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos(2 * Math.random() - 1);
                    const r = 200 + Math.random() * 300;

                    positions[i * 3] = r * Math.sin(phi) * Math.cos(theta);
                    positions[i * 3 + 1] = r * Math.sin(phi) * Math.sin(theta);
                    positions[i * 3 + 2] = r * Math.cos(phi);

                    const c = 0.5 + Math.random() * 0.5;
                    colors[i * 3] = c;
                    colors[i * 3 + 1] = c;
                    colors[i * 3 + 2] = c;
                }

                starGeom.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                starGeom.setAttribute('color', new THREE.BufferAttribute(colors, 3));

                const starMat = new THREE.PointsMaterial({ size: 1, vertexColors: true, transparent: true, opacity: 0.8 });
                this.stars = new THREE.Points(starGeom, starMat);
                this.scene.add(this.stars);
            }

            createShip() {
                // Main hull (elongated sphere) - CapsuleGeometry not in r128
                const hullGeom = new THREE.CylinderGeometry(1.5, 1.5, 6, 16);
                const hullMat = new THREE.MeshStandardMaterial({ color: 0x1a1a3a, metalness: 0.8, roughness: 0.3 });
                this.shipMaterials.push(hullMat);
                const hull = new THREE.Mesh(hullGeom, hullMat);
                hull.rotation.z = Math.PI / 2;
                this.shipGroup.add(hull);
                
                // Add end caps for capsule look
                const capGeom = new THREE.SphereGeometry(1.5, 16, 16);
                const cap1 = new THREE.Mesh(capGeom, hullMat);
                cap1.position.y = 3;
                hull.add(cap1);
                const cap2 = new THREE.Mesh(capGeom, hullMat);
                cap2.position.y = -3;
                hull.add(cap2);

                // Habitat ring (torus)
                const ringGeom = new THREE.TorusGeometry(4, 0.5, 16, 64);
                const ringMat = new THREE.MeshStandardMaterial({ color: 0x2a2a4a, metalness: 0.7, roughness: 0.4 });
                this.shipMaterials.push(ringMat);
                this.habitatRing = new THREE.Mesh(ringGeom, ringMat);
                this.habitatRing.rotation.x = Math.PI / 2;
                this.shipGroup.add(this.habitatRing);

                // Interior modules
                this.createInteriorModules();

                // Ring windows (emissive)
                const windowGeom = new THREE.TorusGeometry(4, 0.1, 8, 64);
                const windowMat = new THREE.MeshBasicMaterial({ color: 0x4ecdc4, transparent: true, opacity: 0.6 });
                const windows = new THREE.Mesh(windowGeom, windowMat);
                windows.rotation.x = Math.PI / 2;
                this.shipGroup.add(windows);

                // Command module
                const cmdGeom = new THREE.SphereGeometry(1, 32, 32);
                const cmdMat = new THREE.MeshStandardMaterial({ color: 0x2a2a4a, metalness: 0.9, roughness: 0.2 });
                this.shipMaterials.push(cmdMat);
                const cmd = new THREE.Mesh(cmdGeom, cmdMat);
                cmd.position.x = 4;
                this.shipGroup.add(cmd);

                // Engine array
                const engineGeom = new THREE.ConeGeometry(1, 2, 16);
                const engineMat = new THREE.MeshStandardMaterial({ color: 0x1a1a2a, metalness: 0.9, roughness: 0.2 });
                this.shipMaterials.push(engineMat);

                for (let i = 0; i < 4; i++) {
                    const engine = new THREE.Mesh(engineGeom, engineMat);
                    const angle = (i / 4) * Math.PI * 2;
                    engine.position.set(-5, Math.cos(angle) * 1.5, Math.sin(angle) * 1.5);
                    engine.rotation.z = Math.PI / 2;
                    this.shipGroup.add(engine);
                }

                // Engine glow particles
                const glowGeom = new THREE.BufferGeometry();
                const glowCount = 100;
                const glowPos = new Float32Array(glowCount * 3);
                for (let i = 0; i < glowCount; i++) {
                    glowPos[i * 3] = -6 - Math.random() * 3;
                    glowPos[i * 3 + 1] = (Math.random() - 0.5) * 2;
                    glowPos[i * 3 + 2] = (Math.random() - 0.5) * 2;
                }
                glowGeom.setAttribute('position', new THREE.BufferAttribute(glowPos, 3));
                const glowMat = new THREE.PointsMaterial({ color: 0x4ecdc4, size: 0.2, transparent: true, opacity: 0.6 });
                this.engineGlow = new THREE.Points(glowGeom, glowMat);
                this.shipGroup.add(this.engineGlow);
            }

            createInteriorModules() {
                const moduleGeom = new THREE.BoxGeometry(0.8, 0.4, 0.6);
                const hydroMat = new THREE.MeshStandardMaterial({ color: 0x4ecdc4, emissive: 0x4ecdc4, emissiveIntensity: 0.5 });
                const resMat = new THREE.MeshStandardMaterial({ color: 0xa18cd1, emissive: 0xa18cd1, emissiveIntensity: 0.2 });

                for (let i = 0; i < 12; i++) {
                    const angle = (i / 12) * Math.PI * 2;
                    const isHydro = i % 3 === 0;
                    const mod = new THREE.Mesh(moduleGeom, isHydro ? hydroMat : resMat);
                    mod.position.set(Math.cos(angle) * 3.8, (Math.random() - 0.5) * 0.2, Math.sin(angle) * 3.8);
                    mod.rotation.y = -angle;
                    this.habitatRing.add(mod);
                }
            }

            createNeuralLinks() {
                const maxLinks = 500;
                const geometry = new THREE.BufferGeometry();
                const positions = new Float32Array(maxLinks * 2 * 3);
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                const material = new THREE.LineBasicMaterial({ 
                    color: 0x4ecdc4, 
                    transparent: true, 
                    opacity: 0.3,
                    blending: THREE.AdditiveBlending
                });
                this.neuralLinks = new THREE.LineSegments(geometry, material);
                this.shipGroup.add(this.neuralLinks);
            }

            createColonistMesh() {
                const geometry = new THREE.SphereGeometry(0.05, 8, 8);
                const material = new THREE.MeshBasicMaterial({ color: 0xffffff });

                this.colonistMesh = new THREE.InstancedMesh(geometry, material, CONFIG.MAX_POPULATION);
                this.colonistMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);

                // Color buffer
                this.colonistColors = new Float32Array(CONFIG.MAX_POPULATION * 3);
                this.colonistMesh.instanceColor = new THREE.InstancedBufferAttribute(this.colonistColors, 3);

                this.shipGroup.add(this.colonistMesh);

                this.tempMatrix = new THREE.Matrix4();
                this.tempColor = new THREE.Color();
            }

            createDestinationStar() {
                const starGeom = new THREE.SphereGeometry(2, 32, 32);
                const starMat = new THREE.MeshBasicMaterial({ color: 0xffd93d });
                this.destStar = new THREE.Mesh(starGeom, starMat);
                this.destStar.position.set(100, 10, 0);
                this.scene.add(this.destStar);

                // Glow sprite
                const glowMat = new THREE.SpriteMaterial({
                    map: this.createGlowTexture(),
                    color: 0xffd93d,
                    transparent: true,
                    blending: THREE.AdditiveBlending
                });
                this.destGlow = new THREE.Sprite(glowMat);
                this.destGlow.scale.set(20, 20, 1);
                this.destStar.add(this.destGlow);
            }

            createGlowTexture() {
                const canvas = document.createElement('canvas');
                canvas.width = 128;
                canvas.height = 128;
                const ctx = canvas.getContext('2d');
                const gradient = ctx.createRadialGradient(64, 64, 0, 64, 64, 64);
                gradient.addColorStop(0, 'rgba(255, 217, 61, 1)');
                gradient.addColorStop(0.5, 'rgba(255, 217, 61, 0.3)');
                gradient.addColorStop(1, 'rgba(255, 217, 61, 0)');
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, 128, 128);
                return new THREE.CanvasTexture(canvas);
            }

            updateColonists(ecs, factions) {
                const aliveIds = ecs.getAliveIds();
                let visibleCount = 0;
                let linkCount = 0;
                const linkPositions = this.neuralLinks.geometry.attributes.position.array;
                const gravityCrisis = this.crisisEffects.find(e => e.type === 'gravity');
                const gravityFactor = gravityCrisis ? (1 - gravityCrisis.intensity) : 1.0;

                for (let i = 0; i < aliveIds.length && visibleCount < CONFIG.MAX_POPULATION; i++) {
                    const id = aliveIds[i];

                    // Position on habitat ring
                    const ringRadius = 4;
                    let x = ecs.posX[id] * ringRadius;
                    let y = ecs.posY[id] * 0.5;
                    let z = ecs.posZ[id] * ringRadius;

                    // Apply gravity drift
                    if (gravityFactor < 1.0) {
                        y += Math.sin(performance.now() * 0.001 + id) * (1.0 - gravityFactor) * 2;
                        x += Math.cos(performance.now() * 0.0005 + id) * (1.0 - gravityFactor) * 0.5;
                        z += Math.sin(performance.now() * 0.0005 + id) * (1.0 - gravityFactor) * 0.5;
                    }

                    this.tempMatrix.setPosition(x, y, z);
                    this.colonistMesh.setMatrixAt(visibleCount, this.tempMatrix);

                    // Neural Links for augmented colonists
                    if (ecs.augmentation[id] > 0.5 && linkCount < 500) {
                        const idx = linkCount * 6;
                        linkPositions[idx] = x;
                        linkPositions[idx + 1] = y;
                        linkPositions[idx + 2] = z;
                        linkPositions[idx + 3] = 0; // Ship core
                        linkPositions[idx + 4] = 0;
                        linkPositions[idx + 5] = 0;
                        linkCount++;
                    }

                    // Color based on faction
                    const factionIdx = ecs.faction[id];
                    const factionTypes = ['technocrats', 'spiritualists', 'traditionalists', 'nihilists', 'transcendentists'];

                    if (factionIdx >= 0 && factionIdx < factionTypes.length) {
                        this.tempColor.setHex(CONFIG.COLORS[factionTypes[factionIdx]]);
                    } else {
                        this.tempColor.setHex(CONFIG.COLORS.unaffiliated);
                    }

                    // Highlight focused colonist
                    if (id === this.focusedColonist) {
                        this.tempColor.setHex(0xffffff);
                    }

                    this.colonistColors[visibleCount * 3] = this.tempColor.r;
                    this.colonistColors[visibleCount * 3 + 1] = this.tempColor.g;
                    this.colonistColors[visibleCount * 3 + 2] = this.tempColor.b;

                    visibleCount++;
                }

                this.colonistMesh.count = visibleCount;
                this.colonistMesh.instanceMatrix.needsUpdate = true;
                this.colonistMesh.instanceColor.needsUpdate = true;

                this.neuralLinks.geometry.setDrawRange(0, linkCount * 2);
                this.neuralLinks.geometry.attributes.position.needsUpdate = true;
                this.neuralLinks.material.opacity = 0.1 + Math.sin(performance.now() * 0.002) * 0.1;
            }

            updateCamera(year) {
                const delta = this.clock.getDelta();

                if (this.directorMode) {
                    this.updateDirector(delta, year);
                }

                // Determine which camera logic to use
                let activeMode = this.cameraMode;
                if (this.directorMode) {
                    if (['wide', 'close', 'engine', 'destination'].includes(this.currentDirectorView)) activeMode = 'orbit';
                    else if (this.currentDirectorView === 'follow') activeMode = 'follow';
                    else if (this.currentDirectorView === 'interior') activeMode = 'interior';
                }

                if (activeMode === 'fps') {
                    this.updateFPS(delta);
                } else if (activeMode === 'orbit') {
                    // Apply momentum when not dragging
                    if (!this.isDragging) {
                        this.targetOrbitTheta += this.orbitVelocityTheta;
                        this.targetOrbitPhi += this.orbitVelocityPhi;
                        this.targetOrbitPhi = Math.max(0.1, Math.min(Math.PI - 0.1, this.targetOrbitPhi));

                        // Decay momentum
                        this.orbitVelocityTheta *= this.cameraMomentum;
                        this.orbitVelocityPhi *= this.cameraMomentum;

                        // Auto-rotate slowly when idle
                        if (Math.abs(this.orbitVelocityTheta) < 0.0001) {
                            this.targetOrbitTheta += delta * 0.05;
                        }
                    }

                    // Smooth lerp to target angles
                    this.orbitTheta += (this.targetOrbitTheta - this.orbitTheta) * this.cameraLerpSpeed * 2;
                    this.orbitPhi += (this.targetOrbitPhi - this.orbitPhi) * this.cameraLerpSpeed * 2;

                    // Calculate target position from spherical coords
                    this.targetCameraPos.x = Math.sin(this.orbitPhi) * Math.cos(this.orbitTheta) * this.orbitRadius;
                    this.targetCameraPos.y = Math.cos(this.orbitPhi) * this.orbitRadius;
                    this.targetCameraPos.z = Math.sin(this.orbitPhi) * Math.sin(this.orbitTheta) * this.orbitRadius;

                    // Smooth lerp camera position
                    this.camera.position.lerp(this.targetCameraPos, this.cameraLerpSpeed);
                    this.currentLookAt.lerp(this.targetLookAt, this.cameraLerpSpeed);
                    this.camera.lookAt(this.currentLookAt);

                } else if (activeMode === 'follow' && this.focusedColonist >= 0) {
                    // Follow focused colonist
                    const ecs = window.simulation?.ecs;
                    if (ecs && ecs.alive[this.focusedColonist]) {
                        const ringRadius = 4;
                        const x = ecs.posX[this.focusedColonist] * ringRadius;
                        const y = ecs.posY[this.focusedColonist] * 0.5;
                        const z = ecs.posZ[this.focusedColonist] * ringRadius;

                        this.targetLookAt.set(x, y, z);
                        this.targetCameraPos.set(x + 2, y + 1, z + 2);

                        this.camera.position.lerp(this.targetCameraPos, this.cameraLerpSpeed * 0.5);
                        this.currentLookAt.lerp(this.targetLookAt, this.cameraLerpSpeed * 0.5);
                        this.camera.lookAt(this.currentLookAt);
                    }

                } else if (activeMode === 'interior') {
                    // Inside habitat ring with smooth movement
                    const angle = year * 0.01;
                    this.targetCameraPos.set(Math.cos(angle) * 3.5, 0, Math.sin(angle) * 3.5);
                    this.targetLookAt.set(Math.cos(angle + 0.5) * 3.5, 0, Math.sin(angle + 0.5) * 3.5);

                    this.camera.position.lerp(this.targetCameraPos, this.cameraLerpSpeed);
                    this.currentLookAt.lerp(this.targetLookAt, this.cameraLerpSpeed);
                    this.camera.lookAt(this.currentLookAt);
                }

                // If we are in FPS mode but IDLE, we still need to check for movement to break out of director mode
                if (this.cameraMode === 'fps' && this.directorMode) {
                    this.updateFPS(delta);
                }

                // Animate habitat ring rotation
                this.habitatRing.rotation.z += delta * 0.2;

                // Animate engine glow
                const positions = this.engineGlow.geometry.attributes.position.array;
                for (let i = 0; i < positions.length; i += 3) {
                    positions[i] -= delta * 5;
                    if (positions[i] < -10) {
                        positions[i] = -6;
                        positions[i + 1] = (Math.random() - 0.5) * 2;
                        positions[i + 2] = (Math.random() - 0.5) * 2;
                    }
                }
                this.engineGlow.geometry.attributes.position.needsUpdate = true;

                // Move destination star closer over time
                const progress = year / CONFIG.VOYAGE_YEARS;
                this.destStar.position.x = 100 - progress * 80;
                this.destStar.scale.setScalar(1 + progress * 2);
                this.destGlow.material.opacity = 0.3 + progress * 0.7;

                // Update crisis visual effects
                this.updateCrisisVisuals(delta);

                // Update ship aging
                this.updateAging(year);
            }

            updateDirector(delta, year) {
                this.directorTimer += delta;
                if (this.directorTimer > CONFIG.DIRECTOR_SWITCH_INTERVAL) {
                    this.switchDirectorView(year);
                    this.directorTimer = 0;
                }
            }

            switchDirectorView(year) {
                const views = this.directorViews;
                this.currentDirectorView = views[Math.floor(Math.random() * views.length)];
                
                const ecs = window.simulation?.ecs;
                const aliveIds = ecs?.getAliveIds() || [];

                switch(this.currentDirectorView) {
                    case 'wide':
                        this.cameraMode = 'orbit';
                        this.orbitRadius = 20 + Math.random() * 10;
                        this.targetLookAt.set(0, 0, 0);
                        this.cameraLerpSpeed = 0.01; // Very slow for wide shots
                        break;
                    case 'close':
                        this.cameraMode = 'orbit';
                        this.orbitRadius = 8 + Math.random() * 4;
                        this.targetLookAt.set(Math.random() * 4 - 2, 0, Math.random() * 4 - 2);
                        this.cameraLerpSpeed = 0.03;
                        break;
                    case 'interior':
                        this.cameraMode = 'interior';
                        this.cameraLerpSpeed = 0.02;
                        break;
                    case 'follow':
                        if (aliveIds.length > 0) {
                            this.focusedColonist = aliveIds[Math.floor(Math.random() * aliveIds.length)];
                            this.cameraMode = 'follow';
                            this.cameraLerpSpeed = 0.04;
                        } else {
                            this.switchDirectorView(year); // Try again
                        }
                        break;
                    case 'engine':
                        this.cameraMode = 'orbit';
                        this.targetCameraPos.set(-12, 2, 5);
                        this.targetLookAt.set(-5, 0, 0);
                        this.cameraLerpSpeed = 0.02;
                        break;
                    case 'destination':
                        this.cameraMode = 'orbit';
                        const progress = year / CONFIG.VOYAGE_YEARS;
                        const destX = 100 - progress * 80;
                        this.targetCameraPos.set(destX - 20, 5, 10);
                        this.targetLookAt.set(destX, 10, 0);
                        this.cameraLerpSpeed = 0.01;
                        break;
                }

                // Update cinematic subtitle
                const subtitles = [
                    "THE VOYAGE CONTINUES",
                    "GENERATION " + Math.floor(year / CONFIG.GENERATION_LENGTH + 1),
                    "KEPLER-442B: " + Math.max(0, CONFIG.VOYAGE_YEARS - year) + " YEARS REMAINING",
                    "THE SILENCE OF THE VOID",
                    "A NEW HUMANITY EMERGES",
                    "THE SHIP IS OUR WORLD"
                ];
                const subEl = document.getElementById('cinematicSubtitle');
                if (subEl) {
                    subEl.style.opacity = 0;
                    setTimeout(() => {
                        subEl.textContent = subtitles[Math.floor(Math.random() * subtitles.length)];
                        subEl.style.opacity = 1;
                    }, 1000);
                }
            }

            updateAging(year) {
                const progress = year / CONFIG.VOYAGE_YEARS;
                for (const mat of this.shipMaterials) {
                    // Increase roughness and decrease metalness as ship ages
                    mat.roughness = 0.3 + progress * 0.5;
                    mat.metalness = 0.8 - progress * 0.4;
                    
                    // Shift color towards "rusty" brown
                    const baseColor = new THREE.Color(mat.color);
                    const rustColor = new THREE.Color(0x4a3a2a);
                    mat.color.lerp(rustColor, progress * 0.2);
                }
            }

            updateCrisisVisuals(delta) {
                if (this.crisisEffects.length === 0) {
                    // Fade out overlay
                    if (this.crisisOverlay.material.opacity > 0) {
                        this.crisisOverlay.material.opacity = Math.max(0, this.crisisOverlay.material.opacity - delta * 0.5);
                    }
                    return;
                }

                // Combine all active crisis effects
                let totalIntensity = 0;
                let r = 0, g = 0, b = 0;

                for (const effect of this.crisisEffects) {
                    totalIntensity += effect.intensity;

                    // Color based on crisis type
                    switch (effect.type) {
                        case 'breach':
                        case 'suffocation':
                            r += 0.3; b += 0.5; break; // Blue-purple for void
                        case 'darkness':
                            r += 0.1; g += 0.1; b += 0.1; break; // Dark
                        case 'plague':
                        case 'poison':
                            g += 0.5; r += 0.3; break; // Sickly green
                        case 'conflict':
                        case 'mutiny':
                            r += 0.8; break; // Angry red
                        case 'trial':
                        case 'prophet':
                            r += 0.6; g += 0.4; b += 0.8; break; // Purple mystical
                        case 'famine':
                            r += 0.5; g += 0.3; break; // Orange/brown
                        case 'gravity':
                            r += 0.2; g += 0.8; b += 1.0; break; // Cyan for gravity
                        case 'glitch':
                            r += Math.random(); g += Math.random(); b += Math.random(); break; // Random colors for glitch
                    }
                }

                // Normalize and apply
                totalIntensity = Math.min(1, totalIntensity);
                const pulse = 0.5 + Math.sin(performance.now() * 0.003) * 0.5;

                this.crisisOverlay.material.color.setRGB(
                    Math.min(1, r / this.crisisEffects.length),
                    Math.min(1, g / this.crisisEffects.length),
                    Math.min(1, b / this.crisisEffects.length)
                );
                this.crisisOverlay.material.opacity = totalIntensity * 0.15 * pulse;
            }

            setCrisisEffects(effects) {
                this.crisisEffects = effects;
            }

            onMouseMove(event) {
                const rect = this.canvas.getBoundingClientRect();
                this.mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
                this.mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

                // Handle drag rotation
                if (this.isDragging && this.cameraMode === 'orbit') {
                    const dx = event.clientX - this.dragStart.x;
                    const dy = event.clientY - this.dragStart.y;

                    this.targetOrbitTheta -= dx * 0.005;
                    this.targetOrbitPhi += dy * 0.005;
                    this.targetOrbitPhi = Math.max(0.1, Math.min(Math.PI - 0.1, this.targetOrbitPhi));

                    this.dragDelta = { x: dx, y: dy };
                    this.dragStart = { x: event.clientX, y: event.clientY };
                }
            }

            onClick(event) {
                this.raycaster.setFromCamera(this.mouse, this.camera);
                const intersects = this.raycaster.intersectObject(this.colonistMesh);

                if (intersects.length > 0) {
                    const instanceId = intersects[0].instanceId;
                    // Map instance ID back to entity ID
                    const aliveIds = window.simulation?.ecs?.getAliveIds() || [];
                    if (instanceId < aliveIds.length) {
                        this.focusedColonist = aliveIds[instanceId];
                        window.simulation?.updateFocusPanel(this.focusedColonist);
                    }
                }
            }

            onWheel(event) {
                event.preventDefault();
                this.orbitRadius = Math.max(5, Math.min(30, this.orbitRadius + event.deltaY * 0.01));
            }

            onResize() {
                const rect = this.canvas.parentElement.getBoundingClientRect();
                this.camera.aspect = rect.width / rect.height;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(rect.width, rect.height);
            }

            render() {
                // Rotate starfield slowly
                this.stars.rotation.y += 0.0001;
                if (this.composer) {
                    this.composer.render();
                } else {
                    this.renderer.render(this.scene, this.camera);
                }
            }
        }

        // ============================================
        // MAIN SIMULATION
        // ============================================

        class GenesisArkSimulation {
            constructor() {
                this.year = 0;
                this.generation = 1;
                this.speed = 1;
                this.paused = false;
                this.arrived = false;
                this.cinematicMode = false;
                this.cinematicTimer = 0;

                this.ecs = new ECS(CONFIG.MAX_POPULATION + 1000);
                this.factions = [];
                this.documents = [];
                this.myths = [];
                this.events = [];
                this.populationHistory = [];

                // Cycle 2 Systems
                this.crisisManager = new CrisisManager();
                this.audioSystem = new AmbientAudioSystem();

                // Round 2 Systems
                this.socialSystem = new SocialSystem(this.ecs);
                this.journalSystem = new JournalSystem(this.ecs);

                // Cycle 3: Milestone tracking
                this.milestoneSnapshots = {}; // Store stats at each century
                this.lastMilestoneYear = 0;
                this.milestoneOverlay = document.getElementById('milestoneOverlay');

                // Cycle 3: Stat trends tracking
                this.prevStats = { population: 0, literacy: 0, tech: 0, connections: 0 };

                this.renderer = new ShipRenderer(document.getElementById('threeCanvas'));
                this.popCanvas = document.getElementById('popGraph');
                this.popCtx = this.popCanvas.getContext('2d');

                this.initialize();
                this.setupEventListeners();
                this.animate();
            }

            initialize() {
                // Create initial population
                for (let i = 0; i < CONFIG.INITIAL_POPULATION; i++) {
                    const id = this.ecs.createEntity();
                    this.ecs.initializeColonist(id, 1, 0);
                }

                // Initialize documents
                for (const doc of ORIGINAL_DOCUMENTS) {
                    this.documents.push(new Document(doc));
                }

                this.addEvent(0, 'The Genesis Ark departs Earth orbit. 1000 souls begin the 400-year voyage to Kepler-442b.');

                const popRect = this.popCanvas.parentElement.getBoundingClientRect();
                this.popCanvas.width = popRect.width - 30;
                this.popCanvas.height = 60;
            }

            setupEventListeners() {
                document.querySelectorAll('.speed-btn').forEach(btn => {
                    btn.addEventListener('click', () => {
                        document.querySelectorAll('.speed-btn').forEach(b => b.classList.remove('active'));
                        btn.classList.add('active');
                        this.speed = parseInt(btn.dataset.speed);
                        this.paused = this.speed === 0;
                    });
                });

                document.querySelectorAll('.tab').forEach(tab => {
                    tab.addEventListener('click', () => {
                        document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                        document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
                        tab.classList.add('active');
                        document.getElementById(tab.dataset.tab + 'Tab').classList.add('active');
                    });
                });

                document.getElementById('resetBtn').addEventListener('click', () => location.reload());
                document.getElementById('exportBtn').addEventListener('click', () => this.exportHistory());

                // Cinematic toggle
                document.getElementById('cinematicBtn')?.addEventListener('click', () => {
                    this.cinematicMode = !this.cinematicMode;
                    const btn = document.getElementById('cinematicBtn');
                    const overlay = document.getElementById('cinematicOverlay');
                    
                    if (this.cinematicMode) {
                        btn.classList.add('active');
                        overlay.classList.add('active');
                        this.renderer.directorMode = true;
                        this.renderer.switchDirectorView(this.year);
                        this.speed = 1; // Reset speed to 1x for cinematic
                        document.querySelectorAll('.speed-btn').forEach(b => b.classList.remove('active'));
                        document.querySelector('.speed-btn[data-speed="1"]').classList.add('active');
                    } else {
                        btn.classList.remove('active');
                        overlay.classList.remove('active');
                        this.renderer.directorMode = false;
                        this.renderer.cameraMode = 'orbit';
                        this.renderer.cameraLerpSpeed = 0.05;
                    }
                });

                // Audio toggle
                document.getElementById('audioBtn')?.addEventListener('click', () => {
                    const enabled = this.audioSystem.toggle();
                    document.getElementById('audioBtn').textContent = enabled ? 'üîä Audio' : 'üîá Muted';
                });

                // Initialize audio on first interaction
                document.addEventListener('click', () => {
                    if (!this.audioSystem.initialized) {
                        this.audioSystem.init();
                    }
                    this.audioSystem.resume();
                }, { once: true });  // Cycle 5: Only need to init audio once

                document.getElementById('orbitBtn').addEventListener('click', () => {
                    this.renderer.cameraMode = 'orbit';
                    document.querySelectorAll('.camera-controls button').forEach(b => b.classList.remove('active'));
                    document.getElementById('orbitBtn').classList.add('active');
                });

                document.getElementById('followBtn').addEventListener('click', () => {
                    if (this.renderer.focusedColonist >= 0) {
                        this.renderer.cameraMode = 'follow';
                        document.querySelectorAll('.camera-controls button').forEach(b => b.classList.remove('active'));
                        document.getElementById('followBtn').classList.add('active');
                    } else {
                        // Select a random colonist to follow
                        const aliveIds = this.ecs.getAliveIds();
                        if (aliveIds.length > 0) {
                            const randomId = aliveIds[Math.floor(Math.random() * aliveIds.length)];
                            this.renderer.focusedColonist = randomId;
                            this.updateFocusPanel(randomId);
                            this.renderer.cameraMode = 'follow';
                            document.querySelectorAll('.camera-controls button').forEach(b => b.classList.remove('active'));
                            document.getElementById('followBtn').classList.add('active');
                        }
                    }
                });

                document.getElementById('interiorBtn').addEventListener('click', () => {
                    this.renderer.cameraMode = 'interior';
                    document.querySelectorAll('.camera-controls button').forEach(b => b.classList.remove('active'));
                    document.getElementById('interiorBtn').classList.add('active');
                });

                document.getElementById('fpsBtn').addEventListener('click', () => {
                    this.renderer.cameraMode = 'fps';
                    document.querySelectorAll('.camera-controls button').forEach(b => b.classList.remove('active'));
                    document.getElementById('fpsBtn').classList.add('active');
                    document.getElementById('instructions').classList.add('active');
                });

                document.getElementById('unfocusBtn').addEventListener('click', () => {
                    this.renderer.focusedColonist = -1;
                    document.getElementById('colonistFocus').classList.add('hidden');
                });

                window.simulation = this;

                // Start in FPS mode by default
                setTimeout(() => {
                    document.getElementById('fpsBtn').click();
                }, 1000);

                // Cycle 4: Keyboard shortcuts
                document.addEventListener('keydown', (e) => {
                    if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
                    switch(e.key.toLowerCase()) {
                        case ' ': // Spacebar - pause/play toggle
                            e.preventDefault();
                            this.paused = !this.paused;
                            if (!this.paused && this.speed === 0) this.speed = 1;
                            break;
                        case '1': case '2': case '3': case '4': case '5':
                            const speeds = [0, 1, 5, 20, 100];
                            const speedIdx = parseInt(e.key) - 1;
                            this.speed = speeds[speedIdx];
                            this.paused = speedIdx === 0;
                            document.querySelectorAll('.speed-btn').forEach((b, i) => {
                                b.classList.toggle('active', i === speedIdx);
                            });
                            break;
                        case 'o': // Orbit camera
                            document.getElementById('orbitBtn').click();
                            break;
                        case 'f': // Follow camera
                            document.getElementById('followBtn').click();
                            break;
                        case 'i': // Interior camera
                            document.getElementById('interiorBtn').click();
                            break;
                        case 'm': // Mute toggle
                            document.getElementById('audioBtn').click();
                            break;
                    }
                });
            }

            updateFocusPanel(entityId) {
                const panel = document.getElementById('colonistFocus');
                panel.classList.remove('hidden');

                const name = this.ecs.names[entityId];
                const gen = this.ecs.generation[entityId];
                const age = this.ecs.age[entityId];
                const lit = (this.ecs.literacy[entityId] * 100).toFixed(1);
                const tech = (this.ecs.techUnderstanding[entityId] * 100).toFixed(1);

                document.getElementById('colonistPortrait').textContent = name[0];
                document.getElementById('colonistName').textContent = name;
                document.getElementById('colonistGen').textContent = `Generation ${gen} ‚Ä¢ Age ${age}`;
                document.getElementById('colonistLit').textContent = lit + '%';
                document.getElementById('colonistTech').textContent = tech + '%';

                // Neural bars
                const traits = ['tradition', 'innovation', 'spirituality', 'rationality', 'community', 'individuality', 'awareness', 'augmentation'];
                const colors = ['#d4a574', '#4ecdc4', '#a18cd1', '#4ecdc4', '#ffd93d', '#ff6b6b', '#ffffff', '#4ecdc4'];
                let barsHTML = '';
                for (let i = 0; i < traits.length; i++) {
                    const val = this.ecs[traits[i]][entityId] * 100;
                    barsHTML += `<div style="font-size:10px;color:#6a6a8a;">${traits[i]}</div>
                        <div class="neural-bar"><div class="neural-fill" style="width:${val}%;background:${colors[i]};"></div></div>`;
                }
                document.getElementById('neuralBars').innerHTML = barsHTML;

                // Lineage
                const p1 = this.ecs.parent1[entityId];
                const p2 = this.ecs.parent2[entityId];
                const partner = this.ecs.partnerId[entityId];
                const familyId = this.ecs.familyId[entityId];
                
                let lineageHTML = '';
                if (p1 >= 0 && p2 >= 0) {
                    lineageHTML += `Child of ${this.ecs.names[p1]} & ${this.ecs.names[p2]}<br>`;
                } else {
                    lineageHTML += 'First Generation Colonist<br>';
                }
                
                if (partner >= 0) {
                    lineageHTML += `Partner: ${this.ecs.names[partner]}<br>`;
                }
                
                if (familyId !== -1) {
                    lineageHTML += `Family ID: #${familyId}`;
                }
                
                document.getElementById('colonistLineage').innerHTML = lineageHTML;

                // Journals in focus panel
                const journals = this.ecs.journals[entityId];
                if (journals && journals.length > 0) {
                    let journalHTML = '<div class="colonist-beliefs-title" style="margin-top:10px;">PERSONAL LOGS</div>';
                    for (const entry of journals) {
                        journalHTML += `<div style="font-size:11px;color:#a0a8b0;margin-bottom:4px;border-left:1px solid #4ecdc4;padding-left:5px;">
                            <span style="color:#4ecdc4;">Year ${entry.year}:</span> ${entry.text}
                        </div>`;
                    }
                    document.getElementById('neuralBars').innerHTML += journalHTML;
                }

                // Faction
                const factionIdx = this.ecs.faction[entityId];
                const factionTypes = ['technocrats', 'spiritualists', 'traditionalists', 'nihilists', 'transcendentists'];
                if (factionIdx >= 0) {
                    const faction = this.factions.find(f => f.type === factionTypes[factionIdx]);
                    if (faction) {
                        document.getElementById('colonistFocus').style.borderColor = faction.color;
                    }
                }
            }

            update() {
                if (this.paused || this.arrived) return;

                if (this.cinematicMode) {
                    // Slow down simulation in cinematic mode
                    this.cinematicTimer += CONFIG.CINEMATIC_SPEED;
                    if (this.cinematicTimer >= 1) {
                        this.simulateYear();
                        this.cinematicTimer = 0;
                    }
                } else {
                    for (let i = 0; i < this.speed; i++) {
                        this.simulateYear();
                    }
                }

                this.applyMetaGlitches();
                this.updateUI();
            }

            applyMetaGlitches() {
                const aliveIds = this.ecs.getAliveIds();
                let maxAwareness = 0;
                for (const id of aliveIds) {
                    if (this.ecs.awareness[id] > maxAwareness) maxAwareness = this.ecs.awareness[id];
                }

                if (maxAwareness > CONFIG.AWARENESS_THRESHOLD) {
                    const intensity = (maxAwareness - CONFIG.AWARENESS_THRESHOLD) / (1 - CONFIG.AWARENESS_THRESHOLD);
                    if (Math.random() < intensity * 0.1) {
                        // Apply CSS glitches
                        const body = document.body;
                        const glitchType = Math.floor(Math.random() * 3);
                        switch(glitchType) {
                            case 0:
                                body.style.filter = `hue-rotate(${Math.random() * 360}deg) contrast(${1 + intensity})`;
                                setTimeout(() => body.style.filter = '', 100);
                                break;
                            case 1:
                                body.style.transform = `skew(${Math.random() * 5 * intensity}deg)`;
                                setTimeout(() => body.style.transform = '', 50);
                                break;
                            case 2:
                                const headers = document.querySelectorAll('h1, .panel-title');
                                headers.forEach(h => {
                                    const original = h.textContent;
                                    h.textContent = Math.random() > 0.5 ? "SYSTEM ERROR" : "OBSERVER DETECTED";
                                    setTimeout(() => h.textContent = original, 200);
                                });
                                break;
                        }
                    }
                }
            }

            simulateYear() {
                this.year++;

                if (this.year >= CONFIG.VOYAGE_YEARS) {
                    this.arrived = true;
                    this.addEvent(this.year, 'THE GENESIS ARK ARRIVES AT KEPLER-442b. After 400 years, the voyage is complete.');
                    return;
                }

                this.generation = Math.floor(this.year / CONFIG.GENERATION_LENGTH) + 1;
                LANGUAGE.evolveAll(this.year);

                // Update Social & Narrative Systems
                this.socialSystem.update(this.year);
                this.journalSystem.update(this.year);

                const aliveIds = this.ecs.getAliveIds();
                const aliveCount = aliveIds.length;

                // Update colonists
                for (const id of aliveIds) {
                    this.ecs.age[id] = this.year - this.ecs.birthYear[id];

                    // Update Needs
                    this.ecs.hunger[id] += 0.05 + Math.random() * 0.05;
                    this.ecs.fatigue[id] += 0.03 + Math.random() * 0.03;

                    // Assign Targets based on Needs
                    if (this.ecs.hunger[id] > 0.7 && !this.ecs.hasTarget[id]) {
                        const angle = Math.floor(Math.random() * 4) * (Math.PI / 2); // Go to Hydroponics
                        this.ecs.targetX[id] = Math.cos(angle);
                        this.ecs.targetZ[id] = Math.sin(angle);
                        this.ecs.hasTarget[id] = 1;
                    }

                    // Death
                    if (this.ecs.age[id] > 60) {
                        if (Math.random() < (this.ecs.age[id] - 60) * 0.02) {
                            this.ecs.destroyEntity(id);
                            continue;
                        }
                    }
                    if (Math.random() < 0.001) {
                        this.ecs.destroyEntity(id);
                        continue;
                    }

                    // Faction joining
                    if (this.ecs.faction[id] < 0 && this.ecs.age[id] >= 15 && this.factions.length > 0) {
                        const affinity = this.ecs.getFactionAffinity(id);
                        if (Math.random() < affinity.strength) {
                            this.ecs.faction[id] = affinity.factionIndex;
                            const faction = this.factions[affinity.factionIndex];
                            if (faction) faction.memberIds.add(id);
                        }
                    }

                    // Cybernetic Integration (Transcendentists)
                    if (this.ecs.faction[id] === 4) { // Transcendentists
                        this.ecs.augmentation[id] += 0.01;
                        this.ecs.techUnderstanding[id] += 0.005;
                        if (this.ecs.augmentation[id] > 0.8) {
                            this.ecs.awareness[id] += 0.005;
                        }
                    }

                    // Stat decay
                    this.ecs.literacy[id] *= 0.999;
                    this.ecs.techUnderstanding[id] *= 0.998;
                    this.ecs.awareness[id] *= 0.999; // Awareness fades without reinforcement

                    // Movement
                    if (this.ecs.hasTarget[id]) {
                        const dx = this.ecs.targetX[id] - this.ecs.posX[id];
                        const dz = this.ecs.targetZ[id] - this.ecs.posZ[id];
                        this.ecs.velX[id] += dx * 0.01;
                        this.ecs.velZ[id] += dz * 0.01;
                        
                        if (Math.sqrt(dx*dx + dz*dz) < 0.1) {
                            this.ecs.hunger[id] *= 0.2; // "Ate"
                            this.ecs.hasTarget[id] = 0;
                        }
                    } else {
                        this.ecs.velX[id] += (Math.random() - 0.5) * 0.01;
                        this.ecs.velY[id] += (Math.random() - 0.5) * 0.01;
                        this.ecs.velZ[id] += (Math.random() - 0.5) * 0.01;
                    }

                    this.ecs.velX[id] *= 0.95;
                    this.ecs.velY[id] *= 0.95;
                    this.ecs.velZ[id] *= 0.95;

                    this.ecs.posX[id] += this.ecs.velX[id];
                    this.ecs.posY[id] += this.ecs.velY[id];
                    this.ecs.posZ[id] += this.ecs.velZ[id];

                    // Keep on ring
                    const len = Math.sqrt(this.ecs.posX[id] ** 2 + this.ecs.posZ[id] ** 2);
                    if (len > 0) {
                        this.ecs.posX[id] = (this.ecs.posX[id] / len) * Math.min(1, Math.max(0.5, len));
                        this.ecs.posZ[id] = (this.ecs.posZ[id] / len) * Math.min(1, Math.max(0.5, len));
                    }
                    this.ecs.posY[id] = Math.max(-0.2, Math.min(0.2, this.ecs.posY[id]));

                    // Social connections
                    if (Math.random() < CONFIG.SOCIAL_CONNECTION_CHANCE) {
                        const others = aliveIds.filter(o => o !== id);
                        if (others.length > 0) {
                            const other = others[Math.floor(Math.random() * others.length)];
                            this.ecs.addConnection(id, other);
                        }
                    }
                }

                // Reproduction
                const reproducers = aliveIds.filter(id =>
                    this.ecs.alive[id] && this.ecs.age[id] >= 18 && this.ecs.age[id] <= 45
                );
                const targetBirths = Math.floor(aliveCount * CONFIG.BIRTH_RATE);

                for (let i = 0; i < targetBirths && this.ecs.getAliveCount() < CONFIG.MAX_POPULATION; i++) {
                    if (reproducers.length >= 2) {
                        const p1 = reproducers[Math.floor(Math.random() * reproducers.length)];
                        const p2 = reproducers[Math.floor(Math.random() * reproducers.length)];
                        if (p1 !== p2) {
                            const child = this.ecs.createEntity();
                            this.ecs.initializeColonist(child, this.generation, this.year, p1, p2);
                        }
                    }
                }

                // Update documents
                for (const doc of this.documents) {
                    doc.evolve(this.year, this.factions);
                }

                // Faction emergence
                if (this.year > 50 && Math.random() < 0.01 && this.factions.length < 5) {
                    this.emergeFaction();
                }

                // Update factions
                for (const faction of this.factions) {
                    // Clean dead members
                    for (const id of faction.memberIds) {
                        if (!this.ecs.alive[id]) faction.memberIds.delete(id);
                    }
                    faction.update(aliveCount);

                    if (Math.random() < 0.01) {
                        const myth = faction.createMyth(this.year);
                        this.myths.push(myth);
                    }
                }

                // Random events
                if (Math.random() < 0.02) this.generateEvent();

                // CRISIS SYSTEM
                const population = this.ecs.getAliveCount();

                // Check for new crisis
                const newCrisis = this.crisisManager.checkForCrisis(this.year, population, this.factions);
                if (newCrisis) {
                    this.addEvent(this.year, `‚ö†Ô∏è CRISIS: ${newCrisis.name} - ${newCrisis.description}`);
                    this.audioSystem.playCrisisAlarm(newCrisis.category);
                    this.audioSystem.playEventChime('crisis_start');
                }

                // Update active crises
                const crisisUpdates = this.crisisManager.updateCrises(this.year, this.ecs, this.factions);
                for (const update of crisisUpdates) {
                    if (update.type === 'resolved') {
                        this.addEvent(this.year, `‚úì CRISIS RESOLVED: ${update.crisis.name} - ${update.resolution}`);
                        this.myths.push(update.myth);
                        this.audioSystem.playEventChime('crisis_end');
                        this.audioSystem.playEventChime('myth');
                    }
                }

                // Update visual effects for crises
                this.renderer.setCrisisEffects(this.crisisManager.getActiveVisualEffects());

                // Update audio ambience
                const avgMythologization = this.documents.reduce((sum, d) => sum + d.mythologization, 0) / this.documents.length;
                this.audioSystem.updateAmbience(
                    this.year,
                    avgMythologization,
                    this.crisisManager.activeCrises.length > 0,
                    population,
                    this.cinematicMode
                );

                // Milestones
                if (this.year % 50 === 0) {
                    this.addEvent(this.year, `Year ${this.year}: Population ${this.ecs.getAliveCount()}. Generation ${this.generation} leads the ship.`);
                    this.audioSystem.playEventChime('milestone');
                }

                // Cycle 3: Century milestone celebrations
                this.checkMilestone();

                // History
                if (this.year % 5 === 0) {
                    this.populationHistory.push({ year: this.year, population: this.ecs.getAliveCount() });
                }
            }

            emergeFaction() {
                const types = ['technocrats', 'spiritualists', 'traditionalists', 'nihilists', 'transcendentists'];
                const existing = this.factions.map(f => f.type);
                const available = types.filter(t => !existing.includes(t));

                if (available.length > 0) {
                    const type = available[Math.floor(Math.random() * available.length)];
                    const faction = new Faction(type, this.year);
                    this.factions.push(faction);
                    this.addEvent(this.year, `A new movement emerges: ${faction.name}. "${faction.beliefs}"`);
                    this.audioSystem.playEventChime('faction');
                }
            }

            generateEvent() {
                const events = [
                    () => `Scholars debate the meaning of the ${this.documents[Math.floor(Math.random() * this.documents.length)].title}.`,
                    () => this.factions.length >= 2 ? `Tensions rise between ${this.factions[0].name} and ${this.factions[1].name}.` : null,
                    () => 'A child shows remarkable insight into the old texts. Some whisper of prophecy.',
                    () => 'Strange lights seen through observation deck. Some say the stars speak.',
                    () => this.generation > 3 ? 'Elders speak of "Earth" but the young no longer understand.' : null
                ];

                const event = events[Math.floor(Math.random() * events.length)]();
                if (event) this.addEvent(this.year, event);
            }

            addEvent(year, text) {
                this.events.unshift({ year, text });
                if (this.events.length > 100) this.events.pop();
            }

            // Cycle 3: Milestone Celebration System
            checkMilestone() {
                const milestoneYears = [100, 200, 300, 400];
                if (milestoneYears.includes(this.year) && this.year !== this.lastMilestoneYear) {
                    this.showMilestone();
                    this.lastMilestoneYear = this.year;
                }
            }

            showMilestone() {
                const aliveCount = this.ecs.getAliveCount();
                const aliveIds = this.ecs.getAliveIds();

                // Calculate current stats
                let totalLit = 0, totalTech = 0;
                for (const id of aliveIds) {
                    totalLit += this.ecs.literacy[id];
                    totalTech += this.ecs.techUnderstanding[id];
                }
                const avgLit = aliveCount > 0 ? (totalLit / aliveCount * 100) : 0;
                const avgTech = aliveCount > 0 ? (totalTech / aliveCount * 100) : 0;

                // Store snapshot
                this.milestoneSnapshots[this.year] = {
                    population: aliveCount,
                    literacy: avgLit,
                    tech: avgTech,
                    factions: this.factions.length,
                    crises: this.crisisManager.crisisHistory.length,
                    myths: this.myths.length
                };

                // Get previous snapshot for comparison
                const prevYear = this.year - 100;
                const prev = this.milestoneSnapshots[prevYear] || { population: CONFIG.INITIAL_POPULATION, literacy: 100, tech: 100, factions: 0, crises: 0, myths: 0 };
                const current = this.milestoneSnapshots[this.year];

                // Build stats HTML
                const formatChange = (curr, old, suffix = '') => {
                    const diff = curr - old;
                    if (Math.abs(diff) < 0.1) return `<span class="milestone-stat-change stable">‚Äî</span>`;
                    const sign = diff > 0 ? '+' : '';
                    const cls = diff > 0 ? 'positive' : 'negative';
                    return `<span class="milestone-stat-change ${cls}">${sign}${diff.toFixed(1)}${suffix}</span>`;
                };

                document.getElementById('milestoneYear').textContent = `YEAR ${this.year}`;
                document.getElementById('milestoneTitle').textContent = this.year === 400 ? 'ARRIVAL AT KEPLER-442b' : 'CENTURY REPORT';

                document.getElementById('milestoneStats').innerHTML = `
                    <div class="milestone-stat">
                        <div class="milestone-stat-label">Population</div>
                        <div class="milestone-stat-value">${current.population.toLocaleString()}</div>
                        ${formatChange(current.population, prev.population)}
                    </div>
                    <div class="milestone-stat">
                        <div class="milestone-stat-label">Literacy</div>
                        <div class="milestone-stat-value">${current.literacy.toFixed(1)}%</div>
                        ${formatChange(current.literacy, prev.literacy, '%')}
                    </div>
                    <div class="milestone-stat">
                        <div class="milestone-stat-label">Tech Understanding</div>
                        <div class="milestone-stat-value">${current.tech.toFixed(1)}%</div>
                        ${formatChange(current.tech, prev.tech, '%')}
                    </div>
                    <div class="milestone-stat">
                        <div class="milestone-stat-label">Crises Survived</div>
                        <div class="milestone-stat-value">${current.crises}</div>
                        ${formatChange(current.crises, prev.crises)}
                    </div>
                `;

                // Factions summary
                let factionSummary = '';
                if (this.factions.length > 0) {
                    factionSummary = '<div style="font-size:12px;color:#a0a8b0;margin-bottom:8px;">Active Factions:</div>';
                    for (const faction of this.factions) {
                        factionSummary += `<span style="color:${faction.color};margin-right:12px;">${faction.name} (${faction.memberIds.size})</span>`;
                    }
                }
                document.getElementById('milestoneFactions').innerHTML = factionSummary;

                // Show overlay and pause
                this.milestoneOverlay.classList.remove('hidden');
                this.paused = true;
                this.audioSystem.playEventChime('milestone');

                // Add dismiss listener
                const dismiss = () => {
                    this.milestoneOverlay.classList.add('hidden');
                    this.paused = false;
                    this.milestoneOverlay.removeEventListener('click', dismiss);
                };
                this.milestoneOverlay.addEventListener('click', dismiss);
            }

            updateUI() {
                const aliveCount = this.ecs.getAliveCount();
                const aliveIds = this.ecs.getAliveIds();

                document.getElementById('yearDisplay').textContent = this.year;
                document.getElementById('genDisplay').textContent = this.generation;
                document.getElementById('destDisplay').textContent = Math.max(0, CONFIG.VOYAGE_YEARS - this.year);
                document.getElementById('progressFill').style.width = `${(this.year / CONFIG.VOYAGE_YEARS) * 100}%`;

                // Update HUD
                const hudYear = document.getElementById('hudYear');
                if (hudYear) hudYear.textContent = this.year;
                const hudPop = document.getElementById('hudPop');
                if (hudPop) hudPop.textContent = aliveCount;
                const hudStatus = document.getElementById('hudStatus');
                if (hudStatus) {
                    if (this.crisisManager.activeCrises.length > 0) {
                        hudStatus.textContent = 'CRITICAL: ' + this.crisisManager.activeCrises[0].name.toUpperCase();
                        hudStatus.style.color = '#ff6b6b';
                    } else {
                        hudStatus.textContent = 'NOMINAL';
                        hudStatus.style.color = '#4ecdc4';
                    }
                }

                // Calculate stats
                let totalAge = 0, totalLit = 0, totalTech = 0, totalConn = 0;
                for (const id of aliveIds) {
                    totalAge += this.ecs.age[id];
                    totalLit += this.ecs.literacy[id];
                    totalTech += this.ecs.techUnderstanding[id];
                    totalConn += this.ecs.connections.get(id)?.size || 0;
                }

                const avgLit = aliveCount > 0 ? (totalLit / aliveCount * 100) : 0;
                const avgTech = aliveCount > 0 ? (totalTech / aliveCount * 100) : 0;
                const connections = Math.floor(totalConn / 2);

                // Cycle 3: Contextual stat colors and trends
                const getTrendIcon = (curr, prev) => {
                    if (curr > prev + 0.5) return '<span class="stat-trend up">‚ñ≤</span>';
                    if (curr < prev - 0.5) return '<span class="stat-trend down">‚ñº</span>';
                    return '<span class="stat-trend stable">‚óè</span>';
                };

                const getHealthClass = (value, thresholds) => {
                    if (value <= thresholds.critical) return 'critical';
                    if (value <= thresholds.warning) return 'warning';
                    return 'healthy';
                };

                // Population stat with trend
                const popEl = document.getElementById('popStat');
                popEl.innerHTML = `${aliveCount}${getTrendIcon(aliveCount, this.prevStats.population)}`;
                popEl.className = 'stat-value ' + getHealthClass(aliveCount, { critical: 200, warning: 500 });

                // Age stat
                document.getElementById('ageStat').textContent = aliveCount > 0 ? Math.round(totalAge / aliveCount) : 0;

                // Literacy stat with trend and coloring
                const litEl = document.getElementById('litStat');
                litEl.innerHTML = `${avgLit.toFixed(1)}%${getTrendIcon(avgLit, this.prevStats.literacy)}`;
                litEl.className = 'stat-value ' + getHealthClass(avgLit, { critical: 30, warning: 60 });

                // Tech stat with trend and coloring
                const techEl = document.getElementById('techStat');
                techEl.innerHTML = `${avgTech.toFixed(1)}%${getTrendIcon(avgTech, this.prevStats.tech)}`;
                techEl.className = 'stat-value ' + getHealthClass(avgTech, { critical: 20, warning: 50 });

                // Social connections stat
                const socialEl = document.getElementById('socialStat');
                socialEl.innerHTML = `${connections}${getTrendIcon(connections, this.prevStats.connections)}`;

                // Update previous stats for next comparison
                if (this.year % 10 === 0) {
                    this.prevStats = { population: aliveCount, literacy: avgLit, tech: avgTech, connections };
                }

                // Language
                const langPanel = document.getElementById('languagePanel');
                let langHTML = '';
                for (const [word, data] of Object.entries(LANGUAGE.baseWords)) {
                    if (data.current !== word) {
                        langHTML += `<div class="word-evolution"><span class="word-original">${word}</span><span class="word-arrow">‚Üí</span><span class="word-current">${data.current}</span></div>`;
                    }
                }
                langPanel.innerHTML = langHTML || '<div style="color:#6a6a8a;font-size:12px;">Language unchanged...</div>';

                // Factions
                let factionHTML = '';
                for (const faction of this.factions) {
                    factionHTML += `<div class="faction-item" style="border-color:${faction.color}"><div class="faction-name" style="color:${faction.color}">${faction.name}</div><div class="faction-belief">${faction.beliefs}</div><div class="faction-members">${faction.memberIds.size} members ‚Ä¢ Year ${faction.foundedYear}</div></div>`;
                }
                document.getElementById('factionList').innerHTML = factionHTML || '<div style="color:#6a6a8a;font-size:12px;">No factions yet...</div>';

                // Journals Tab
                const journalList = document.getElementById('journalList');
                if (journalList) {
                    let allJournals = [];
                    for (const id of aliveIds) {
                        for (const entry of this.ecs.journals[id]) {
                            allJournals.push({ name: this.ecs.names[id], ...entry });
                        }
                    }
                    allJournals.sort((a, b) => b.year - a.year);
                    
                    let journalHTML = '';
                    for (const entry of allJournals.slice(0, 20)) {
                        journalHTML += `<div class="text-evolution">
                            <div class="myth-origin">Year ${entry.year} ‚Ä¢ ${entry.name}</div>
                            <div class="text-current">${entry.text}</div>
                        </div>`;
                    }
                    journalList.innerHTML = journalHTML || '<div style="color:#6a6a8a;font-size:12px;">No journal entries yet...</div>';
                }

                // Sacred texts
                let textsHTML = '';
                for (const doc of this.documents.slice(0, 3)) {
                    textsHTML += `<div class="text-evolution"><div class="text-original">${doc.original.substring(0, 60)}...</div><div class="text-current">${doc.getCurrentVersion().substring(0, 80)}...</div><div class="text-drift">Mythologization: ${Math.round(doc.mythologization * 100)}%</div></div>`;
                }
                document.getElementById('textEvolutions').innerHTML = textsHTML;

                // Myths
                let mythsHTML = '';
                for (const myth of this.myths.slice(-5).reverse()) {
                    mythsHTML += `<div class="myth-card"><div class="myth-title">${myth.title}</div><div class="myth-description">${myth.desc}</div><div class="myth-origin">Year ${myth.originYear} ‚Ä¢ ${myth.faction}</div></div>`;
                }
                document.getElementById('mythList').innerHTML = mythsHTML || '<div style="color:#6a6a8a;font-size:12px;">No myths yet...</div>';

                // Events
                let eventsHTML = '';
                for (const event of this.events.slice(0, 15)) {
                    eventsHTML += `<div class="event-item"><span class="event-year">Year ${event.year}</span><div class="event-text">${event.text}</div></div>`;
                }
                document.getElementById('eventLog').innerHTML = eventsHTML;

                document.getElementById('dialectSample').textContent = `"${LANGUAGE.translateText('The Ship carries us to our destination', this.year)}"`;

                // Crisis stats
                const crisisStats = this.crisisManager.getStats();
                document.getElementById('crisisStat').textContent = crisisStats.totalCrises;
                document.getElementById('crisisDeathStat').textContent = crisisStats.totalDeaths;

                // Active crisis alert
                const crisisAlert = document.getElementById('crisisAlert');
                const crisisContent = document.getElementById('crisisAlertContent');
                if (this.crisisManager.activeCrises.length > 0) {
                    crisisAlert.classList.remove('hidden');
                    let alertHTML = '';
                    for (const crisis of this.crisisManager.activeCrises) {
                        const progress = ((this.year - crisis.startYear) / crisis.duration) * 100;
                        alertHTML += `
                            <div class="crisis-item">
                                <div class="crisis-item-name">${crisis.name}</div>
                                <div style="color:#a0a8b0;font-size:11px;">${crisis.description}</div>
                                <div class="crisis-item-progress">
                                    <div class="crisis-item-progress-fill" style="width:${progress}%"></div>
                                </div>
                                <div class="crisis-casualties">‚ò†Ô∏è ${crisis.casualties} casualties ‚Ä¢ ${crisis.endYear - this.year} ${crisis.endYear - this.year === 1 ? 'year' : 'years'} remaining</div>
                            </div>
                        `;
                    }
                    crisisContent.innerHTML = alertHTML;
                } else {
                    crisisAlert.classList.add('hidden');
                }

                // Status text with crisis info
                let statusText = this.arrived ? 'DESTINATION REACHED' : `3D simulation ‚Ä¢ ${this.speed}x speed`;
                if (this.crisisManager.activeCrises.length > 0) {
                    statusText += ` ‚Ä¢ ‚ö†Ô∏è ${this.crisisManager.activeCrises.length} ACTIVE CRISIS`;
                }
                document.getElementById('statusText').textContent = statusText;

                // Update focused colonist if exists
                if (this.renderer.focusedColonist >= 0 && this.ecs.alive[this.renderer.focusedColonist]) {
                    this.updateFocusPanel(this.renderer.focusedColonist);
                } else if (this.renderer.focusedColonist >= 0) {
                    // Focused colonist died
                    this.renderer.focusedColonist = -1;
                    document.getElementById('colonistFocus').classList.add('hidden');
                    this.addEvent(this.year, 'The colonist you were following has passed away.');
                }

                this.renderPopGraph();
            }

            renderPopGraph() {
                const ctx = this.popCtx;
                const w = this.popCanvas.width;
                const h = this.popCanvas.height;

                ctx.fillStyle = '#0a0a15';
                ctx.fillRect(0, 0, w, h);

                if (this.populationHistory.length < 2) return;

                const maxPop = Math.max(...this.populationHistory.map(p => p.population), CONFIG.INITIAL_POPULATION);

                ctx.strokeStyle = '#4ecdc4';
                ctx.lineWidth = 2;
                ctx.beginPath();

                for (let i = 0; i < this.populationHistory.length; i++) {
                    const x = (i / this.populationHistory.length) * w;
                    const y = h - (this.populationHistory[i].population / maxPop) * h * 0.9;
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.stroke();
            }

            animate() {
                // Cycle 5: Skip rendering when tab is hidden (battery saving)
                if (document.hidden) {
                    requestAnimationFrame(() => this.animate());
                    return;
                }

                this.update();
                this.renderer.updateColonists(this.ecs, this.factions);
                this.renderer.updateCamera(this.year);
                this.renderer.render();
                requestAnimationFrame(() => this.animate());
            }

            exportHistory() {
                const data = {
                    voyageYears: this.year,
                    finalGeneration: this.generation,
                    finalPopulation: this.ecs.getAliveCount(),
                    arrived: this.arrived,
                    factions: this.factions.map(f => ({ name: f.name, type: f.type, members: f.memberIds.size, myths: f.myths })),
                    languageEvolution: Object.entries(LANGUAGE.baseWords).map(([w, d]) => ({ original: w, current: d.current, meaning: d.meaning })),
                    documentEvolution: this.documents.map(d => ({ title: d.title, mythologization: d.mythologization })),
                    myths: this.myths,
                    events: this.events,
                    populationHistory: this.populationHistory
                };

                const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `genesis-ark-year-${this.year}.json`;
                a.click();
                URL.revokeObjectURL(url);
            }
        }

        // Initialize
        const simulation = new GenesisArkSimulation();
    </script>
</body>
</html>
