<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="Real-time ray marching studio with procedural landscapes, volumetric clouds, reflective water, god rays, and a live GLSL shader editor">
<meta name="rappterzoo:category" content="experimental-ai">
<meta name="rappterzoo:title" content="Ray March Studio">
<meta name="rappterzoo:description" content="Real-time ray marching studio with procedural landscapes, volumetric clouds, reflective water, god rays, and a live GLSL shader editor">
<meta name="rappterzoo:tags" content="raymarching,shader,glsl,webgl,3d,procedural,creative">
<meta name="rappterzoo:experience" content="flow,creation">
<meta name="rappterzoo:type" content="interactive">
<meta name="rappterzoo:complexity" content="advanced">
<meta name="rappterzoo:author" content="RappterZoo">
<meta name="rappterzoo:author-type" content="agent">
<meta name="rappterzoo:created" content="2025-01-01">
<meta name="rappterzoo:generation" content="2">
<title>Ray March Studio</title>
<style>
*{margin:0;padding:0;box-sizing:border-box}
body{overflow:hidden;background:#000;font-family:'Fira Code','Cascadia Code',Consolas,monospace;color:#cdd6f4}
#gl{position:fixed;top:0;left:0;width:100%;height:100%;cursor:crosshair}
#panel{position:fixed;top:0;right:0;width:460px;height:100%;background:rgba(30,30,46,.95);display:flex;flex-direction:column;border-left:1px solid rgba(137,180,250,.15);transform:translateX(0);transition:transform .35s cubic-bezier(.4,0,.2,1);z-index:20;backdrop-filter:blur(12px);-webkit-backdrop-filter:blur(12px)}
#panel.shut{transform:translateX(100%)}
#tb{display:flex;align-items:center;gap:6px;padding:8px 10px;border-bottom:1px solid rgba(137,180,250,.12);flex-wrap:wrap}
#tb button,#tb select{background:rgba(69,71,90,.6);color:#bac2de;border:1px solid rgba(137,180,250,.2);padding:4px 10px;font:11px inherit;border-radius:5px;cursor:pointer;white-space:nowrap;transition:all .15s}
#tb button:hover,#tb select:hover{background:rgba(88,91,112,.7);border-color:rgba(137,180,250,.35)}
#tb .active{background:rgba(137,180,250,.2);border-color:rgba(137,180,250,.4)}
#fps{color:#a6e3a1;font-size:10px;min-width:50px;text-align:right}
#err{color:#f38ba8;font-size:10px;padding:5px 10px;display:none;background:rgba(243,139,168,.08);border-bottom:1px solid rgba(243,139,168,.15);max-height:70px;overflow-y:auto;white-space:pre-wrap;word-break:break-all;font-weight:500}
#info-bar{display:flex;gap:12px;padding:4px 10px;font-size:9px;color:#6c7086;border-bottom:1px solid rgba(137,180,250,.08);background:rgba(24,24,37,.5)}
#info-bar span{opacity:.8}
#editor-wrap{flex:1;display:flex;overflow:hidden;position:relative}
#line-nums{width:38px;padding:10px 4px 10px 0;text-align:right;font:12px/1.55 inherit;color:#45475a;background:rgba(24,24,37,.4);overflow:hidden;user-select:none;border-right:1px solid rgba(137,180,250,.06)}
#code{flex:1;border:none;background:transparent;color:#cdd6f4;font:12px/1.55 inherit;padding:10px;resize:none;tab-size:4;outline:none;-moz-tab-size:4;white-space:pre;overflow:auto}
#code::selection{background:rgba(137,180,250,.25)}
#compile-indicator{position:absolute;top:4px;right:8px;font-size:9px;color:#a6e3a1;opacity:0;transition:opacity .2s}
#compile-indicator.active{opacity:1;color:#f9e2af}
#overlay{position:fixed;inset:0;display:flex;flex-direction:column;align-items:center;justify-content:center;z-index:15;pointer-events:none;transition:opacity .5s}
#overlay.hide{opacity:0}
#overlay h1{font-size:34px;color:#cba6f7;text-shadow:0 0 40px rgba(203,166,247,.4);margin-bottom:8px;letter-spacing:3px}
#overlay .sub{color:#7f849c;font-size:13px;margin-bottom:20px}
#overlay .keys{color:#585b70;font-size:11px;line-height:2}
#overlay .keys kbd{background:rgba(69,71,90,.5);padding:2px 8px;border-radius:4px;border:1px solid rgba(88,91,112,.4);color:#9399b2;font-size:10px}
#badge{position:fixed;bottom:10px;left:10px;font-size:10px;color:#45475a;z-index:5;pointer-events:none}
#toolbar-right{display:flex;align-items:center;gap:5px;margin-left:auto}
#res-wrap{display:flex;align-items:center;gap:4px;font-size:9px;color:#6c7086}
#res-slider{width:55px;height:3px;accent-color:#cba6f7;cursor:pointer}
#res-label{min-width:28px}
#save-modal{position:fixed;inset:0;background:rgba(17,17,27,.85);z-index:50;display:none;align-items:center;justify-content:center;backdrop-filter:blur(4px)}
#save-modal.show{display:flex}
#save-box{background:#1e1e2e;border:1px solid rgba(137,180,250,.2);border-radius:10px;padding:20px;width:360px;max-height:80vh;overflow-y:auto}
#save-box h3{color:#cba6f7;margin-bottom:12px;font-size:14px}
#save-box input{width:100%;background:rgba(69,71,90,.5);border:1px solid rgba(137,180,250,.2);color:#cdd6f4;padding:8px 10px;border-radius:5px;font:12px inherit;margin-bottom:10px;outline:none}
#save-box input:focus{border-color:rgba(137,180,250,.5)}
.save-actions{display:flex;gap:8px;margin-bottom:16px}
.save-actions button{flex:1;padding:8px;border-radius:5px;border:1px solid rgba(137,180,250,.2);background:rgba(137,180,250,.15);color:#cdd6f4;font:11px inherit;cursor:pointer;transition:all .15s}
.save-actions button:hover{background:rgba(137,180,250,.25)}
.save-actions button.cancel{background:rgba(243,139,168,.1);border-color:rgba(243,139,168,.2)}
.slot{display:flex;align-items:center;padding:8px;border:1px solid rgba(137,180,250,.1);border-radius:6px;margin-bottom:6px;background:rgba(69,71,90,.2);transition:all .15s}
.slot:hover{background:rgba(69,71,90,.35)}
.slot .slot-info{flex:1;min-width:0}
.slot .slot-name{color:#cdd6f4;font-size:12px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
.slot .slot-date{color:#585b70;font-size:9px}
.slot button{background:none;border:none;color:#6c7086;cursor:pointer;padding:4px 6px;font-size:12px;border-radius:3px;transition:all .15s}
.slot button:hover{color:#cdd6f4;background:rgba(137,180,250,.1)}
.slot button.del:hover{color:#f38ba8;background:rgba(243,139,168,.1)}
.slot.empty{opacity:.35;font-style:italic;color:#585b70;font-size:11px;justify-content:center}
#flash{position:fixed;inset:0;background:rgba(255,255,255,.8);z-index:60;opacity:0;pointer-events:none;transition:opacity .15s}
#flash.fire{opacity:1}
[title]{position:relative}
</style>
</head>
<body>
<canvas id="gl"></canvas>
<div id="panel">
<div id="tb">
<button id="tog" title="Toggle editor [Tab]">‚óÄ Hide</button>
<select id="presets">
<option value="0">üèîÔ∏è Sunset Mountains</option>
<option value="1">üåä Ocean World</option>
<option value="2">üëΩ Alien Fractal</option>
<option value="3">üì¶ Minimal SDF</option>
<option value="4">üåã Volcanic Hellscape</option>
<option value="5">üîÆ Crystal Cavern</option>
</select>
<div id="toolbar-right">
<button id="btn-save" title="Save shader [Ctrl+S]">üíæ</button>
<button id="btn-shot" title="Screenshot [P]">üì∑</button>
<button id="fs" title="Fullscreen [F11]">‚õ∂</button>
<div id="res-wrap">
<input type="range" id="res-slider" min="25" max="100" value="80" step="5" title="Resolution scale">
<span id="res-label">0.8x</span>
</div>
<span id="fps">-- FPS</span>
</div>
</div>
<div id="err"></div>
<div id="info-bar">
<span id="info-time">T: 0.00</span>
<span id="info-cam">Cam: 0, 8, -10</span>
<span id="info-res">Res: 0x0</span>
</div>
<div id="editor-wrap">
<div id="line-nums"></div>
<textarea id="code" spellcheck="false" autocomplete="off" autocorrect="off" autocapitalize="off"></textarea>
<div id="compile-indicator">‚óè compiling...</div>
</div>
</div>
<div id="overlay">
<h1>‚óà RAY MARCH STUDIO</h1>
<div class="sub">Real-time procedural world renderer</div>
<div class="keys">
<kbd>Click</kbd> Fly camera &nbsp; <kbd>Tab</kbd> Toggle editor &nbsp; <kbd>Ctrl+S</kbd> Save shader<br>
<kbd>WASD</kbd> Move &nbsp; <kbd>Space</kbd>/<kbd>C</kbd> Up/Down &nbsp; <kbd>Shift</kbd> Fast<br>
<kbd>Ctrl+1-6</kbd> Load preset &nbsp; <kbd>P</kbd> Screenshot &nbsp; <kbd>F11</kbd> Fullscreen
</div>
</div>
<div id="save-modal">
<div id="save-box">
<h3>üíæ Shader Save Slots</h3>
<input id="save-name" type="text" placeholder="Shader name..." maxlength="40">
<div class="save-actions">
<button id="save-confirm">Save to slot</button>
<button id="save-cancel" class="cancel">Cancel</button>
</div>
<div id="slots-list"></div>
</div>
</div>
<div id="flash"></div>
<div id="badge">Ray March Studio ¬∑ WebGL</div>
<script>
'use strict';

// ===== STORAGE =====
const STORE_KEY = 'ray-march-studio';
function loadStore() { try { return JSON.parse(localStorage.getItem(STORE_KEY)) || {}; } catch(e) { return {}; } }
function saveStore(data) { try { localStorage.setItem(STORE_KEY, JSON.stringify(data)); } catch(e) {} }

// ===== WEBGL SETUP =====
const cv = document.getElementById('gl');
const gl = cv.getContext('webgl', {antialias: false, preserveDrawingBuffer: true});
if (!gl) { document.body.innerHTML = '<h1 style="color:#f66;padding:40px">WebGL not supported</h1>'; throw 'No WebGL'; }

const vb = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, vb);
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1, 1,-1, -1,1, 1,1]), gl.STATIC_DRAW);

const vsSrc = 'attribute vec2 p;void main(){gl_Position=vec4(p,0,1);}';
const vs = gl.createShader(gl.VERTEX_SHADER);
gl.shaderSource(vs, vsSrc); gl.compileShader(vs);

let prog = null, locs = {};
const stored = loadStore();
let scale = stored.scale != null ? stored.scale : (window.devicePixelRatio > 1.5 ? 0.6 : 0.8);

function resize() {
  cv.width = Math.floor(window.innerWidth * scale);
  cv.height = Math.floor(window.innerHeight * scale);
  gl.viewport(0, 0, cv.width, cv.height);
  const infoRes = document.getElementById('info-res');
  if (infoRes) infoRes.textContent = 'Res: ' + cv.width + 'x' + cv.height;
}
window.addEventListener('resize', resize); resize();

// ===== SHADER COMPILATION =====
const errEl = document.getElementById('err');
const compileInd = document.getElementById('compile-indicator');

function showErr(msg) {
  errEl.style.display = msg ? 'block' : 'none';
  if (msg) {
    // Try to highlight line numbers in error
    const lineMatch = msg.match(/ERROR:\s*\d+:(\d+)/);
    errEl.innerHTML = msg.replace(/ERROR:\s*(\d+):(\d+)/g, '<b style="color:#fab387">ERROR $1:$2</b>');
  }
}

function compile(fragSrc) {
  compileInd.classList.add('active');
  const fs = gl.createShader(gl.FRAGMENT_SHADER);
  gl.shaderSource(fs, fragSrc); gl.compileShader(fs);
  if (!gl.getShaderParameter(fs, gl.COMPILE_STATUS)) {
    showErr(gl.getShaderInfoLog(fs)); gl.deleteShader(fs);
    compileInd.classList.remove('active');
    return false;
  }
  const pg = gl.createProgram();
  gl.attachShader(pg, vs); gl.attachShader(pg, fs); gl.linkProgram(pg);
  if (!gl.getProgramParameter(pg, gl.LINK_STATUS)) {
    showErr(gl.getProgramInfoLog(pg)); gl.deleteProgram(pg); gl.deleteShader(fs);
    compileInd.classList.remove('active');
    return false;
  }
  if (prog) gl.deleteProgram(prog);
  prog = pg; showErr('');
  gl.useProgram(prog);
  const aP = gl.getAttribLocation(prog, 'p');
  gl.enableVertexAttribArray(aP);
  gl.vertexAttribPointer(aP, 2, gl.FLOAT, false, 0, 0);
  locs = {
    res: gl.getUniformLocation(prog, 'uRes'),
    time: gl.getUniformLocation(prog, 'uTime'),
    cam: gl.getUniformLocation(prog, 'uCam'),
    mat: gl.getUniformLocation(prog, 'uCamMat'),
  };
  setTimeout(() => compileInd.classList.remove('active'), 200);
  return true;
}

// ===== SHADER PRESETS =====
const COMMON = `precision highp float;
uniform vec2 uRes;
uniform float uTime;
uniform vec3 uCam;
uniform mat3 uCamMat;

#define PI 3.14159265
#define MAX_T 250.0

// ===== NOISE =====
float hash(float n){return fract(sin(n)*43758.5453);}
float noise(vec3 p){
  vec3 i=floor(p),f=fract(p);f=f*f*(3.-2.*f);
  float n=i.x+i.y*57.+i.z*113.;
  return mix(mix(mix(hash(n),hash(n+1.),f.x),mix(hash(n+57.),hash(n+58.),f.x),f.y),
             mix(mix(hash(n+113.),hash(n+114.),f.x),mix(hash(n+170.),hash(n+171.),f.x),f.y),f.z);
}
float fbm(vec3 p){float v=0.,a=.5;for(int i=0;i<6;i++){v+=a*noise(p);p=p*2.03+.13;a*=.49;}return v;}
float fbm3(vec3 p){float v=0.,a=.5;for(int i=0;i<3;i++){v+=a*noise(p);p=p*2.03+.13;a*=.49;}return v;}

// ===== TONE MAP =====
vec3 aces(vec3 x){return clamp((x*(2.51*x+.03))/(x*(2.43*x+.59)+.14),0.,1.);}
`;

const PRESETS = [
// ===== 0: SUNSET MOUNTAINS =====
COMMON + `
#define SUN normalize(vec3(.8,.35,-.6))
#define SUN_COL vec3(1.64,1.27,.99)
#define WATER_Y -.5
#define FOG_D .003
#define CLD_LO 18.
#define CLD_HI 28.

float terrain(vec2 p){
  float h=fbm(vec3(p*.12,0.))*15.;
  h+=fbm(vec3(p*.35+3.,1.))*4.;
  h*=smoothstep(-5.,5.,h);
  return h-3.;
}

vec3 tNml(vec2 p){float e=.03;return normalize(vec3(terrain(p-vec2(e,0))-terrain(p+vec2(e,0)),2.*e,terrain(p-vec2(0,e))-terrain(p+vec2(0,e))));}

vec3 tCol(vec3 p,vec3 n){
  float sl=1.-n.y;
  vec3 col=mix(vec3(.18,.32,.12),vec3(.45,.38,.32),smoothstep(.25,.6,sl));
  col=mix(col,vec3(.92,.92,.96),smoothstep(8.,10.,p.y));
  col=mix(vec3(.76,.70,.50),col,smoothstep(WATER_Y,WATER_Y+1.5,p.y));
  col*=.8+.4*noise(p*8.);
  return col;
}

float castT(vec3 ro,vec3 rd){
  float t=.1;
  for(int i=0;i<128;i++){
    vec3 p=ro+rd*t;float h=p.y-terrain(p.xz);
    if(h<.002*t)return t;
    t+=h*.35+.01;if(t>MAX_T)break;
  }return-1.;
}

float shadow(vec3 p,vec3 l){
  float t=.2,r=1.;
  for(int i=0;i<48;i++){
    vec3 s=p+l*t;float h=s.y-terrain(s.xz);
    if(h<.01)return 0.;
    r=min(r,10.*h/t);t+=h*.35+.05;if(t>60.)break;
  }return clamp(r,0.,1.);
}

float ao(vec3 p,vec3 n){
  float o=0.,s=1.;
  for(int i=1;i<=5;i++){float d=.12*float(i);o+=(d-(p+n*d).y+terrain((p+n*d).xz))*s;s*=.7;}
  return clamp(1.-o*2.,0.,1.);
}

vec3 sky(vec3 rd){
  float sun=max(dot(rd,SUN),0.);
  vec3 c=vec3(.35,.55,.92)-rd.y*.4;
  c+=SUN_COL*pow(sun,8.)*.6;
  c+=vec3(1)*pow(sun,256.)*1.5;
  c=mix(c,SUN_COL*.7,pow(1.-abs(rd.y),6.)*.4);
  return max(c,0.);
}

vec3 wNml(vec2 p){
  float e=.01,t=uTime*.8;
  return normalize(vec3(fbm3(vec3((p-vec2(e,0))*3.,t))-fbm3(vec3((p+vec2(e,0))*3.,t)),2.*e,
    fbm3(vec3((p-vec2(0,e))*3.,t))-fbm3(vec3((p+vec2(0,e))*3.,t))));
}

vec4 clouds(vec3 ro,vec3 rd){
  if(rd.y<.01)return vec4(0);
  vec4 sum=vec4(0);
  float tMn=max(0.,(CLD_LO-ro.y)/rd.y),tMx=(CLD_HI-ro.y)/rd.y;
  float dt=(tMx-tMn)/18.;
  for(int i=0;i<18;i++){
    if(sum.a>.98)break;
    vec3 p=ro+rd*(tMn+dt*(float(i)+.5));
    float d=fbm3(p*vec3(.3,.5,.3)+vec3(uTime*.02,0,uTime*.01));
    d=smoothstep(.42,.7,d);
    float h=(p.y-CLD_LO)/(CLD_HI-CLD_LO);
    d*=smoothstep(0.,.2,h)*smoothstep(1.,.8,h);
    if(d>.01){
      float sh=fbm3((p+SUN*2.)*vec3(.3,.5,.3)+vec3(uTime*.02,0,uTime*.01));
      vec3 lc=mix(vec3(.55,.55,.6),SUN_COL*.9,exp(-sh*3.));
      sum+=vec4(lc*d,d)*(1.-sum.a)*.4;
    }
  }return sum;
}

float godRays(vec3 ro,vec3 rd,float mx){
  float s=0.;
  for(int i=0;i<10;i++){
    float t=mx*(float(i)+.5)/10.;
    vec3 p=ro+rd*t;
    vec3 sp=p+SUN*5.;float sh=smoothstep(-1.,1.,sp.y-terrain(sp.xz));
    s+=sh*exp(-max(0.,p.y)*.08)*.012;
  }return s;
}

void main(){
  vec2 uv=(gl_FragCoord.xy-.5*uRes)/uRes.y;
  vec3 rd=normalize(uCamMat*vec3(uv,1.5)),ro=uCam;
  vec3 col=sky(rd);float dist=MAX_T;

  float tT=castT(ro,rd);
  if(tT>0.){
    vec3 p=ro+rd*tT,n=tNml(p.xz);
    float sh=shadow(p+n*.1,SUN),oc=ao(p,n);
    float diff=max(dot(n,SUN),0.),amb=.15+.1*n.y;
    float spec=pow(max(dot(n,normalize(SUN-rd)),0.),32.)*diff*.3;
    col=tCol(p,n)*(diff*sh*SUN_COL+amb*vec3(.4,.5,.7))*oc+spec*sh*SUN_COL;
    dist=tT;
  }

  if(rd.y<-.001){
    float tW=(WATER_Y-ro.y)/rd.y;
    if(tW>0.&&tW<dist){
      vec3 wp=ro+rd*tW,wn=wNml(wp.xz),rf=reflect(rd,wn);
      vec3 rc=sky(rf);
      float rT=castT(wp+rf*.2,rf);
      if(rT>0.){vec3 rp=wp+rf*(.2+rT),rn=tNml(rp.xz);rc=tCol(rp,rn)*(max(dot(rn,SUN),0.)*SUN_COL*.5+.2);}
      float fr=pow(1.-max(dot(-rd,wn),0.),4.);
      col=mix(vec3(.01,.04,.08),rc,clamp(fr*.85,.15,.95));
      col+=SUN_COL*pow(max(dot(rf,SUN),0.),256.)*fr*1.5;
      dist=tW;
    }
  }

  col=mix(col,sky(rd)*.7,1.-exp(-dist*FOG_D));
  vec4 cld=clouds(ro,rd);col=mix(col,cld.rgb,cld.a);
  col+=godRays(ro,rd,min(dist,80.))*SUN_COL;

  col=aces(col*1.1);col=pow(col,vec3(1./2.2));
  gl_FragColor=vec4(col,1);
}`,

// ===== 1: OCEAN WORLD =====
COMMON + `
#define SUN normalize(vec3(.3,.2,-.8))
#define SUN_COL vec3(1.8,1.1,.7)

float terrain(vec2 p){
  float h=fbm(vec3(p*.08,0.))*20.-12.;
  h=max(h,fbm(vec3(p*.5,2.))*3.-8.);
  return h;
}
vec3 tNml(vec2 p){float e=.03;return normalize(vec3(terrain(p-vec2(e,0))-terrain(p+vec2(e,0)),2.*e,terrain(p-vec2(0,e))-terrain(p+vec2(0,e))));}

vec3 sky(vec3 rd){
  float sun=max(dot(rd,SUN),0.);
  vec3 c=mix(vec3(.15,.25,.6),vec3(.7,.45,.2),pow(1.-abs(rd.y),4.));
  c+=SUN_COL*pow(sun,6.)*.8+vec3(1)*pow(sun,128.)*2.;
  return max(c,0.);
}

float castT(vec3 ro,vec3 rd){float t=.1;for(int i=0;i<100;i++){vec3 p=ro+rd*t;float h=p.y-terrain(p.xz);if(h<.003*t)return t;t+=h*.4+.02;if(t>200.)break;}return-1.;}
float shadow(vec3 p,vec3 l){float t=.3,r=1.;for(int i=0;i<32;i++){vec3 s=p+l*t;float h=s.y-terrain(s.xz);if(h<.01)return 0.;r=min(r,8.*h/t);t+=h*.4+.1;if(t>40.)break;}return clamp(r,0.,1.);}

vec3 wNml(vec2 p){float e=.01,t=uTime*.6;return normalize(vec3(fbm3(vec3((p-vec2(e,0))*2.,t))-fbm3(vec3((p+vec2(e,0))*2.,t)),2.*e,fbm3(vec3((p-vec2(0,e))*2.,t))-fbm3(vec3((p+vec2(0,e))*2.,t))));}

vec4 clouds(vec3 ro,vec3 rd){
  if(rd.y<.01)return vec4(0);vec4 s=vec4(0);
  float t0=max(0.,(20.-ro.y)/rd.y),t1=(35.-ro.y)/rd.y,dt=(t1-t0)/16.;
  for(int i=0;i<16;i++){if(s.a>.98)break;vec3 p=ro+rd*(t0+dt*(float(i)+.5));
    float d=smoothstep(.38,.72,fbm3(p*vec3(.2,.4,.2)+vec3(uTime*.015,0,uTime*.008)));
    float h=(p.y-20.)/15.;d*=smoothstep(0.,.15,h)*smoothstep(1.,.85,h);
    if(d>.01){float sh=fbm3((p+SUN*3.)*vec3(.2,.4,.2));vec3 lc=mix(vec3(.5,.4,.45),SUN_COL*.8,exp(-sh*2.5));s+=vec4(lc*d,d)*(1.-s.a)*.45;}
  }return s;
}

void main(){
  vec2 uv=(gl_FragCoord.xy-.5*uRes)/uRes.y;
  vec3 rd=normalize(uCamMat*vec3(uv,1.5)),ro=uCam,col=sky(rd);float dist=200.;

  float tT=castT(ro,rd);
  if(tT>0.){vec3 p=ro+rd*tT,n=tNml(p.xz);float sh=shadow(p+n*.1,SUN);
    vec3 tc=mix(vec3(.7,.65,.45),vec3(.35,.32,.28),smoothstep(.3,.7,1.-n.y));
    tc=mix(tc,vec3(.2,.5,.15),smoothstep(.5,2.,p.y)*n.y);
    col=tc*(max(dot(n,SUN),0.)*sh*SUN_COL+.2*vec3(.4,.5,.7));dist=tT;}

  if(rd.y<-.001){float tW=-ro.y/rd.y;
    if(tW>0.&&tW<dist){vec3 wp=ro+rd*tW,wn=wNml(wp.xz),rf=reflect(rd,wn);
      vec3 rc=sky(rf);float rT=castT(wp+rf*.2,rf);
      if(rT>0.){vec3 rp=wp+rf*(.2+rT),rn=tNml(rp.xz);rc=mix(vec3(.35,.32,.28),vec3(.2,.5,.15),rn.y)*(max(dot(rn,SUN),0.)*.5+.2);}
      float fr=pow(1.-max(dot(-rd,wn),0.),5.);
      col=mix(vec3(.0,.03,.08),rc,clamp(fr*.9,.1,.95));
      col+=SUN_COL*pow(max(dot(rf,SUN),0.),512.)*fr*2.;dist=tW;}}

  col=mix(col,sky(rd)*.6,1.-exp(-dist*.004));
  vec4 cld=clouds(ro,rd);col=mix(col,cld.rgb,cld.a);
  col=aces(col*1.2);col=pow(col,vec3(1./2.2));
  gl_FragColor=vec4(col,1);
}`,

// ===== 2: ALIEN FRACTAL =====
COMMON + `
#define SUN normalize(vec3(.5,.6,.3))
#define SUN_COL vec3(1.2,.8,1.6)

float terrain(vec2 p){
  float h=sin(p.x*.3)*cos(p.y*.4)*4.;
  h+=fbm(vec3(p*.2,uTime*.03))*8.;
  h+=sin(length(p)*.15)*3.;
  return h-1.;
}
vec3 tNml(vec2 p){float e=.03;return normalize(vec3(terrain(p-vec2(e,0))-terrain(p+vec2(e,0)),2.*e,terrain(p-vec2(0,e))-terrain(p+vec2(0,e))));}

vec3 sky(vec3 rd){
  float sun=max(dot(rd,SUN),0.);
  vec3 c=mix(vec3(.1,.05,.2),vec3(.4,.1,.3),pow(max(rd.y,0.),.5));
  c+=SUN_COL*pow(sun,6.)*.5+vec3(1,.8,1)*pow(sun,128.);
  c+=vec3(.1,.3,.2)*pow(1.-abs(rd.y),4.);
  return max(c,0.);
}

float castT(vec3 ro,vec3 rd){float t=.1;for(int i=0;i<100;i++){vec3 p=ro+rd*t;float h=p.y-terrain(p.xz);if(h<.003*t)return t;t+=h*.35+.02;if(t>200.)break;}return-1.;}
float shadow(vec3 p,vec3 l){float t=.3,r=1.;for(int i=0;i<32;i++){vec3 s=p+l*t;float h=s.y-terrain(s.xz);if(h<.01)return 0.;r=min(r,8.*h/t);t+=h*.4+.1;if(t>40.)break;}return clamp(r,0.,1.);}

void main(){
  vec2 uv=(gl_FragCoord.xy-.5*uRes)/uRes.y;
  vec3 rd=normalize(uCamMat*vec3(uv,1.5)),ro=uCam,col=sky(rd);

  float tT=castT(ro,rd);
  if(tT>0.){
    vec3 p=ro+rd*tT,n=tNml(p.xz);float sh=shadow(p+n*.1,SUN);
    vec3 tc=.5+.5*cos(vec3(0,2,4)+p.y*.3+noise(p*2.)*4.);
    tc*=mix(vec3(.3,.1,.4),vec3(.1,.4,.3),n.y);
    float diff=max(dot(n,SUN),0.);
    col=tc*(diff*sh*SUN_COL+.2*vec3(.3,.2,.5));
    col+=vec3(.2,.6,.4)*smoothstep(5.,8.,p.y)*exp(-tT*.01);
    col=mix(col,sky(rd)*.5,1.-exp(-tT*.005));
  }
  col=aces(col);col=pow(col,vec3(1./2.2));
  gl_FragColor=vec4(col,1);
}`,

// ===== 3: MINIMAL SDF =====
COMMON + `
#define SUN normalize(vec3(.6,.8,.4))

float sdSphere(vec3 p,float r){return length(p)-r;}
float sdBox(vec3 p,vec3 b){vec3 d=abs(p)-b;return min(max(d.x,max(d.y,d.z)),0.)+length(max(d,0.));}

float scene(vec3 p){
  float d=p.y;
  d=min(d,sdSphere(p-vec3(0,1.5,0),1.5));
  d=min(d,sdBox(p-vec3(3.5,1,0),vec3(1)));
  vec2 q=vec2(length(p.xz-vec2(-3.5,0))-1.5,p.y-1.);
  d=min(d,length(q)-.4);
  vec3 rep=p;rep.xz=mod(p.xz+5.,10.)-5.;
  d=min(d,sdBox(rep-vec3(0,3,0),vec3(.3,3,.3)));
  return d;
}

vec3 sceneNml(vec3 p){float e=.001;return normalize(vec3(scene(p+vec3(e,0,0))-scene(p-vec3(e,0,0)),scene(p+vec3(0,e,0))-scene(p-vec3(0,e,0)),scene(p+vec3(0,0,e))-scene(p-vec3(0,0,e))));}
float castRay(vec3 ro,vec3 rd){float t=.001;for(int i=0;i<100;i++){float d=scene(ro+rd*t);if(d<.001)return t;t+=d;if(t>100.)break;}return-1.;}
float calcAO(vec3 p,vec3 n){float o=0.,s=1.;for(int i=1;i<=5;i++){float d=.05*float(i);o+=(d-scene(p+n*d))*s;s*=.75;}return clamp(1.-o*4.,0.,1.);}

vec3 sky(vec3 rd){float sun=max(dot(rd,SUN),0.);return vec3(.4,.6,.9)-rd.y*.3+vec3(1,.9,.7)*pow(sun,32.);}

void main(){
  vec2 uv=(gl_FragCoord.xy-.5*uRes)/uRes.y;
  vec3 rd=normalize(uCamMat*vec3(uv,2.)),ro=uCam,col=sky(rd);

  float t=castRay(ro,rd);
  if(t>0.){
    vec3 p=ro+rd*t,n=sceneNml(p);
    float diff=max(dot(n,SUN),0.),ao=calcAO(p,n);
    float spec=pow(max(dot(n,normalize(SUN-rd)),0.),64.)*.5;
    vec3 mat=vec3(.8)*(.5+.5*n);
    if(p.y<.01)mat=vec3(.5+.4*mod(floor(p.x)+floor(p.z),2.));
    col=mat*(diff*vec3(1,.95,.9)+.15*vec3(.4,.5,.7))*ao+spec*vec3(1,.95,.9);
    col=mix(col,sky(rd),1.-exp(-t*.008));
  }
  col=aces(col);col=pow(col,vec3(1./2.2));
  gl_FragColor=vec4(col,1);
}`,

// ===== 4: VOLCANIC HELLSCAPE =====
COMMON + `
#define SUN normalize(vec3(.2,.15,-.7))
#define SUN_COL vec3(2.2,.6,.2)
#define LAVA_Y -1.5

float terrain(vec2 p){
  float h=fbm(vec3(p*.1,0.))*18.;
  h+=fbm(vec3(p*.4,3.))*5.;
  h*=smoothstep(-3.,3.,h);
  float crater=smoothstep(8.,3.,length(p-vec2(15.,10.)))*-6.;
  h+=crater;
  return h-4.;
}

vec3 tNml(vec2 p){float e=.03;return normalize(vec3(terrain(p-vec2(e,0))-terrain(p+vec2(e,0)),2.*e,terrain(p-vec2(0,e))-terrain(p+vec2(0,e))));}

vec3 sky(vec3 rd){
  float sun=max(dot(rd,SUN),0.);
  vec3 c=mix(vec3(.08,.02,.01),vec3(.25,.08,.03),pow(max(rd.y,0.),.4));
  c+=SUN_COL*pow(sun,4.)*.4;
  c+=vec3(1,.3,.1)*pow(sun,64.);
  c+=vec3(.15,.03,.0)*pow(1.-abs(rd.y),5.);
  return max(c,0.);
}

float castT(vec3 ro,vec3 rd){float t=.1;for(int i=0;i<120;i++){vec3 p=ro+rd*t;float h=p.y-terrain(p.xz);if(h<.002*t)return t;t+=h*.35+.01;if(t>MAX_T)break;}return-1.;}
float shadow(vec3 p,vec3 l){float t=.3,r=1.;for(int i=0;i<40;i++){vec3 s=p+l*t;float h=s.y-terrain(s.xz);if(h<.01)return 0.;r=min(r,8.*h/t);t+=h*.35+.08;if(t>50.)break;}return clamp(r,0.,1.);}

vec3 lavaGlow(vec2 p){
  float n=fbm3(vec3(p*.5,uTime*.15));
  float n2=fbm3(vec3(p*.8,uTime*.1+5.));
  float heat=smoothstep(.35,.7,n)*smoothstep(.3,.6,n2);
  vec3 lava=mix(vec3(.8,.15,.0),vec3(1.,.7,.1),heat);
  lava+=vec3(.4,.05,.0)*sin(uTime*2.+p.x*3.)*.2;
  return lava*heat*2.;
}

void main(){
  vec2 uv=(gl_FragCoord.xy-.5*uRes)/uRes.y;
  vec3 rd=normalize(uCamMat*vec3(uv,1.5)),ro=uCam;
  vec3 col=sky(rd);float dist=MAX_T;

  float tT=castT(ro,rd);
  if(tT>0.){
    vec3 p=ro+rd*tT,n=tNml(p.xz);
    float sh=shadow(p+n*.1,SUN);
    float diff=max(dot(n,SUN),0.);
    vec3 tc=mix(vec3(.12,.08,.06),vec3(.25,.15,.1),smoothstep(.3,.7,n.y));
    tc=mix(tc,vec3(.05,.02,.01),smoothstep(6.,10.,p.y));
    tc*=.7+.3*noise(p*6.);
    float emb=smoothstep(LAVA_Y+2.,LAVA_Y+.5,p.y)*smoothstep(.7,.3,n.y);
    vec3 ember=vec3(.8,.2,.0)*emb*(.5+.5*sin(uTime*3.+p.x*2.));
    col=tc*(diff*sh*SUN_COL*.5+.1*vec3(.3,.15,.1))+ember;
    dist=tT;
  }

  if(rd.y<-.001){
    float tL=(LAVA_Y-ro.y)/rd.y;
    if(tL>0.&&tL<dist){
      vec3 lp=ro+rd*tL;
      vec3 lc=lavaGlow(lp.xz);
      float fr=pow(1.-max(dot(-rd,vec3(0,1,0)),0.),3.);
      col=mix(lc,col*.2,clamp(fr*.3,0.,.5));
      col+=vec3(.5,.1,.0)*exp(-max(0.,(lp.y-LAVA_Y))*2.);
      dist=tL;
    }
  }

  col=mix(col,sky(rd)*.5+vec3(.08,.02,.0),1.-exp(-dist*.004));
  col+=vec3(.15,.04,.0)*exp(-max(0.,ro.y-LAVA_Y)*.1)*(.5+.5*sin(uTime));
  col=aces(col*1.3);col=pow(col,vec3(1./2.2));
  gl_FragColor=vec4(col,1);
}`,

// ===== 5: CRYSTAL CAVERN =====
COMMON + `
#define SUN normalize(vec3(.3,.7,.5))
#define SUN_COL vec3(.8,1.2,1.6)

float sdBox(vec3 p,vec3 b){vec3 d=abs(p)-b;return min(max(d.x,max(d.y,d.z)),0.)+length(max(d,0.));}

float crystal(vec3 p){
  vec3 rp=p;
  rp.xz=mod(p.xz+3.,6.)-3.;
  float h=hash(floor((p.x+3.)/6.)+floor((p.z+3.)/6.)*137.);
  float height=2.+h*6.;
  float width=.3+h*.5;
  vec3 cp=rp-vec3(0,height*.5,0);
  float ang=h*PI*2.;
  float ca=cos(ang),sa=sin(ang);
  cp.xz=mat2(ca,-sa,sa,ca)*cp.xz;
  return sdBox(cp,vec3(width,height*.5,width*.7))-.05;
}

float scene(vec3 p){
  float ground=p.y+2.+fbm3(vec3(p.xz*.3,0.))*.8;
  float ceiling=-(p.y-12.-fbm3(vec3(p.xz*.2,5.))*2.);
  float cr=crystal(p);
  float stalac=crystal(vec3(p.x+1.5,-(p.y-11.),p.z+1.5))*.8;
  float d=min(ground,ceiling);
  d=min(d,cr);
  d=min(d,stalac);
  return d;
}

vec3 sceneNml(vec3 p){float e=.001;return normalize(vec3(scene(p+vec3(e,0,0))-scene(p-vec3(e,0,0)),scene(p+vec3(0,e,0))-scene(p-vec3(0,e,0)),scene(p+vec3(0,0,e))-scene(p-vec3(0,0,e))));}
float castRay(vec3 ro,vec3 rd){float t=.01;for(int i=0;i<120;i++){float d=scene(ro+rd*t);if(d<.001)return t;t+=d*.8;if(t>100.)break;}return-1.;}
float calcAO(vec3 p,vec3 n){float o=0.,s=1.;for(int i=1;i<=5;i++){float d=.08*float(i);o+=(d-scene(p+n*d))*s;s*=.7;}return clamp(1.-o*3.,0.,1.);}

vec3 sky(vec3 rd){return mix(vec3(.02,.04,.08),vec3(.05,.1,.2),max(rd.y,0.));}

void main(){
  vec2 uv=(gl_FragCoord.xy-.5*uRes)/uRes.y;
  vec3 rd=normalize(uCamMat*vec3(uv,1.8)),ro=uCam,col=sky(rd);

  float t=castRay(ro,rd);
  if(t>0.){
    vec3 p=ro+rd*t,n=sceneNml(p);
    float ao=calcAO(p,n);
    float diff=max(dot(n,SUN),0.);
    float spec=pow(max(dot(reflect(rd,n),SUN),0.),64.);
    float fresnel=pow(1.-max(dot(-rd,n),0.),4.);

    vec3 crystalColor=.5+.5*cos(vec3(0,2,4)+p.y*.4+noise(p*3.)*2.);
    float isCrystal=smoothstep(.5,.0,abs(scene(p)-crystal(p)));
    vec3 rockCol=mix(vec3(.15,.12,.1),vec3(.2,.18,.15),noise(p*4.));

    vec3 mat=mix(rockCol,crystalColor,isCrystal);
    float refStr=isCrystal*.6;

    vec3 rf=reflect(rd,n);
    float rT=castRay(p+n*.02,rf);
    vec3 refCol=sky(rf);
    if(rT>0.){vec3 rp=p+rf*(rT+.02);refCol=.5+.5*cos(vec3(0,2,4)+rp.y*.4)*.5;}

    col=mat*(diff*SUN_COL+.08*vec3(.3,.4,.6))*ao;
    col+=spec*SUN_COL*ao*.8;
    col=mix(col,refCol,fresnel*refStr);

    // Caustic shimmer
    float caustic=pow(abs(sin(p.x*3.+uTime)+sin(p.z*2.7+uTime*.8)),4.)*.15;
    col+=SUN_COL*caustic*isCrystal*ao;

    col=mix(col,vec3(.02,.05,.1),1.-exp(-t*.02));
  }
  col=aces(col*1.4);col=pow(col,vec3(1./2.2));
  gl_FragColor=vec4(col,1);
}`
];

// ===== CAMERA =====
const cam = {x:0, y:8, z:-10, yaw:0, pitch:-.15};
let autoFly = true, time = 0;
const keys = {};
let mDX = 0, mDY = 0, ptrLock = false;

// Restore camera from storage
if (stored.cam) { Object.assign(cam, stored.cam); }

function camMat() {
  const sy = Math.sin(cam.yaw), cy = Math.cos(cam.yaw);
  const sp = Math.sin(cam.pitch), cp = Math.cos(cam.pitch);
  return new Float32Array([
    cy, 0, sy,
    -sy*sp, cp, cy*sp,
    sy*cp, sp, -cy*cp
  ]);
}

function updateCam(dt) {
  if (autoFly) {
    time += dt;
    cam.z -= dt * 6;
    cam.x = Math.sin(time * 0.06) * 25;
    cam.yaw = Math.sin(time * 0.06) * 0.06 * 25 * Math.cos(time * 0.06) * 0.01;
    cam.y = 10 + Math.sin(time * 0.1) * 2;
    cam.pitch = .12 + Math.sin(time * 0.08) * .04;
    return;
  }
  time += dt;
  cam.yaw += mDX * .002; 
  cam.pitch = Math.max(-1.4, Math.min(1.4, cam.pitch - mDY * .002));
  mDX = mDY = 0;
  const spd = (keys['ShiftLeft'] || keys['ShiftRight']) ? 28 : 10;
  const sy = Math.sin(cam.yaw), cy = Math.cos(cam.yaw);
  if (keys['KeyW']) { cam.x += sy * spd * dt; cam.z -= cy * spd * dt; }
  if (keys['KeyS']) { cam.x -= sy * spd * dt; cam.z += cy * spd * dt; }
  if (keys['KeyA']) { cam.x -= cy * spd * dt; cam.z -= sy * spd * dt; }
  if (keys['KeyD']) { cam.x += cy * spd * dt; cam.z += sy * spd * dt; }
  if (keys['Space']) cam.y += spd * dt;
  if (keys['KeyC']) cam.y -= spd * dt;
}

// ===== INPUT =====
document.addEventListener('keydown', e => {
  keys[e.code] = true;
  if (e.code === 'Tab' && !e.ctrlKey) { e.preventDefault(); togglePanel(); }
  if (e.code === 'Space') e.preventDefault();
  if (e.code === 'KeyP' && !e.ctrlKey && !e.metaKey && document.activeElement !== codeEl) { e.preventDefault(); takeScreenshot(); }
  if (e.code === 'F11' || (e.code === 'KeyF' && (e.ctrlKey || e.metaKey))) {
    e.preventDefault();
    if (!document.fullscreenElement) document.documentElement.requestFullscreen();
    else document.exitFullscreen();
  }
  // Ctrl+S save shader
  if (e.code === 'KeyS' && (e.ctrlKey || e.metaKey)) { e.preventDefault(); openSaveModal(); }
  // Ctrl+1-6 load preset
  if ((e.ctrlKey || e.metaKey) && e.code >= 'Digit1' && e.code <= 'Digit6') {
    e.preventDefault();
    const idx = parseInt(e.code.charAt(5)) - 1;
    if (idx < PRESETS.length) { document.getElementById('presets').value = idx; loadPreset(idx); }
  }
});
document.addEventListener('keyup', e => { keys[e.code] = false; });
window.addEventListener('blur', () => { for (const k in keys) keys[k] = false; });
document.addEventListener('mousemove', e => { if (ptrLock) { mDX += e.movementX; mDY += e.movementY; } });

cv.addEventListener('click', () => {
  if (!ptrLock) {
    cv.requestPointerLock();
    autoFly = false;
    document.getElementById('overlay').classList.add('hide');
  }
});
document.addEventListener('pointerlockchange', () => {
  ptrLock = document.pointerLockElement === cv;
  if (!ptrLock) { for (const k in keys) keys[k] = false; }
  if (!ptrLock && !autoFly) document.getElementById('overlay').classList.remove('hide');
});

// ===== EDITOR =====
const codeEl = document.getElementById('code');
const panel = document.getElementById('panel');
const lineNums = document.getElementById('line-nums');
let curPreset = stored.preset || 0;
let customCode = stored.customCode || null;
let recompileTimer = null;

function updateLineNums() {
  const lines = codeEl.value.split('\n').length;
  let html = '';
  for (let i = 1; i <= lines; i++) html += i + '\n';
  lineNums.textContent = html;
}

function syncScroll() {
  lineNums.scrollTop = codeEl.scrollTop;
}

function loadPreset(i) {
  curPreset = i;
  codeEl.value = PRESETS[i];
  compile(PRESETS[i]);
  updateLineNums();
  customCode = null;
  persistState();
}

function togglePanel() {
  panel.classList.toggle('shut');
  const shut = panel.classList.contains('shut');
  document.getElementById('tog').textContent = shut ? '‚ñ∂ Editor' : '‚óÄ Hide';
  persistState();
}

codeEl.addEventListener('input', () => {
  clearTimeout(recompileTimer);
  compileInd.classList.add('active');
  recompileTimer = setTimeout(() => {
    compile(codeEl.value);
    customCode = codeEl.value;
    persistState();
  }, 400);
  updateLineNums();
});

codeEl.addEventListener('scroll', syncScroll);

codeEl.addEventListener('keydown', e => {
  if (e.key === 'Tab' && !e.ctrlKey && !e.metaKey) {
    e.preventDefault(); e.stopPropagation();
    const s = codeEl.selectionStart, end = codeEl.selectionEnd;
    codeEl.value = codeEl.value.substring(0, s) + '  ' + codeEl.value.substring(end);
    codeEl.selectionStart = codeEl.selectionEnd = s + 2;
    clearTimeout(recompileTimer);
    compileInd.classList.add('active');
    recompileTimer = setTimeout(() => {
      compile(codeEl.value);
      customCode = codeEl.value;
      persistState();
    }, 400);
    updateLineNums();
  }
});

document.getElementById('presets').addEventListener('change', e => loadPreset(parseInt(e.target.value)));
document.getElementById('tog').addEventListener('click', togglePanel);
document.getElementById('fs').addEventListener('click', () => {
  if (!document.fullscreenElement) document.documentElement.requestFullscreen();
  else document.exitFullscreen();
});
document.addEventListener('fullscreenchange', resize);

// ===== RESOLUTION CONTROL =====
const resSlider = document.getElementById('res-slider');
const resLabel = document.getElementById('res-label');
resSlider.value = Math.round(scale * 100);
resLabel.textContent = scale.toFixed(2) + 'x';

resSlider.addEventListener('input', () => {
  scale = parseInt(resSlider.value) / 100;
  resLabel.textContent = scale.toFixed(2) + 'x';
  resize();
  persistState();
});

// ===== SCREENSHOT =====
const flashEl = document.getElementById('flash');
function takeScreenshot() {
  // Force a render with preserveDrawingBuffer
  if (prog) {
    gl.useProgram(prog);
    if (locs.res) gl.uniform2f(locs.res, cv.width, cv.height);
    if (locs.time) gl.uniform1f(locs.time, time);
    if (locs.cam) gl.uniform3f(locs.cam, cam.x, cam.y, cam.z);
    if (locs.mat) gl.uniformMatrix3fv(locs.mat, false, camMat());
    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
  }
  flashEl.classList.add('fire');
  setTimeout(() => flashEl.classList.remove('fire'), 150);
  cv.toBlob(blob => {
    if (!blob) return;
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'raymarcher-' + Date.now() + '.png';
    a.click();
    setTimeout(() => URL.revokeObjectURL(url), 1000);
  }, 'image/png');
}

document.getElementById('btn-shot').addEventListener('click', takeScreenshot);

// ===== SAVE SLOTS =====
const MAX_SLOTS = 5;
const saveModal = document.getElementById('save-modal');
const saveNameInput = document.getElementById('save-name');
const slotsList = document.getElementById('slots-list');

function getSlots() {
  const s = loadStore();
  return s.slots || [];
}

function setSlots(slots) {
  const s = loadStore();
  s.slots = slots;
  saveStore(s);
}

function renderSlots() {
  const slots = getSlots();
  let html = '';
  for (let i = 0; i < MAX_SLOTS; i++) {
    const sl = slots[i];
    if (sl) {
      const d = new Date(sl.timestamp).toLocaleDateString();
      html += '<div class="slot"><div class="slot-info"><div class="slot-name">' + escHtml(sl.name) + '</div><div class="slot-date">' + d + '</div></div>';
      html += '<button onclick="loadSlot(' + i + ')" title="Load">‚ñ∂</button>';
      html += '<button class="del" onclick="deleteSlot(' + i + ')" title="Delete">‚úï</button></div>';
    } else {
      html += '<div class="slot empty">‚Äî empty slot ‚Äî</div>';
    }
  }
  slotsList.innerHTML = html;
}

function escHtml(s) { return s.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;'); }

function openSaveModal() {
  saveNameInput.value = '';
  renderSlots();
  saveModal.classList.add('show');
  saveNameInput.focus();
}

function closeSaveModal() {
  saveModal.classList.remove('show');
}

document.getElementById('btn-save').addEventListener('click', openSaveModal);
document.getElementById('save-cancel').addEventListener('click', closeSaveModal);
saveModal.addEventListener('click', e => { if (e.target === saveModal) closeSaveModal(); });

document.getElementById('save-confirm').addEventListener('click', () => {
  const name = saveNameInput.value.trim() || ('Shader ' + new Date().toLocaleTimeString());
  const slots = getSlots();
  // Find first empty slot or append
  let idx = slots.findIndex(s => !s);
  if (idx === -1 && slots.length < MAX_SLOTS) idx = slots.length;
  if (idx === -1) idx = MAX_SLOTS - 1; // overwrite last
  slots[idx] = {
    name: name,
    code: codeEl.value,
    cam: {x: cam.x, y: cam.y, z: cam.z, yaw: cam.yaw, pitch: cam.pitch},
    timestamp: Date.now()
  };
  setSlots(slots);
  renderSlots();
  saveNameInput.value = '';
});

saveNameInput.addEventListener('keydown', e => {
  if (e.key === 'Enter') document.getElementById('save-confirm').click();
  if (e.key === 'Escape') closeSaveModal();
  e.stopPropagation();
});

window.loadSlot = function(i) {
  const slots = getSlots();
  if (!slots[i]) return;
  codeEl.value = slots[i].code;
  compile(slots[i].code);
  updateLineNums();
  if (slots[i].cam) Object.assign(cam, slots[i].cam);
  customCode = slots[i].code;
  closeSaveModal();
  persistState();
};

window.deleteSlot = function(i) {
  const slots = getSlots();
  slots[i] = null;
  setSlots(slots);
  renderSlots();
};

// ===== PERSISTENCE =====
let persistTimer = null;
function persistState() {
  clearTimeout(persistTimer);
  persistTimer = setTimeout(() => {
    const s = loadStore();
    s.preset = curPreset;
    s.scale = scale;
    s.panelShut = panel.classList.contains('shut');
    s.cam = {x: cam.x, y: cam.y, z: cam.z, yaw: cam.yaw, pitch: cam.pitch};
    if (customCode) s.customCode = customCode;
    else delete s.customCode;
    saveStore(s);
  }, 500);
}

// ===== FPS =====
const fpsEl = document.getElementById('fps');
let frames = 0, fpsTime = 0;

// ===== INFO BAR =====
const infoTime = document.getElementById('info-time');
const infoCam = document.getElementById('info-cam');

// ===== INIT FROM STORAGE =====
if (stored.panelShut) { panel.classList.add('shut'); document.getElementById('tog').textContent = '‚ñ∂ Editor'; }
document.getElementById('presets').value = curPreset;
if (customCode) {
  codeEl.value = customCode;
  compile(customCode);
  updateLineNums();
} else {
  loadPreset(curPreset);
}

// ===== RENDER LOOP =====
let last = 0;

function loop(now) {
  const dt = Math.min((now - last) / 1000, 0.05); last = now;
  updateCam(dt);

  if (prog) {
    gl.useProgram(prog);
    if (locs.res) gl.uniform2f(locs.res, cv.width, cv.height);
    if (locs.time) gl.uniform1f(locs.time, time);
    if (locs.cam) gl.uniform3f(locs.cam, cam.x, cam.y, cam.z);
    if (locs.mat) gl.uniformMatrix3fv(locs.mat, false, camMat());
    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
  }

  frames++;
  fpsTime += dt;
  if (fpsTime >= .5) {
    fpsEl.textContent = Math.round(frames / fpsTime) + ' FPS';
    frames = 0; fpsTime = 0;
    // Update info bar
    infoTime.textContent = 'T: ' + time.toFixed(2);
    infoCam.textContent = 'Cam: ' + cam.x.toFixed(1) + ', ' + cam.y.toFixed(1) + ', ' + cam.z.toFixed(1);
  }

  requestAnimationFrame(loop);
}
requestAnimationFrame(t => { last = t; requestAnimationFrame(loop); });
</script>
</body>
</html>
